<html>
  <head>
    <title>Semantics Test Coverage Report</title>
    <meta charset="UTF-8">
    <style>
/*! normalize.css v3.0.2 | MIT License | git.io/normalize */

/**
 * 1. Set default font family to sans-serif.
 * 2. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
  font-family: sans-serif; /* 1 */
  -ms-text-size-adjust: 100%; /* 2 */
  -webkit-text-size-adjust: 100%; /* 2 */
}

/**
 * Remove default margin.
 */

body {
  margin: 0;
}

/* HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined for any HTML5 element in IE 8/9.
 * Correct `block` display not defined for `details` or `summary` in IE 10/11
 * and Firefox.
 * Correct `block` display not defined for `main` in IE 11.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
menu,
nav,
section,
summary {
  display: block;
}

/**
 * 1. Correct `inline-block` display not defined in IE 8/9.
 * 2. Normalize vertical alignment of `progress` in Chrome, Firefox, and Opera.
 */

audio,
canvas,
progress,
video {
  display: inline-block; /* 1 */
  vertical-align: baseline; /* 2 */
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
  display: none;
  height: 0;
}

/**
 * Address `[hidden]` styling not present in IE 8/9/10.
 * Hide the `template` element in IE 8/9/11, Safari, and Firefox < 22.
 */

[hidden],
template {
  display: none;
}

/* Links
   ========================================================================== */

/**
 * Remove the gray background color from active links in IE 10.
 */

a {
  background-color: transparent;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
  outline: 0;
}

/* Text-level semantics
   ========================================================================== */

/**
 * Address styling not present in IE 8/9/10/11, Safari, and Chrome.
 */

abbr[title] {
  border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 4+, Safari, and Chrome.
 */

b,
strong {
  font-weight: bold;
}

/**
 * Address styling not present in Safari and Chrome.
 */

dfn {
  font-style: italic;
}

/**
 * Address variable `h1` font-size and margin within `section` and `article`
 * contexts in Firefox 4+, Safari, and Chrome.
 */

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

/**
 * Address styling not present in IE 8/9.
 */

mark {
  background: #ff0;
  color: #000;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
  font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sup {
  top: -0.5em;
}

sub {
  bottom: -0.25em;
}

/* Embedded content
   ========================================================================== */

/**
 * Remove border when inside `a` element in IE 8/9/10.
 */

img {
  border: 0;
}

/**
 * Correct overflow not hidden in IE 9/10/11.
 */

svg:not(:root) {
  overflow: hidden;
}

/* Grouping content
   ========================================================================== */

/**
 * Address margin not present in IE 8/9 and Safari.
 */

figure {
  margin: 1em 40px;
}

/**
 * Address differences between Firefox and other browsers.
 */

hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

/**
 * Contain overflow in all browsers.
 */

pre {
  overflow: auto;
}

/**
 * Address odd `em`-unit font size rendering in all browsers.
 */

code,
kbd,
pre,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

/* Forms
   ========================================================================== */

/**
 * Known limitation: by default, Chrome and Safari on OS X allow very limited
 * styling of `select`, unless a `border` property is set.
 */

/**
 * 1. Correct color not being inherited.
 *    Known issue: affects color of disabled elements.
 * 2. Correct font properties not being inherited.
 * 3. Address margins set differently in Firefox 4+, Safari, and Chrome.
 */

button,
input,
optgroup,
select,
textarea {
  color: inherit; /* 1 */
  font: inherit; /* 2 */
  margin: 0; /* 3 */
}

/**
 * Address `overflow` set to `hidden` in IE 8/9/10/11.
 */

button {
  overflow: visible;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Firefox, IE 8/9/10/11, and Opera.
 * Correct `select` style inheritance in Firefox.
 */

button,
select {
  text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
  -webkit-appearance: button; /* 2 */
  cursor: pointer; /* 3 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
  cursor: default;
}

/**
 * Remove inner padding and border in Firefox 4+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
  border: 0;
  padding: 0;
}

/**
 * Address Firefox 4+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

input {
  line-height: normal;
}

/**
 * It's recommended that you don't attempt to style these elements.
 * Firefox's implementation doesn't respect box-sizing, padding, or width.
 *
 * 1. Address box sizing set to `content-box` in IE 8/9/10.
 * 2. Remove excess padding in IE 8/9/10.
 */

input[type="checkbox"],
input[type="radio"] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Fix the cursor style for Chrome's increment/decrement buttons. For certain
 * `font-size` values of the `input`, it causes the cursor style of the
 * decrement button to change from `default` to `text`.
 */

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  height: auto;
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
  -webkit-appearance: textfield; /* 1 */
  -moz-box-sizing: content-box;
  -webkit-box-sizing: content-box; /* 2 */
  box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari and Chrome on OS X.
 * Safari (but not Chrome) clips the cancel button when the search input has
 * padding (and `textfield` appearance).
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
  border: 1px solid #c0c0c0;
  margin: 0 2px;
  padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct `color` not being inherited in IE 8/9/10/11.
 * 2. Remove padding so people aren't caught out if they zero out fieldsets.
 */

legend {
  border: 0; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Remove default vertical scrollbar in IE 8/9/10/11.
 */

textarea {
  overflow: auto;
}

/**
 * Don't inherit the `font-weight` (applied by a rule above).
 * NOTE: the default cannot safely be changed in Chrome and Safari on OS X.
 */

optgroup {
  font-weight: bold;
}

/* Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
  border-collapse: collapse;
  border-spacing: 0;
}

td,
th {
  padding: 0;
}
/*
* Skeleton V2.0.4
* Copyright 2014, Dave Gamache
* www.getskeleton.com
* Free to use under the MIT license.
* http://www.opensource.org/licenses/mit-license.php
* 12/29/2014
*/


/* Table of contents
––––––––––––––––––––––––––––––––––––––––––––––––––
- Grid
- Base Styles
- Typography
- Links
- Buttons
- Forms
- Lists
- Code
- Tables
- Spacing
- Utilities
- Clearing
- Media Queries
*/


/* Grid
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }
.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }

/* For devices larger than 400px */
@media (min-width: 400px) {
  .container {
    width: 85%;
    padding: 0; }
}

/* For devices larger than 550px */
@media (min-width: 550px) {
  .container {
    width: 80%; }
  .column,
  .columns {
    margin-left: 4%; }
  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns                    { width: 4.66666666667%; }
  .two.columns                    { width: 13.3333333333%; }
  .three.columns                  { width: 22%;            }
  .four.columns                   { width: 30.6666666667%; }
  .five.columns                   { width: 39.3333333333%; }
  .six.columns                    { width: 48%;            }
  .seven.columns                  { width: 56.6666666667%; }
  .eight.columns                  { width: 65.3333333333%; }
  .nine.columns                   { width: 74.0%;          }
  .ten.columns                    { width: 82.6666666667%; }
  .eleven.columns                 { width: 91.3333333333%; }
  .twelve.columns                 { width: 100%; margin-left: 0; }

  .one-third.column               { width: 30.6666666667%; }
  .two-thirds.column              { width: 65.3333333333%; }

  .one-half.column                { width: 48%; }

  /* Offsets */
  .offset-by-one.column,
  .offset-by-one.columns          { margin-left: 8.66666666667%; }
  .offset-by-two.column,
  .offset-by-two.columns          { margin-left: 17.3333333333%; }
  .offset-by-three.column,
  .offset-by-three.columns        { margin-left: 26%;            }
  .offset-by-four.column,
  .offset-by-four.columns         { margin-left: 34.6666666667%; }
  .offset-by-five.column,
  .offset-by-five.columns         { margin-left: 43.3333333333%; }
  .offset-by-six.column,
  .offset-by-six.columns          { margin-left: 52%;            }
  .offset-by-seven.column,
  .offset-by-seven.columns        { margin-left: 60.6666666667%; }
  .offset-by-eight.column,
  .offset-by-eight.columns        { margin-left: 69.3333333333%; }
  .offset-by-nine.column,
  .offset-by-nine.columns         { margin-left: 78.0%;          }
  .offset-by-ten.column,
  .offset-by-ten.columns          { margin-left: 86.6666666667%; }
  .offset-by-eleven.column,
  .offset-by-eleven.columns       { margin-left: 95.3333333333%; }

  .offset-by-one-third.column,
  .offset-by-one-third.columns    { margin-left: 34.6666666667%; }
  .offset-by-two-thirds.column,
  .offset-by-two-thirds.columns   { margin-left: 69.3333333333%; }

  .offset-by-one-half.column,
  .offset-by-one-half.columns     { margin-left: 52%; }

}


/* Base Styles
–––––––––––––––––––––––––––––––––––––––––––––––––– */
/* NOTE
html is set to 62.5% so that all the REM measurements throughout Skeleton
are based on 10px sizing. So basically 1.5rem = 15px :) */
html {
  font-size: 62.5%; }
body {
  font-size: 1.5em; /* currently ems cause chrome bug misinterpreting rems on body element */
  line-height: 1.6;
  font-weight: 400;
  font-family: "Raleway", "HelveticaNeue", "Helvetica Neue", Helvetica, Arial, sans-serif;
  color: #222; }


/* Typography
–––––––––––––––––––––––––––––––––––––––––––––––––– */
h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
  margin-bottom: 2rem;
  font-weight: 300; }
h1 { font-size: 4.0rem; line-height: 1.2;  letter-spacing: -.1rem;}
h2 { font-size: 3.6rem; line-height: 1.25; letter-spacing: -.1rem; }
h3 { font-size: 3.0rem; line-height: 1.3;  letter-spacing: -.1rem; }
h4 { font-size: 2.4rem; line-height: 1.35; letter-spacing: -.08rem; }
h5 { font-size: 1.8rem; line-height: 1.5;  letter-spacing: -.05rem; }
h6 { font-size: 1.5rem; line-height: 1.6;  letter-spacing: 0; }

/* Larger than phablet */
@media (min-width: 550px) {
  h1 { font-size: 5.0rem; }
  h2 { font-size: 4.2rem; }
  h3 { font-size: 3.6rem; }
  h4 { font-size: 3.0rem; }
  h5 { font-size: 2.4rem; }
  h6 { font-size: 1.5rem; }
}

p {
  margin-top: 0; }


/* Links
–––––––––––––––––––––––––––––––––––––––––––––––––– */
a {
  color: #1EAEDB; }
a:hover {
  color: #0FA0CE; }


/* Buttons
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.button,
button,
input[type="submit"],
input[type="reset"],
input[type="button"] {
  display: inline-block;
  height: 38px;
  padding: 0 30px;
  color: #555;
  text-align: center;
  font-size: 11px;
  font-weight: 600;
  line-height: 38px;
  letter-spacing: .1rem;
  text-transform: uppercase;
  text-decoration: none;
  white-space: nowrap;
  background-color: transparent;
  border-radius: 4px;
  border: 1px solid #bbb;
  cursor: pointer;
  box-sizing: border-box; }
.button:hover,
button:hover,
input[type="submit"]:hover,
input[type="reset"]:hover,
input[type="button"]:hover,
.button:focus,
button:focus,
input[type="submit"]:focus,
input[type="reset"]:focus,
input[type="button"]:focus {
  color: #333;
  border-color: #888;
  outline: 0; }
.button.button-primary,
button.button-primary,
input[type="submit"].button-primary,
input[type="reset"].button-primary,
input[type="button"].button-primary {
  color: #FFF;
  background-color: #33C3F0;
  border-color: #33C3F0; }
.button.button-primary:hover,
button.button-primary:hover,
input[type="submit"].button-primary:hover,
input[type="reset"].button-primary:hover,
input[type="button"].button-primary:hover,
.button.button-primary:focus,
button.button-primary:focus,
input[type="submit"].button-primary:focus,
input[type="reset"].button-primary:focus,
input[type="button"].button-primary:focus {
  color: #FFF;
  background-color: #1EAEDB;
  border-color: #1EAEDB; }


/* Forms
–––––––––––––––––––––––––––––––––––––––––––––––––– */
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea,
select {
  height: 38px;
  padding: 6px 10px; /* The 6px vertically centers text on FF, ignored by Webkit */
  background-color: #fff;
  border: 1px solid #D1D1D1;
  border-radius: 4px;
  box-shadow: none;
  box-sizing: border-box; }
/* Removes awkward default styles on some inputs for iOS */
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none; }
textarea {
  min-height: 65px;
  padding-top: 6px;
  padding-bottom: 6px; }
input[type="email"]:focus,
input[type="number"]:focus,
input[type="search"]:focus,
input[type="text"]:focus,
input[type="tel"]:focus,
input[type="url"]:focus,
input[type="password"]:focus,
textarea:focus,
select:focus {
  border: 1px solid #33C3F0;
  outline: 0; }
label,
legend {
  display: block;
  margin-bottom: .5rem;
  font-weight: 600; }
fieldset {
  padding: 0;
  border-width: 0; }
input[type="checkbox"],
input[type="radio"] {
  display: inline; }
label > .label-body {
  display: inline-block;
  margin-left: .5rem;
  font-weight: normal; }


/* Lists
–––––––––––––––––––––––––––––––––––––––––––––––––– */
ul {
  list-style: circle inside; }
ol {
  list-style: decimal inside; }
ol, ul {
  padding-left: 0;
  margin-top: 0; }
ul ul,
ul ol,
ol ol,
ol ul {
  margin: 1.5rem 0 1.5rem 3rem;
  font-size: 90%; }
li {
  margin-bottom: 1rem; }


/* Code
–––––––––––––––––––––––––––––––––––––––––––––––––– */
code {
  padding: .2rem .5rem;
  margin: 0 .2rem;
  font-size: 90%;
  white-space: nowrap;
  background: #F1F1F1;
  border: 1px solid #E1E1E1;
  border-radius: 4px; }
pre > code {
  display: block;
  padding: 1rem 1.5rem;
  white-space: pre; }


/* Tables
–––––––––––––––––––––––––––––––––––––––––––––––––– */
th,
td {
  padding: 12px 15px;
  text-align: left;
  border-bottom: 1px solid #E1E1E1; }
th:first-child,
td:first-child {
  padding-left: 0; }
th:last-child,
td:last-child {
  padding-right: 0; }


/* Spacing
–––––––––––––––––––––––––––––––––––––––––––––––––– */
button,
.button {
  margin-bottom: 1rem; }
input,
textarea,
select,
fieldset {
  margin-bottom: 1.5rem; }
pre,
blockquote,
dl,
figure,
table,
p,
ul,
ol,
form {
  margin-bottom: 2.5rem; }


/* Utilities
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.u-full-width {
  width: 100%;
  box-sizing: border-box; }
.u-max-full-width {
  max-width: 100%;
  box-sizing: border-box; }
.u-pull-right {
  float: right; }
.u-pull-left {
  float: left; }


/* Misc
–––––––––––––––––––––––––––––––––––––––––––––––––– */
hr {
  margin-top: 3rem;
  margin-bottom: 3.5rem;
  border-width: 0;
  border-top: 1px solid #E1E1E1; }


/* Clearing
–––––––––––––––––––––––––––––––––––––––––––––––––– */

/* Self Clearing Goodness */
.container:after,
.row:after,
.u-cf {
  content: "";
  display: table;
  clear: both; }


/* Media Queries
–––––––––––––––––––––––––––––––––––––––––––––––––– */
/*
Note: The best way to structure the use of media queries is to create the queries
near the relevant code. For example, if you wanted to change the styles for buttons
on small devices, paste the mobile query code up in the buttons section and style it
there.
*/


/* Larger than mobile */
@media (min-width: 400px) {}

/* Larger than phablet (also point when grid becomes active) */
@media (min-width: 550px) {}

/* Larger than tablet */
@media (min-width: 750px) {}

/* Larger than desktop */
@media (min-width: 1000px) {}

/* Larger than Desktop HD */
@media (min-width: 1200px) {}
.hit {background-color: #EAFFEA}
.miss {background-color: #FFECEC}
.container .code {margin-left: 0}
pre {line-height: 1.3}
    </style>
  </head>
  <body>
    <div class="container">
      <h1>pycobertura report</h1>
      <table class="u-full-width">
        <thead>
          <tr>
            <th>Filename</th>
            <th>Stmts</th>
            <th>Miss</th>
            <th>Cover</th>
            <th>Missing</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><a href="#avm/blockchain.md">avm/blockchain.md</a></td>
            <td>103</td>
            <td>38</td>
            <td>63.11%</td>
            <td>900, 576, 454, 520, 30, 57, 736, 63-512, 281, 330, 377-395, 438, 29-536, 363, 679, 669, 370, 323-676, 356, 528, 354-384, 288-544, 309, 457, 32, 277, 28, 270-448</td>
          </tr>
          <tr>
            <td><a href="#avm/constants.md">avm/constants.md</a></td>
            <td>15</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#avm/txn.md">avm/txn.md</a></td>
            <td>89</td>
            <td>56</td>
            <td>37.08%</td>
            <td>644-781, 452, 380, 434, 344-489, 309-671, 916, 572, 554, 407, 291, 909, 257-825, 859, 362-911, 905, 425-907, 653, 680, 389, 219, 590, 545-900, 335, 903, 635, 498, 300, 608, 416-837, 812, 917, 266-626, 398, 371-443, 211-282, 581-599, 240, 617-772</td>
          </tr>
          <tr>
            <td><a href="#avm/itxn.md">avm/itxn.md</a></td>
            <td>69</td>
            <td>37</td>
            <td>46.38%</td>
            <td>320-400, 275-287, 148, 100-382, 299, 293, 478, 47, 222, 130-314, 124-136, 118-180, 406, 326, 216, 204, 228, 234, 29-496, 376, 240, 281, 41-94, 35, 505, 142-252</td>
          </tr>
          <tr>
            <td><a href="#avm/avm-configuration.md">avm/avm-configuration.md</a></td>
            <td>18</td>
            <td>6</td>
            <td>66.67%</td>
            <td>158, 128, 157-161, 159-160</td>
          </tr>
          <tr>
            <td><a href="#avm/avm-execution.md">avm/avm-execution.md</a></td>
            <td>49</td>
            <td>17</td>
            <td>65.31%</td>
            <td>166, 514-1102, 69, 1105, 1099, 1045, 424, 654, 37, 740-940, 230, 633, 445, 610, 597</td>
          </tr>
          <tr>
            <td><a href="#avm/avm-initialization.md">avm/avm-initialization.md</a></td>
            <td>21</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#avm/avm-limits.md">avm/avm-limits.md</a></td>
            <td>10</td>
            <td>5</td>
            <td>50.00%</td>
            <td>30-35, 28-29, 31</td>
          </tr>
          <tr>
            <td><a href="#avm/avm-txn-deque.md">avm/avm-txn-deque.md</a></td>
            <td>10</td>
            <td>6</td>
            <td>40.00%</td>
            <td>51, 112, 78, 47-104, 74</td>
          </tr>
          <tr>
            <td><a href="#avm/teal/teal-constants.md">avm/teal/teal-constants.md</a></td>
            <td>53</td>
            <td>26</td>
            <td>50.94%</td>
            <td>85, 132-135, 130, 124-139, 79-117, 88-118, 123, 134, 121-126, 78, 122, 120, 92, 83-138, 125, 119, 87, 91</td>
          </tr>
          <tr>
            <td><a href="#avm/teal/teal-driver.md">avm/teal/teal-driver.md</a></td>
            <td>358</td>
            <td>244</td>
            <td>31.84%</td>
            <td>530, 602-1219, 184-1232, 1135, 483, 231, 1844-2333, 2306, 793, 1025, 58-1970, 505, 179, 497-2131, 1105, 666, 379, 117, 61-1370, 2061, 346, 146, 2340, 1651-2044, 2346, 1647, 568-866, 813, 454, 187, 1338, 316, 148, 1966-2383, 2260, 717-1178, 1160, 493-2010, 271, 44-2036, 823-2070, 1205, 1079-2368, 2299-2359, 2040, 165-1554, 536, 200, 846-878, 270-1694, 545, 98-2116, 1145, 614, 2006, 755, 415, 350-940, 122-999, 466-767, 391-939, 891, 320-994, 285, 745-1050, 979, 149, 55, 1066, 560, 1778, 139, 129, 1301-2018, 709, 2151, 399-1095, 807, 685, 513, 2310, 363-445, 1020-1175, 926, 387-2323, 817-1341, 915, 779-883, 404-1438, 701, 774-2054, 2287, 1887, 595-1960, 1087, 354, 1324, 673-1004, 657, 650-1465, 266, 1130, 1713, 1428, 150, 221-918, 2313, 783, 304-1597, 693-896, 928, 358-942, 300-459, 49, 167-2027, 169-725, 367-1126, 235, 86, 1836, 841-1735, 641, 135-2319, 836-1933, 1601, 1292, 759-2002, 1840, 1643-2172, 217, 212, 151-2343, 194, 2291, 1099, 950, 329-1170, 902-1877, 376, 1447, 269, 161-2075, 634-1892, 168-2316, 2326, 1262, 1110, 851, 583, 989, 933, 553, 1364, 927-1155, 372, 1345, 870, 334, 789-2175, 1522-2264, 292-925, 1081, 1570, 449-1743, 751, 575-941</td>
          </tr>
          <tr>
            <td><a href="#avm/teal/teal-execution.md">avm/teal/teal-execution.md</a></td>
            <td>110</td>
            <td>31</td>
            <td>71.82%</td>
            <td>116, 64, 135, 146-462, 458, 432, 253-440, 460, 451, 463, 430-450, 452, 248, 461, 234, 441, 456, 449, 144, 131, 92, 429, 93, 147, 126-454</td>
          </tr>
          <tr>
            <td><a href="#avm/teal/teal-stack.md">avm/teal/teal-stack.md</a></td>
            <td>17</td>
            <td>2</td>
            <td>88.24%</td>
            <td>32, 41</td>
          </tr>
          <tr>
            <td><a href="#avm/teal/teal-syntax.md">avm/teal/teal-syntax.md</a></td>
            <td>3</td>
            <td>1</td>
            <td>66.67%</td>
            <td>391</td>
          </tr>
          <tr>
            <td><a href="#avm/teal/teal-types.md">avm/teal/teal-types.md</a></td>
            <td>48</td>
            <td>12</td>
            <td>75.00%</td>
            <td>228, 232, 112, 119, 233, 227, 154, 158-241, 177-217</td>
          </tr>
        </tbody>
        <tfoot>
          <tr>
            <td>TOTAL</td>
            <td>973</td>
            <td>481</td>
            <td>47.50%</td>
            <td></td>
          </tr>
        </tfoot>
      </table>
<h4 id="avm/blockchain.md">avm/blockchain.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">Algorand Blockchain Model
</span><span class="noop">=========================
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">requires &#34;avm/teal/teal-constants.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-fields.md&#34;
</span><span class="noop">requires &#34;avm/additional-fields.md&#34;
</span><span class="noop">requires &#34;avm/txn.md&#34;
</span><span class="noop">requires &#34;constants.md&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Global Field State Representation
</span><span class="noop">---------------------------------
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module GLOBALS
</span><span class="noop">  imports TEAL-CONSTANTS
</span><span class="noop">  imports TEAL-FIELDS
</span><span class="noop">  imports ALGO-TXN
</span><span class="noop">  imports AVM-CONSTANTS
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Global Accessors*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TValue ::= getGlobalField(GlobalField) [function]
</span><span class="noop">  // ----------------------------------------------------
</span><span class="miss">  rule getGlobalField(MinTxnFee)       =&gt; PARAM_MIN_TXN_FEE
</span><span class="miss">  rule getGlobalField(MinBalance)      =&gt; PARAM_MIN_BALANCE
</span><span class="miss">  rule getGlobalField(MaxTxnLife)      =&gt; PARAM_MAX_TXN_LIFE
</span><span class="hit">  rule getGlobalField(ZeroAddress)     =&gt; b&#34;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#34;
</span><span class="miss">  rule getGlobalField(LogicSigVersion) =&gt; 2
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Globals maintained in the state*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  configuration
</span><span class="noop">    &lt;globals&gt;
</span><span class="noop">      &lt;groupSize&gt;                 0 &lt;/groupSize&gt;
</span><span class="noop">      &lt;globalRound&gt;               0 &lt;/globalRound&gt;
</span><span class="noop">      &lt;latestTimestamp&gt;           0 &lt;/latestTimestamp&gt;
</span><span class="noop">      &lt;currentApplicationID&gt;      0 &lt;/currentApplicationID&gt;
</span><span class="noop">      &lt;currentApplicationAddress&gt; .Bytes &lt;/currentApplicationAddress&gt;
</span><span class="noop">    &lt;/globals&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*State accessor functions*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule [[ getGlobalField(GroupSize) =&gt; V ]]
</span><span class="noop">       &lt;globals&gt;
</span><span class="noop">         &lt;groupSize&gt; V &lt;/groupSize&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/globals&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getGlobalField(Round) =&gt; V ]]
</span><span class="noop">       &lt;globals&gt;
</span><span class="noop">         &lt;globalRound&gt; V &lt;/globalRound&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/globals&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getGlobalField(LatestTimestamp) =&gt; V ]]
</span><span class="noop">       &lt;globals&gt;
</span><span class="noop">         &lt;latestTimestamp&gt; V &lt;/latestTimestamp&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/globals&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getGlobalField(CurrentApplicationID) =&gt; V ]]
</span><span class="noop">       &lt;globals&gt;
</span><span class="noop">         &lt;currentApplicationID&gt; V &lt;/currentApplicationID&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/globals&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getGlobalField(CurrentApplicationAddress) =&gt; V ]]
</span><span class="noop">       &lt;globals&gt;
</span><span class="noop">         &lt;currentApplicationAddress&gt; V &lt;/currentApplicationAddress&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/globals&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">endmodule
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Application State Representation
</span><span class="noop">--------------------------------
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module APPLICATIONS
</span><span class="noop">  imports ALGO-TXN
</span><span class="noop">  imports TEAL-SYNTAX
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Application Configuration*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  // Note: - only 64bit keys and 64bit values may be used in the key/value storage
</span><span class="noop">  //       - only up to 64 key-value pairs for global storage and 16 key-value pairs for local storage.
</span><span class="noop">  configuration
</span><span class="noop">    &lt;appsCreated&gt;
</span><span class="noop">      &lt;app multiplicity=&#34;*&#34; type=&#34;Map&#34;&gt;
</span><span class="noop">        &lt;appID&gt;           NoTValue  &lt;/appID&gt;
</span><span class="noop">        &lt;approvalPgmSrc&gt;     (int 0):TealInputPgm &lt;/approvalPgmSrc&gt;
</span><span class="noop">        &lt;clearStatePgmSrc&gt;   (int 1):TealInputPgm &lt;/clearStatePgmSrc&gt;
</span><span class="noop">        &lt;approvalPgm&gt;     NoTValue &lt;/approvalPgm&gt;
</span><span class="noop">        &lt;clearStatePgm&gt;   NoTValue &lt;/clearStatePgm&gt;
</span><span class="noop">        &lt;globalState&gt;
</span><span class="noop">          &lt;globalNumInts&gt;     NoTValue &lt;/globalNumInts&gt;
</span><span class="noop">          &lt;globalNumBytes&gt;    NoTValue &lt;/globalNumBytes&gt;
</span><span class="noop">          &lt;globalBytes&gt;  .Map     &lt;/globalBytes&gt;
</span><span class="noop">          &lt;globalInts&gt;  .Map     &lt;/globalInts&gt;
</span><span class="noop">        &lt;/globalState&gt;
</span><span class="noop">        &lt;localState&gt;
</span><span class="noop">          &lt;localNumInts&gt;      NoTValue &lt;/localNumInts&gt;
</span><span class="noop">          &lt;localNumBytes&gt;     NoTValue &lt;/localNumBytes&gt;
</span><span class="noop">        &lt;/localState&gt;
</span><span class="noop">        &lt;extraPages&gt;       NoTValue &lt;/extraPages&gt;
</span><span class="noop">      &lt;/app&gt;
</span><span class="noop">    &lt;/appsCreated&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Opted-in Applications Configuration*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  configuration
</span><span class="noop">    &lt;appsOptedIn&gt;
</span><span class="noop">      &lt;optInApp multiplicity=&#34;*&#34; type=&#34;Map&#34;&gt;
</span><span class="noop">        &lt;optInAppID&gt;   NoTValue &lt;/optInAppID&gt;
</span><span class="noop">        &lt;localInts&gt; .Map    &lt;/localInts&gt;
</span><span class="noop">        &lt;localBytes&gt; .Map    &lt;/localBytes&gt;
</span><span class="noop">      &lt;/optInApp&gt;
</span><span class="noop">    &lt;/appsOptedIn&gt;
</span><span class="noop">
</span><span class="noop">endmodule
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Asset State Representation
</span><span class="noop">--------------------------
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module ASSETS
</span><span class="noop">  imports ALGO-TXN
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Asset Configuration*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">/*
</span><span class="noop">  Note: - An account may create up to 1000 assets.
</span><span class="noop">        - For every asset an account creates or owns, its minimum balance is increased by 100,000 microAlgos.
</span><span class="noop">        - Before a new asset can be transferred to an account, it must opt-in to receive the asset.
</span><span class="noop"> */
</span><span class="noop">
</span><span class="noop">  configuration
</span><span class="noop">    &lt;assetsCreated&gt;
</span><span class="noop">      &lt;asset multiplicity=&#34;*&#34; type=&#34;Map&#34;&gt;
</span><span class="noop">        &lt;assetID&gt;            NoTValue &lt;/assetID&gt;
</span><span class="noop">        &lt;assetName&gt;          NoTValue &lt;/assetName&gt;
</span><span class="noop">        &lt;assetUnitName&gt;      NoTValue &lt;/assetUnitName&gt;
</span><span class="noop">        &lt;assetTotal&gt;         NoTValue &lt;/assetTotal&gt;
</span><span class="noop">        &lt;assetDecimals&gt;      NoTValue &lt;/assetDecimals&gt;
</span><span class="noop">        &lt;assetDefaultFrozen&gt; NoTValue &lt;/assetDefaultFrozen&gt;
</span><span class="noop">        &lt;assetURL&gt;           NoTValue &lt;/assetURL&gt;
</span><span class="noop">        &lt;assetMetaDataHash&gt;  NoTValue &lt;/assetMetaDataHash&gt;
</span><span class="noop">        &lt;assetManagerAddr&gt;   NoTValue &lt;/assetManagerAddr&gt;
</span><span class="noop">        &lt;assetReserveAddr&gt;   NoTValue &lt;/assetReserveAddr&gt;
</span><span class="noop">        &lt;assetFreezeAddr&gt;    NoTValue &lt;/assetFreezeAddr&gt;
</span><span class="noop">        &lt;assetClawbackAddr&gt;  NoTValue &lt;/assetClawbackAddr&gt;
</span><span class="noop">      &lt;/asset&gt;
</span><span class="noop">    &lt;/assetsCreated&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Opted-in Assets Configuration*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  configuration
</span><span class="noop">    &lt;assetsOptedIn&gt;
</span><span class="noop">      &lt;optInAsset multiplicity=&#34;*&#34; type=&#34;Map&#34;&gt;
</span><span class="noop">        &lt;optInAssetID&gt;      NoTValue &lt;/optInAssetID&gt;
</span><span class="noop">        &lt;optInAssetBalance&gt; NoTValue &lt;/optInAssetBalance&gt;
</span><span class="noop">        &lt;optInAssetFrozen&gt;  NoTValue &lt;/optInAssetFrozen&gt;
</span><span class="noop">      &lt;/optInAsset&gt;
</span><span class="noop">    &lt;/assetsOptedIn&gt;
</span><span class="noop">endmodule
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Blockchain State Representation
</span><span class="noop">-------------------------------
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module ALGO-BLOCKCHAIN
</span><span class="noop">  imports GLOBALS
</span><span class="noop">  imports APPLICATIONS
</span><span class="noop">  imports ASSETS
</span><span class="noop">  imports ADDITIONAL-FIELDS
</span><span class="noop">  imports TEAL-SYNTAX
</span><span class="noop">  imports TEAL-TYPES-SYNTAX
</span><span class="noop">  imports MAP
</span><span class="noop">
</span><span class="noop">  // Note: An address is the base32 encoding of a {pub key + 4-byte checksum}
</span><span class="noop">  // Note: There are three ways in which an account may be created:
</span><span class="noop">  //       1. Creating an address (standard address)
</span><span class="noop">  //       2. Produced by a compiled TEAL program (LogicSig program address)
</span><span class="noop">  //       3. Created through a multisignature account (MultiSig address)
</span><span class="noop">  //          -- not modeled (two more fields: Threshold, list of accounts)
</span><span class="noop">
</span><span class="noop">  configuration
</span><span class="noop">    &lt;blockchain&gt;
</span><span class="noop">      &lt;accountsMap&gt;
</span><span class="noop">        &lt;account multiplicity=&#34;*&#34; type=&#34;Map&#34;&gt;
</span><span class="noop">          &lt;address&gt;    &#34;&#34;:TBytes &lt;/address&gt;
</span><span class="noop">          &lt;balance&gt;    0                  &lt;/balance&gt;
</span><span class="noop">          &lt;minBalance&gt; PARAM_MIN_BALANCE  &lt;/minBalance&gt; // the default min balance is 0.1 Algo
</span><span class="noop">          &lt;round&gt;      0                  &lt;/round&gt;
</span><span class="noop">          &lt;preRewards&gt; 0                  &lt;/preRewards&gt;
</span><span class="noop">          &lt;rewards&gt;    0                  &lt;/rewards&gt;
</span><span class="noop">          &lt;status&gt;     0                  &lt;/status&gt;
</span><span class="noop">          &lt;key&gt;        &#34;&#34;:TBytes &lt;/key&gt;
</span><span class="noop">          &lt;appsCreated/&gt;
</span><span class="noop">          &lt;appsOptedIn/&gt;
</span><span class="noop">          &lt;assetsCreated/&gt;
</span><span class="noop">          &lt;assetsOptedIn/&gt;
</span><span class="noop">        &lt;/account&gt;
</span><span class="noop">      &lt;/accountsMap&gt;
</span><span class="noop">      &lt;appCreator&gt;   .Map &lt;/appCreator&gt;   // AppID |-&gt; Creator&#39;s address
</span><span class="noop">      &lt;assetCreator&gt; .Map &lt;/assetCreator&gt; // AssetID |-&gt; Creator&#39;s address
</span><span class="noop">      &lt;blocks&gt;       .Map &lt;/blocks&gt;       // Int -&gt; Block (Unused)
</span><span class="noop">      &lt;blockheight&gt;  0    &lt;/blockheight&gt;
</span><span class="noop">      &lt;nextAssetID&gt;  1    &lt;/nextAssetID&gt;
</span><span class="noop">      &lt;nextAppID&gt;    1    &lt;/nextAppID&gt;
</span><span class="noop">      &lt;nextTxnID&gt;    0    &lt;/nextTxnID&gt;
</span><span class="noop">      &lt;nextGroupID&gt;  1    &lt;/nextGroupID&gt;
</span><span class="noop">      &lt;txnIndexMap&gt;
</span><span class="noop">        &lt;txnIndexMapGroup multiplicity=&#34;*&#34; type=&#34;Map&#34;&gt;
</span><span class="noop">          &lt;txnIndexMapGroupKey&gt; &#34;&#34;:String &lt;/txnIndexMapGroupKey&gt;
</span><span class="noop">          &lt;txnIndexMapGroupValues&gt; .Map &lt;/txnIndexMapGroupValues&gt; // GroupIdx (offset) |-&gt; Transaction ID
</span><span class="noop">        &lt;/txnIndexMapGroup&gt;
</span><span class="noop">      &lt;/txnIndexMap&gt;
</span><span class="noop">    &lt;/blockchain&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax String ::= getCurrentTxn() [function]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Accessor functions
</span><span class="noop">------------------
</span><span class="noop">
</span><span class="noop">### Account State Accessors
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax MaybeTValue ::= getAccountParamsField(AccountParamsField, TValue)  [function, functional]
</span><span class="noop">  //----------------------------------------------------------------------------------------------
</span><span class="hit">  rule [[ getAccountParamsField(AcctBalance, ADDR) =&gt; BAL ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;balance&gt; BAL &lt;/balance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getAccountParamsField(AcctMinBalance, ADDR) =&gt; MIN_BAL ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BAL &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAccountParamsField(AcctAuthAddr, ADDR) =&gt; KEY ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;key&gt; KEY &lt;/key&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="miss">  rule getAccountParamsField(_, _) =&gt; NoTValue  [owise]
</span><span class="noop">
</span><span class="noop">  syntax MaybeTValue ::= getAppParamsField(AppParamsField, Int) [function, functional]
</span><span class="noop">  //----------------------------------------------------------------------------------
</span><span class="miss">  rule [[ getAppParamsField(AppApprovalProgram, APP) =&gt; X ]]
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;approvalPgm&gt; X &lt;/approvalPgm&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAppParamsField(AppClearStateProgram, APP) =&gt; X ]]
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;clearStatePgm&gt; X &lt;/clearStatePgm&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getAppParamsField(AppGlobalNumUint, APP) =&gt; X ]]
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;globalNumInts&gt; X &lt;/globalNumInts&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAppParamsField(AppGlobalNumByteSlice, APP) =&gt; X ]]
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;globalNumBytes&gt; X &lt;/globalNumBytes&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAppParamsField(AppLocalNumUint, APP) =&gt; X ]]
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;localNumInts&gt; X &lt;/localNumInts&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getAppParamsField(AppLocalNumByteSlice, APP) =&gt; X ]]
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;localNumBytes&gt; X &lt;/localNumBytes&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAppParamsField(AppExtraProgramPages, APP) =&gt; X ]]
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;extraPages&gt; X &lt;/extraPages&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAppParamsField(AppCreator, APP) =&gt; X ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; X &lt;/address&gt;
</span><span class="noop">         &lt;appsCreated&gt;
</span><span class="noop">           &lt;app&gt;
</span><span class="noop">             &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">             &lt;extraPages&gt; X &lt;/extraPages&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/app&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/appsCreated&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getAppParamsField(AppAddress, APP) =&gt; getAppAddress(APP) ]]
</span><span class="noop">       &lt;accountsMap&gt; AM &lt;/accountsMap&gt;
</span><span class="noop">    requires APP in_apps(&lt;accountsMap&gt; AM &lt;/accountsMap&gt;)
</span><span class="noop">
</span><span class="hit">  rule getAppParamsField(_, _) =&gt; NoTValue [owise]
</span><span class="noop">
</span><span class="noop">  //TODO: In all accessors below, handle the case when NoTValue is returned
</span><span class="noop">
</span><span class="noop">  syntax MaybeTValue ::= getAccountField(AccountField, TValue) [function]
</span><span class="noop">  // -----------------------------------------------------------
</span><span class="miss">  rule getAccountField(Amount, ADDR) =&gt; getAccountParamsField(AcctBalance, ADDR)
</span><span class="noop">
</span><span class="miss">  rule [[ getAccountField(Round, ADDR) =&gt; V ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;round&gt; V &lt;/round&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAccountField(PendingRewards, ADDR) =&gt; V ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;preRewards&gt; V &lt;/preRewards&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAccountField(Rewards, ADDR) =&gt; V ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;rewards&gt; V &lt;/rewards&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAccountField(Status, ADDR) =&gt; V ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;status&gt; V &lt;/status&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAccountField(_, ADDR) =&gt; -1 ]]
</span><span class="noop">       &lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;
</span><span class="noop">    requires notBool (ADDR in_accounts(&lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;))
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Asset State Accessors
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Bool ::= hasOptedInAsset(TValue, TValue) [function, functional]
</span><span class="noop">  // -----------------------------------------------------
</span><span class="miss">  rule [[ hasOptedInAsset(ASSET, ADDR) =&gt; true ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;assetsOptedIn&gt;
</span><span class="noop">           &lt;optInAsset&gt;
</span><span class="noop">             &lt;optInAssetID&gt; ASSET &lt;/optInAssetID&gt; ...
</span><span class="noop">           &lt;/optInAsset&gt; ...
</span><span class="noop">         &lt;/assetsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="hit">  rule hasOptedInAsset(_, _) =&gt; false [owise]
</span><span class="noop">
</span><span class="noop">  syntax TValue ::= getOptInAssetField(AssetHoldingField, TValue, TValue) [function]
</span><span class="noop">  // ----------------------------------------------------------------------------
</span><span class="hit">  rule [[ getOptInAssetField(AssetBalance, ADDR, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;assetsOptedIn&gt;
</span><span class="noop">           &lt;optInAsset&gt;
</span><span class="noop">             &lt;optInAssetID&gt; ASSET &lt;/optInAssetID&gt;
</span><span class="noop">             &lt;optInAssetBalance&gt; V &lt;/optInAssetBalance&gt; ...
</span><span class="noop">           &lt;/optInAsset&gt; ...
</span><span class="noop">         &lt;/assetsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getOptInAssetField(AssetFrozen, ADDR, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;assetsOptedIn&gt;
</span><span class="noop">           &lt;optInAsset&gt;
</span><span class="noop">             &lt;optInAssetID&gt; ASSET &lt;/optInAssetID&gt;
</span><span class="noop">             &lt;optInAssetFrozen&gt;  V &lt;/optInAssetFrozen&gt; ...
</span><span class="noop">           &lt;/optInAsset&gt; ...
</span><span class="noop">         &lt;/assetsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getOptInAssetField(_, ADDR, ASSET) =&gt; -1 ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;assetsOptedIn&gt; OA &lt;/assetsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires notBool (ASSET in_optedInAssets(&lt;assetsOptedIn&gt; OA &lt;/assetsOptedIn&gt;))
</span><span class="noop">
</span><span class="miss">  rule [[ getOptInAssetField(_, ADDR, _) =&gt; -1 ]]
</span><span class="noop">       &lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;
</span><span class="noop">    requires notBool (ADDR in_accounts(&lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;))
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= assetCreated(TValue) [function]
</span><span class="noop">  // -------------------------------------------
</span><span class="hit">  rule [[ assetCreated(ASSET) =&gt; true ]]
</span><span class="noop">       &lt;assetCreator&gt; ASSET |-&gt; _ ... &lt;/assetCreator&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ assetCreated(ASSET) =&gt; false ]]
</span><span class="noop">       &lt;assetCreator&gt; AMap &lt;/assetCreator&gt;
</span><span class="noop">    requires notBool (ASSET in_keys(AMap))
</span><span class="noop">
</span><span class="noop"> syntax TValue ::= getAssetInfo(AssetField, TValue) [function]
</span><span class="noop">  // -----------------------------------------------------------
</span><span class="miss">  rule [[ getAssetInfo(Creator, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetCreator&gt; ASSET |-&gt; V ... &lt;/assetCreator&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAssetInfo(Creator, ASSET) =&gt; -1 ]]
</span><span class="noop">       &lt;assetCreator&gt; AMap &lt;/assetCreator&gt;
</span><span class="noop">    requires notBool (ASSET in_keys(AMap))
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">  syntax TValue ::= getAssetParamsField(AssetParamsField, TValue) [function]
</span><span class="noop">  // ---------------------------------------------------------------------
</span><span class="hit">  rule [[ getAssetParamsField(AssetTotal, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetsCreated&gt;
</span><span class="noop">         &lt;asset&gt;
</span><span class="noop">           &lt;assetID&gt; ASSET &lt;/assetID&gt;
</span><span class="noop">           &lt;assetTotal&gt; V &lt;/assetTotal&gt; ...
</span><span class="noop">         &lt;/asset&gt; ...
</span><span class="noop">       &lt;/assetsCreated&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getAssetParamsField(AssetDecimals, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetsCreated&gt;
</span><span class="noop">         &lt;asset&gt;
</span><span class="noop">           &lt;assetID&gt; ASSET &lt;/assetID&gt;
</span><span class="noop">           &lt;assetDecimals&gt; V &lt;/assetDecimals&gt; ...
</span><span class="noop">         &lt;/asset&gt; ...
</span><span class="noop">       &lt;/assetsCreated&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getAssetParamsField(AssetDefaultFrozen, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetsCreated&gt;
</span><span class="noop">         &lt;asset&gt;
</span><span class="noop">           &lt;assetID&gt; ASSET &lt;/assetID&gt;
</span><span class="noop">           &lt;assetDefaultFrozen&gt; V &lt;/assetDefaultFrozen&gt; ...
</span><span class="noop">         &lt;/asset&gt; ...
</span><span class="noop">       &lt;/assetsCreated&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getAssetParamsField(AssetUnitName, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetsCreated&gt;
</span><span class="noop">         &lt;asset&gt;
</span><span class="noop">           &lt;assetID&gt; ASSET &lt;/assetID&gt;
</span><span class="noop">           &lt;assetUnitName&gt; V &lt;/assetUnitName&gt; ...
</span><span class="noop">         &lt;/asset&gt; ...
</span><span class="noop">       &lt;/assetsCreated&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getAssetParamsField(AssetName, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetsCreated&gt;
</span><span class="noop">         &lt;asset&gt;
</span><span class="noop">           &lt;assetID&gt; ASSET &lt;/assetID&gt;
</span><span class="noop">           &lt;assetName&gt; V &lt;/assetName&gt; ...
</span><span class="noop">         &lt;/asset&gt; ...
</span><span class="noop">       &lt;/assetsCreated&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAssetParamsField(AssetURL, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetsCreated&gt;
</span><span class="noop">         &lt;asset&gt;
</span><span class="noop">           &lt;assetID&gt; ASSET &lt;/assetID&gt;
</span><span class="noop">           &lt;assetURL&gt; V &lt;/assetURL&gt; ...
</span><span class="noop">         &lt;/asset&gt; ...
</span><span class="noop">       &lt;/assetsCreated&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAssetParamsField(AssetMetadataHash, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetsCreated&gt;
</span><span class="noop">         &lt;asset&gt;
</span><span class="noop">           &lt;assetID&gt; ASSET &lt;/assetID&gt;
</span><span class="noop">           &lt;assetMetaDataHash&gt; V &lt;/assetMetaDataHash&gt; ...
</span><span class="noop">         &lt;/asset&gt; ...
</span><span class="noop">       &lt;/assetsCreated&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAssetParamsField(AssetManager, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetsCreated&gt;
</span><span class="noop">         &lt;asset&gt;
</span><span class="noop">           &lt;assetID&gt; ASSET &lt;/assetID&gt;
</span><span class="noop">           &lt;assetManagerAddr&gt; V &lt;/assetManagerAddr&gt; ...
</span><span class="noop">         &lt;/asset&gt; ...
</span><span class="noop">       &lt;/assetsCreated&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAssetParamsField(AssetReserve, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetsCreated&gt;
</span><span class="noop">         &lt;asset&gt;
</span><span class="noop">           &lt;assetID&gt; ASSET &lt;/assetID&gt;
</span><span class="noop">           &lt;assetReserveAddr&gt; V &lt;/assetReserveAddr&gt; ...
</span><span class="noop">         &lt;/asset&gt; ...
</span><span class="noop">       &lt;/assetsCreated&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAssetParamsField(AssetFreeze, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetsCreated&gt;
</span><span class="noop">         &lt;asset&gt;
</span><span class="noop">           &lt;assetID&gt; ASSET &lt;/assetID&gt;
</span><span class="noop">           &lt;assetFreezeAddr&gt; V &lt;/assetFreezeAddr&gt; ...
</span><span class="noop">         &lt;/asset&gt; ...
</span><span class="noop">       &lt;/assetsCreated&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getAssetParamsField(AssetClawback, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetsCreated&gt;
</span><span class="noop">         &lt;asset&gt;
</span><span class="noop">           &lt;assetID&gt; ASSET &lt;/assetID&gt;
</span><span class="noop">           &lt;assetClawbackAddr&gt; V &lt;/assetClawbackAddr&gt; ...
</span><span class="noop">         &lt;/asset&gt; ...
</span><span class="noop">       &lt;/assetsCreated&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getAssetParamsField(AssetCreator, ASSET) =&gt; V ]]
</span><span class="noop">       &lt;assetCreator&gt; ASSET |-&gt; V ...&lt;/assetCreator&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getAssetParamsField(_, ASSET) =&gt; -1 ]]
</span><span class="noop">      &lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;
</span><span class="noop">    requires notBool ( ASSET in_assets(&lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;) )
</span><span class="noop">
</span><span class="noop">  // TODO: what if the asset is there but the specified field is not (for some reason)?
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Application State Accessors
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Bool ::= hasOptedInApp(TValue, TValue) [function]
</span><span class="noop">  // ---------------------------------------------------
</span><span class="hit">  rule [[ hasOptedInApp(APP, ADDR) =&gt; APP in_optedInApps( &lt;appsOptedIn&gt; O &lt;/appsOptedIn&gt; ) ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt; O &lt;/appsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="noop">  // if the account doesn&#39;t exist, return false
</span><span class="miss">  rule [[ hasOptedInApp(_, ADDR) =&gt; false ]]
</span><span class="noop">       &lt;accountsMap&gt; AMAP  &lt;/accountsMap&gt;
</span><span class="noop">    requires notBool (ADDR in_accounts(&lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;))
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">  syntax MaybeTValue ::= getAppLocal(TValue, TValue, TValue) [function, functional]
</span><span class="noop">  // ---------------------------------------------------------
</span><span class="hit">  rule [[ getAppLocal(ADDR, APP, KEY) =&gt; V ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           &lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt; APP &lt;/optInAppID&gt;
</span><span class="noop">             &lt;localInts&gt; KEY |-&gt; V ... &lt;/localInts&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInApp&gt; ...
</span><span class="noop">         &lt;/appsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getAppLocal(ADDR, APP, KEY) =&gt; V ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           &lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt; APP &lt;/optInAppID&gt;
</span><span class="noop">             &lt;localBytes&gt; KEY |-&gt; V ... &lt;/localBytes&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInApp&gt; ...
</span><span class="noop">         &lt;/appsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="noop">  // If the key isn&#39;t set, return -1
</span><span class="hit">  rule [[ getAppLocal(ADDR, APP, KEY) =&gt; -1 ]]
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           &lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt; APP &lt;/optInAppID&gt;
</span><span class="noop">             &lt;localInts&gt; MI &lt;/localInts&gt;
</span><span class="noop">             &lt;localBytes&gt; MB &lt;/localBytes&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInApp&gt; ...
</span><span class="noop">         &lt;/appsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires notBool ((KEY in_keys(MI)) orBool (KEY in_keys(MB)))
</span><span class="noop">
</span><span class="noop">  // if the account exists but is not opted in, or does not exist, return NoTValue
</span><span class="hit">  rule getAppLocal(_, _, _) =&gt; NoTValue [owise]
</span><span class="noop">
</span><span class="noop">  syntax TValue ::= getAppGlobal(TValue, TValue) [function]
</span><span class="noop">  // ---------------------------------------------------
</span><span class="hit">  rule [[ getAppGlobal(APP, KEY) =&gt; V ]]
</span><span class="noop">       &lt;appsCreated&gt;
</span><span class="noop">         &lt;app&gt;
</span><span class="noop">           &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">           &lt;globalState&gt;
</span><span class="noop">             &lt;globalInts&gt; KEY |-&gt; V ... &lt;/globalInts&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/globalState&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/app&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/appsCreated&gt;
</span><span class="hit">  rule [[ getAppGlobal(APP, KEY) =&gt; V ]]
</span><span class="noop">       &lt;appsCreated&gt;
</span><span class="noop">         &lt;app&gt;
</span><span class="noop">           &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">           &lt;globalState&gt;
</span><span class="noop">             &lt;globalBytes&gt; KEY |-&gt; V ... &lt;/globalBytes&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/globalState&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/app&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/appsCreated&gt;
</span><span class="noop">
</span><span class="noop">  // if the key doesn&#39;t exist, return -1
</span><span class="hit">  rule [[ getAppGlobal(APP, KEY) =&gt; -1 ]]
</span><span class="noop">       &lt;appsCreated&gt;
</span><span class="noop">         &lt;app&gt;
</span><span class="noop">           &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">           &lt;globalState&gt;
</span><span class="noop">             &lt;globalInts&gt; MI &lt;/globalInts&gt;
</span><span class="noop">             &lt;globalBytes&gt; MB &lt;/globalBytes&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/globalState&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/app&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/appsCreated&gt;
</span><span class="noop">    requires notBool ((KEY in_keys (MI)) orBool (KEY in_keys(MB)))
</span><span class="noop">
</span><span class="noop">  // if the app doesn&#39;t exist, return -1
</span><span class="miss">  rule [[ getAppGlobal(APP, _) =&gt; -1 ]]
</span><span class="noop">       &lt;accountsMap&gt; AMAP  &lt;/accountsMap&gt;
</span><span class="noop">    requires notBool (APP in_apps(&lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;))
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= appCreated(TValue) [function]
</span><span class="noop">  // -----------------------------------------
</span><span class="miss">  rule [[ appCreated(APP) =&gt; true ]]
</span><span class="noop">       &lt;appCreator&gt; APP |-&gt; _ ... &lt;/appCreator&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ appCreated(APP) =&gt; false ]]
</span><span class="noop">       &lt;appCreator&gt; AMap &lt;/appCreator&gt;
</span><span class="noop">    requires notBool (APP in_keys(AMap))
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Auxiliary Functions
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Bool ::= TValue &#34;in_accounts&#34; &#34;(&#34; AccountsMapCell &#34;)&#34; [function]
</span><span class="noop">  // -------------------------------------------------------------------
</span><span class="hit">  rule ADDR in_accounts( &lt;accountsMap&gt;
</span><span class="noop">                           &lt;account&gt;
</span><span class="noop">                             &lt;address&gt; ADDR &lt;/address&gt; ...
</span><span class="noop">                           &lt;/account&gt; ...
</span><span class="noop">                         &lt;/accountsMap&gt; )
</span><span class="noop">       =&gt; true
</span><span class="noop">
</span><span class="hit">  rule ADDR in_accounts( &lt;accountsMap&gt;
</span><span class="noop">                           &lt;account&gt;
</span><span class="noop">                             &lt;address&gt; ADDR&#39; &lt;/address&gt; ...
</span><span class="noop">                           &lt;/account&gt; REST
</span><span class="noop">                         &lt;/accountsMap&gt; )
</span><span class="noop">       =&gt; ADDR in_accounts (&lt;accountsMap&gt; REST &lt;/accountsMap&gt;)
</span><span class="noop">    requires ADDR =/=K ADDR&#39;
</span><span class="noop">
</span><span class="hit">  rule _ in_accounts( &lt;accountsMap&gt; .Bag &lt;/accountsMap&gt; ) =&gt; false
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= TValue &#34;in_optedInApps&#34; &#34;(&#34; AppsOptedInCell &#34;)&#34; [function]
</span><span class="noop">  //-----------------------------------------------------------------------
</span><span class="hit">  rule APP in_optedInApps(
</span><span class="noop">             &lt;appsOptedIn&gt;
</span><span class="noop">               &lt;optInApp&gt;
</span><span class="noop">                 &lt;optInAppID&gt; APP &lt;/optInAppID&gt; ...
</span><span class="noop">               &lt;/optInApp&gt; ...
</span><span class="noop">             &lt;/appsOptedIn&gt;) =&gt; true
</span><span class="noop">
</span><span class="hit">  rule APP in_optedInApps(
</span><span class="noop">             &lt;appsOptedIn&gt;
</span><span class="noop">               &lt;optInApp&gt;
</span><span class="noop">                 &lt;optInAppID&gt; APP&#39; &lt;/optInAppID&gt; ...
</span><span class="noop">               &lt;/optInApp&gt; REST
</span><span class="noop">             &lt;/appsOptedIn&gt;) =&gt; APP in_optedInApps(&lt;appsOptedIn&gt; REST &lt;/appsOptedIn&gt;)
</span><span class="noop">    requires APP =/=K APP&#39;
</span><span class="noop">
</span><span class="hit">  rule _ in_optedInApps(&lt;appsOptedIn&gt; .Bag &lt;/appsOptedIn&gt;) =&gt; false
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= TValue &#34;in_optedInAssets&#34; &#34;(&#34; AssetsOptedInCell &#34;)&#34; [function]
</span><span class="noop">  // -----------------------------------------------------------------
</span><span class="hit">  rule ASSET in_optedInAssets(&lt;assetsOptedIn&gt;
</span><span class="noop">                       &lt;optInAsset&gt;
</span><span class="noop">                         &lt;optInAssetID&gt; ASSET &lt;/optInAssetID&gt; ...
</span><span class="noop">                       &lt;/optInAsset&gt; ...
</span><span class="noop">                     &lt;/assetsOptedIn&gt;) =&gt; true
</span><span class="noop">
</span><span class="miss">  rule ASSET in_optedInAssets(&lt;assetsOptedIn&gt;
</span><span class="noop">                       &lt;optInAsset&gt;
</span><span class="noop">                         &lt;optInAssetID&gt; ASSET&#39; &lt;/optInAssetID&gt; ...
</span><span class="noop">                       &lt;/optInAsset&gt; REST
</span><span class="noop">                     &lt;/assetsOptedIn&gt;)
</span><span class="noop">       =&gt; ASSET in_optedInAssets(&lt;assetsOptedIn&gt; REST &lt;/assetsOptedIn&gt;)
</span><span class="noop">    requires ASSET =/=K ASSET&#39;
</span><span class="noop">
</span><span class="hit">  rule _ in_optedInAssets(&lt;assetsOptedIn&gt; .Bag &lt;/assetsOptedIn&gt;) =&gt; false
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= TValue &#34;in_assets&#34; &#34;(&#34; AccountsMapCell &#34;)&#34; [function]
</span><span class="noop">  // -----------------------------------------------------------------
</span><span class="hit">  rule ASSET in_assets(&lt;accountsMap&gt;
</span><span class="noop">                         &lt;account&gt;
</span><span class="noop">                           &lt;assetsCreated&gt; ASSETS &lt;/assetsCreated&gt; ...
</span><span class="noop">                         &lt;/account&gt; REST
</span><span class="noop">                       &lt;/accountsMap&gt; )
</span><span class="noop">       =&gt; ASSET in_assets (&lt;assetsCreated&gt; ASSETS &lt;/assetsCreated&gt;)
</span><span class="noop">          orBool ASSET in_assets ( &lt;accountsMap&gt; REST &lt;/accountsMap&gt; )
</span><span class="noop">
</span><span class="hit">  rule _ in_assets( &lt;accountsMap&gt; .Bag &lt;/accountsMap&gt; ) =&gt; false
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= TValue &#34;in_assets&#34; &#34;(&#34; AssetsCreatedCell &#34;)&#34; [function]
</span><span class="noop">  // -----------------------------------------------------------------
</span><span class="hit">  rule ASSET in_assets(&lt;assetsCreated&gt;
</span><span class="noop">                         &lt;asset&gt;
</span><span class="noop">                           &lt;assetID&gt; ASSET &lt;/assetID&gt; ...
</span><span class="noop">                         &lt;/asset&gt; ...
</span><span class="noop">                       &lt;/assetsCreated&gt; ) =&gt; true
</span><span class="noop">
</span><span class="hit">  rule ASSET in_assets(&lt;assetsCreated&gt;
</span><span class="noop">                         &lt;asset&gt;
</span><span class="noop">                           &lt;assetID&gt; ASSET&#39; &lt;/assetID&gt; ...
</span><span class="noop">                         &lt;/asset&gt; REST
</span><span class="noop">                       &lt;/assetsCreated&gt; )
</span><span class="noop">       =&gt; ASSET in_assets(&lt;assetsCreated&gt; REST &lt;/assetsCreated&gt;)
</span><span class="noop">    requires ASSET =/=K ASSET&#39;
</span><span class="noop">
</span><span class="hit">  rule _ in_assets(&lt;assetsCreated&gt; .Bag &lt;/assetsCreated&gt;) =&gt; false
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= TValue &#34;in_apps&#34; &#34;(&#34; AccountsMapCell &#34;)&#34; [function, functional]
</span><span class="noop">  // ----------------------------------------------------------------------------
</span><span class="hit">  rule APP in_apps(&lt;accountsMap&gt;
</span><span class="noop">                     &lt;account&gt;
</span><span class="noop">                       &lt;appsCreated&gt; APPS &lt;/appsCreated&gt; ...
</span><span class="noop">                     &lt;/account&gt; REST
</span><span class="noop">                   &lt;/accountsMap&gt; )
</span><span class="noop">       =&gt; APP in_apps (&lt;appsCreated&gt; APPS &lt;/appsCreated&gt;)
</span><span class="noop">          orBool APP in_apps ( &lt;accountsMap&gt; REST &lt;/accountsMap&gt; )
</span><span class="noop">
</span><span class="hit">  rule _ in_apps( &lt;accountsMap&gt; .Bag &lt;/accountsMap&gt; ) =&gt; false
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= TValue &#34;in_apps&#34; &#34;(&#34; AppsCreatedCell &#34;)&#34; [function, functional]
</span><span class="noop">  // ----------------------------------------------------------------------------
</span><span class="hit">  rule APP in_apps(&lt;appsCreated&gt;
</span><span class="noop">                     &lt;app&gt;
</span><span class="noop">                       &lt;appID&gt; APP &lt;/appID&gt; ...
</span><span class="noop">                     &lt;/app&gt; ...
</span><span class="noop">                   &lt;/appsCreated&gt; ) =&gt; true
</span><span class="noop">
</span><span class="hit">  rule APP in_apps(&lt;appsCreated&gt;
</span><span class="noop">                     &lt;app&gt;
</span><span class="noop">                       &lt;appID&gt; APP&#39; &lt;/appID&gt; ...
</span><span class="noop">                     &lt;/app&gt; REST
</span><span class="noop">                   &lt;/appsCreated&gt; )
</span><span class="noop">       =&gt; APP in_apps(&lt;appsCreated&gt; REST &lt;/appsCreated&gt;)
</span><span class="noop">    requires APP =/=K APP&#39;
</span><span class="noop">
</span><span class="hit">  rule _ in_apps(&lt;appsCreated&gt; .Bag &lt;/appsCreated&gt;) =&gt; false
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Resource referencing
</span><span class="noop">
</span><span class="noop">When referring to accounts, applications, and ASAs, certain opcodes allow not just offsets in the foreign array
</span><span class="noop">fields and addresses (in the case of accounts), application/ASA IDs (in the case of applications and ASAs).
</span><span class="noop">The purpose of `accountReference()`, `appReference()`, and `asaReference()` is to disambiguate these types of
</span><span class="noop">references and also to check that a resource is available.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax MaybeTValue ::= accountReference(TValue) [function, functional]
</span><span class="noop">  //--------------------------------------------------------------------
</span><span class="hit">  rule accountReference(A:TBytes ) =&gt; A requires accountAvailable(A)
</span><span class="hit">  rule accountReference(I:Int    ) =&gt; getTxnField(getCurrentTxn(), Accounts, I)
</span><span class="hit">  rule accountReference(_        ) =&gt; NoTValue  [owise]
</span><span class="noop">
</span><span class="noop">  syntax MaybeTValue ::= appReference(TUInt64)  [function, functional]
</span><span class="noop">  //-----------------------------------------------------------------
</span><span class="hit">  rule appReference(I) =&gt; I requires applicationAvailable(I)
</span><span class="hit">  rule appReference(I) =&gt; getTxnField(getCurrentTxn(), Applications, I)  [owise]
</span><span class="noop">
</span><span class="noop">  syntax MaybeTValue ::= asaReference(TUInt64)  [function, functional]
</span><span class="noop">  //------------------------------------------------------------------
</span><span class="hit">  rule asaReference(I) =&gt; I requires assetAvailable(I)
</span><span class="hit">  rule asaReference(I) =&gt; getTxnField(getCurrentTxn(), Assets, I)  [owise]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Resource Availability
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">// TODO the associated account of a contract that was created earlier in the group should be available (v 6)
</span><span class="noop">// TODO the associated account of a contract present in the txn.ForeignApplications field should be available (v7)
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= accountAvailable(TBytes) [function, functional]
</span><span class="noop">  //---------------------------------------------------------------
</span><span class="noop">
</span><span class="hit">  rule accountAvailable(A) =&gt; true
</span><span class="noop">    requires contains(getTxnField(getCurrentTxn(), Accounts), A)
</span><span class="noop">
</span><span class="hit">  rule accountAvailable(A) =&gt; true
</span><span class="noop">    requires A ==K getTxnField(getCurrentTxn(), Sender)
</span><span class="noop">
</span><span class="hit">  rule accountAvailable(A) =&gt; true
</span><span class="noop">    requires A ==K getGlobalField(CurrentApplicationAddress)
</span><span class="noop">
</span><span class="hit">  rule accountAvailable(_) =&gt; false [owise]
</span><span class="noop">
</span><span class="noop">  
</span><span class="noop">// TODO any contract that was created earlier in the same transaction group should be available (v6)
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= applicationAvailable(TUInt64) [function, functional]
</span><span class="noop">  //------------------------------------------------------------------
</span><span class="noop">
</span><span class="hit">  rule applicationAvailable(A) =&gt; true
</span><span class="noop">    requires contains(getTxnField(getCurrentTxn(), Applications), A)
</span><span class="noop">
</span><span class="hit">  rule applicationAvailable(A) =&gt; true
</span><span class="noop">    requires A ==K getGlobalField(CurrentApplicationID)
</span><span class="noop">
</span><span class="hit">  rule applicationAvailable(_) =&gt; false [owise]
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">// TODO any asset that was created earlier in the same transaction group should be available (v6)
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= assetAvailable(TUInt64) [function, functional]
</span><span class="noop">  //------------------------------------------------------------
</span><span class="noop">
</span><span class="hit">  rule assetAvailable(A) =&gt; true
</span><span class="noop">    requires contains(getTxnField(getCurrentTxn(), Assets), A)
</span><span class="noop">
</span><span class="hit">  rule assetAvailable(_) =&gt; false [owise]
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Transaction Index Accessors
</span><span class="noop">
</span><span class="noop">The transaction index connects a transaction groups ID to the transaction IDs comprising the group
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">
</span><span class="noop">  syntax MaybeTValue ::= getGroupFieldByIdx(String, Int, TxnField) [function]
</span><span class="noop">  syntax MaybeTValue ::= getGroupFieldByIdx(String, Int, TxnaField, Int) [function]
</span><span class="noop">
</span><span class="hit">  rule [[ getGroupFieldByIdx(GROUP_ID, GROUP_INDEX, FIELD) =&gt; getTxnField(TXN_ID, FIELD) ]]
</span><span class="noop">        &lt;txnIndexMapGroup&gt;
</span><span class="noop">          &lt;txnIndexMapGroupKey&gt; GROUP_ID &lt;/txnIndexMapGroupKey&gt;
</span><span class="noop">          &lt;txnIndexMapGroupValues&gt; GROUP_INDEX |-&gt; TXN_ID ... &lt;/txnIndexMapGroupValues&gt;
</span><span class="noop">        &lt;/txnIndexMapGroup&gt;
</span><span class="noop">
</span><span class="hit">  rule [[ getGroupFieldByIdx(GROUP_ID, GROUP_INDEX, FIELD, FIELD_INDEX) =&gt; getTxnField(TXN_ID, FIELD, FIELD_INDEX) ]]
</span><span class="noop">        &lt;txnIndexMapGroup&gt;
</span><span class="noop">          &lt;txnIndexMapGroupKey&gt; GROUP_ID &lt;/txnIndexMapGroupKey&gt;
</span><span class="noop">          &lt;txnIndexMapGroupValues&gt; GROUP_INDEX |-&gt; TXN_ID ... &lt;/txnIndexMapGroupValues&gt;
</span><span class="noop">        &lt;/txnIndexMapGroup&gt;
</span><span class="noop">
</span><span class="miss">  rule getGroupFieldByIdx(_, _, _) =&gt; NoTValue [owise]
</span><span class="noop">
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/constants.md">avm/constants.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># AVM Constants
</span><span class="noop">
</span><span class="noop">These are taken from [here](https://developer.algorand.org/docs/get-details/parameter_tables)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module AVM-CONSTANTS
</span><span class="noop">  imports INT
</span><span class="noop">
</span><span class="noop">  syntax Int ::= &#34;PARAM_MIN_BALANCE&#34;            [macro]
</span><span class="noop">               | &#34;PARAM_APP_PAGE_FLAT&#34;          [macro]
</span><span class="noop">               | &#34;PARAM_APP_OPTIN_FLAT&#34;         [macro]
</span><span class="noop">               | &#34;PARAM_MIN_BALANCE_PER_ENTRY&#34;  [macro]
</span><span class="noop">               | &#34;PARAM_UINT_MIN_BALANCE&#34;       [macro]
</span><span class="noop">               | &#34;PARAM_BYTES_MIN_BALANCE&#34;      [macro]
</span><span class="noop">               | &#34;PARAM_MIN_TXN_FEE&#34;            [macro]
</span><span class="noop">               | &#34;PARAM_MAX_TXN_LIFE&#34;           [macro]
</span><span class="noop">               | &#34;PARAM_MAX_LOG_CALLS&#34;          [macro]
</span><span class="noop">               | &#34;PARAM_MAX_LOG_SIZE&#34;           [macro]
</span><span class="noop">               | &#34;PARAM_MAX_LOCAL_KEYS&#34;         [macro]
</span><span class="noop">               | &#34;PARAM_MAX_GLOBAL_KEYS&#34;        [macro]
</span><span class="noop">               | &#34;PARAM_MAX_KEY_SIZE&#34;           [macro]
</span><span class="noop">               | &#34;PARAM_MAX_BYTE_VALUE_SIZE&#34;    [macro]
</span><span class="noop">               | &#34;PARAM_MAX_SUM_KEY_VALUE_SIZE&#34; [macro]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Amount the min balance is set to by default, and amount it is increased by when creating or opting into
</span><span class="noop">an ASA (MinBalance)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_MIN_BALANCE =&gt; 100000
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Amount, per page, the min balance is increased by when creating an app (AppFlatParamsMinBalance)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_APP_PAGE_FLAT =&gt; 100000
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Flat amount the min balance is increased by when opting into an app (AppFlatOptInMinBalance)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_APP_OPTIN_FLAT =&gt; 100000
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Amount the min balance is increased per entry for local or global storage, regardless of type
</span><span class="noop">(SchemaMinBalancePerEntry)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_MIN_BALANCE_PER_ENTRY =&gt; 25000
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Additional amount the min balance is increased for local or global storage of ints (SchemaUintMinBalance)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_UINT_MIN_BALANCE =&gt; 3500
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Additional amount the min balance is increased for local or global storage of byte strings
</span><span class="noop">(SchemaBytesMinBalance)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_BYTES_MIN_BALANCE =&gt; 25000
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Minimum transaction fee (MinTxnFee)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_MIN_TXN_FEE =&gt; 1000
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Maximum transaction life (MaxTxnLife)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_MAX_TXN_LIFE =&gt; 1000
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Maximum number of log messages (MaxLogCalls)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_MAX_LOG_CALLS =&gt; 32
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Maximum size of log messages (MaxLogSize)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_MAX_LOG_SIZE =&gt; 1024
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Maximum number of global storage slots per app (MaxGlobalSchemaEntries)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_MAX_GLOBAL_KEYS =&gt; 64
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Maximum number of local storage slots per app (MaxLocalSchemaEntries)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_MAX_LOCAL_KEYS =&gt; 16
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Maximum size of key for global/local storage (MaxAppKeyLen)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_MAX_KEY_SIZE =&gt; 64
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Maximum size of one value for global/local bytes storage (MaxAppBytesValueLen)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_MAX_BYTE_VALUE_SIZE =&gt; 128
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Maximum size of the sum of the key length plus value length for one storage slot (MaxAppSumKeyValueLens)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule PARAM_MAX_SUM_KEY_VALUE_SIZE =&gt; 128
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/txn.md">avm/txn.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">Algorand Transaction Representation
</span><span class="noop">===================================
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">require &#34;avm/teal/teal-fields.md&#34;
</span><span class="noop">require &#34;avm/teal/teal-types.md&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Transaction State Representation
</span><span class="noop">--------------------------------
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module TXN-FIELDS
</span><span class="noop">  imports TEAL-FIELDS
</span><span class="noop">  imports TEAL-SYNTAX
</span><span class="noop">  imports BYTES
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Pseudo fields*
</span><span class="noop">
</span><span class="noop">We maintain a number of pseudo fields that are not part of the official AVM specification and serve the internal purposes of the semantics.
</span><span class="noop">
</span><span class="noop">In TEALv4, the opcodes `gload` and `gloads` were added to access the final scratch space of the
</span><span class="noop">past application call transactions in the group. We, thus, maintain a `&lt;finalScratch&gt;` sub-cell, initially an empty `.Map`. The cell will be hold the final state of that transaction&#39;s scratch space.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Transaction Header*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  configuration
</span><span class="noop">      &lt;txHeader&gt;
</span><span class="noop">        &lt;fee&gt;         NoTValue &lt;/fee&gt;
</span><span class="noop">        &lt;firstValid&gt;  NoTValue &lt;/firstValid&gt;       // first round during which the transaction is valid
</span><span class="noop">        &lt;lastValid&gt;   NoTValue &lt;/lastValid&gt;        // the transaction is not valid beyond this round (round range max is 1000 rounds)
</span><span class="noop">        &lt;genesisHash&gt; NoTValue &lt;/genesisHash&gt;      // uniquely identifies the network
</span><span class="noop">        &lt;sender&gt;      NoTValue &lt;/sender&gt;
</span><span class="noop">        &lt;txType&gt;      NoTValue &lt;/txType&gt;
</span><span class="noop">        &lt;typeEnum&gt;    NoTValue &lt;/typeEnum&gt;
</span><span class="noop">        &lt;groupID&gt;     &#34;&#34;       &lt;/groupID&gt;
</span><span class="noop">        &lt;groupIdx&gt;    NoTValue &lt;/groupIdx&gt;
</span><span class="noop">        &lt;genesisID&gt;   NoTValue &lt;/genesisID&gt;        // a human-readable name: does not necessarily uniquely identify the network
</span><span class="noop">        &lt;lease&gt;       NoTValue &lt;/lease&gt;
</span><span class="noop">        &lt;note&gt;        NoTValue &lt;/note&gt;
</span><span class="noop">        &lt;rekeyTo&gt;     NoTValue &lt;/rekeyTo&gt;
</span><span class="noop">      &lt;/txHeader&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Pay Transaction*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  configuration
</span><span class="noop">      &lt;payTxFields multiplicity=&#34;?&#34;&gt;
</span><span class="noop">        &lt;receiver&gt;         NoTValue &lt;/receiver&gt;
</span><span class="noop">        &lt;amount&gt;           NoTValue &lt;/amount&gt;           // this is 0 if not specified
</span><span class="noop">        &lt;closeRemainderTo&gt; NoTValue &lt;/closeRemainderTo&gt; // close the sender account and transfer any remaining balance to this account
</span><span class="noop">      &lt;/payTxFields&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Application Call Transaction*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  configuration
</span><span class="noop">      &lt;appCallTxFields multiplicity=&#34;?&#34;&gt;
</span><span class="noop">        &lt;applicationID&gt;        NoTValue    &lt;/applicationID&gt;
</span><span class="noop">        &lt;onCompletion&gt;         NoTValue    &lt;/onCompletion&gt;
</span><span class="noop">        &lt;accounts&gt;             .TValueList &lt;/accounts&gt;
</span><span class="noop">        &lt;approvalProgramSrc&gt;     (int 0):TealInputPgm &lt;/approvalProgramSrc&gt;
</span><span class="noop">        &lt;clearStateProgramSrc&gt;   (int 1):TealInputPgm &lt;/clearStateProgramSrc&gt;
</span><span class="noop">        &lt;approvalProgram&gt;      NoTValue      &lt;/approvalProgram&gt;
</span><span class="noop">        &lt;clearStateProgram&gt;    NoTValue      &lt;/clearStateProgram&gt;
</span><span class="noop">        &lt;applicationArgs&gt;      .TValueList &lt;/applicationArgs&gt; // maximum size is 2KB, and all args are internally byte strings
</span><span class="noop">        &lt;foreignApps&gt;          .TValueList &lt;/foreignApps&gt;
</span><span class="noop">        &lt;foreignAssets&gt;        .TValueList &lt;/foreignAssets&gt;
</span><span class="noop">        &lt;globalStateSchema&gt;
</span><span class="noop">          &lt;globalNui&gt; NoTValue &lt;/globalNui&gt;
</span><span class="noop">          &lt;globalNbs&gt; NoTValue &lt;/globalNbs&gt;
</span><span class="noop">        &lt;/globalStateSchema&gt;
</span><span class="noop">        &lt;localStateSchema&gt;
</span><span class="noop">          &lt;localNui&gt; NoTValue &lt;/localNui&gt;
</span><span class="noop">          &lt;localNbs&gt; NoTValue &lt;/localNbs&gt;
</span><span class="noop">        &lt;/localStateSchema&gt;
</span><span class="noop">        &lt;extraProgramPages&gt; NoTValue &lt;/extraProgramPages&gt;
</span><span class="noop">      &lt;/appCallTxFields&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Key Registration Transaction*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  configuration
</span><span class="noop">    &lt;keyRegTxFields multiplicity=&#34;?&#34;&gt;
</span><span class="noop">      &lt;votePk&gt;           NoTValue &lt;/votePk&gt;
</span><span class="noop">      &lt;selectionPK&gt;      NoTValue &lt;/selectionPK&gt;
</span><span class="noop">      &lt;voteFirst&gt;        NoTValue &lt;/voteFirst&gt;
</span><span class="noop">      &lt;voteLast&gt;         NoTValue &lt;/voteLast&gt;
</span><span class="noop">      &lt;voteKeyDilution&gt;  NoTValue &lt;/voteKeyDilution&gt;
</span><span class="noop">      &lt;nonparticipation&gt; NoTValue &lt;/nonparticipation&gt;
</span><span class="noop">    &lt;/keyRegTxFields&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Asset Configuration Transaction*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  // Note: - Asset creation: if no asset ID specified
</span><span class="noop">  //         Asset update: if both asset ID and (all) asset params are specified
</span><span class="noop">  //         Asset destruction: if asset ID specified but no parameters
</span><span class="noop">  configuration
</span><span class="noop">    &lt;assetConfigTxFields multiplicity=&#34;?&#34;&gt;
</span><span class="noop">      &lt;configAsset&gt; NoTValue &lt;/configAsset&gt;           // the asset ID
</span><span class="noop">      &lt;assetParams&gt;
</span><span class="noop">        &lt;configTotal&gt;         NoTValue &lt;/configTotal&gt;
</span><span class="noop">        &lt;configDecimals&gt;      NoTValue &lt;/configDecimals&gt;
</span><span class="noop">        &lt;configDefaultFrozen&gt; NoTValue &lt;/configDefaultFrozen&gt;
</span><span class="noop">        &lt;configUnitName&gt;      NoTValue &lt;/configUnitName&gt;
</span><span class="noop">        &lt;configAssetName&gt;     NoTValue &lt;/configAssetName&gt;
</span><span class="noop">        &lt;configAssetURL&gt;      NoTValue &lt;/configAssetURL&gt;
</span><span class="noop">        &lt;configMetaDataHash&gt;  NoTValue &lt;/configMetaDataHash&gt;
</span><span class="noop">        &lt;configManagerAddr&gt;   NoTValue &lt;/configManagerAddr&gt;
</span><span class="noop">        &lt;configReserveAddr&gt;   NoTValue &lt;/configReserveAddr&gt;
</span><span class="noop">        &lt;configFreezeAddr&gt;    NoTValue &lt;/configFreezeAddr&gt;
</span><span class="noop">        &lt;configClawbackAddr&gt;  NoTValue &lt;/configClawbackAddr&gt;
</span><span class="noop">      &lt;/assetParams&gt;
</span><span class="noop">    &lt;/assetConfigTxFields&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Asset Transfer Transaction*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  // Note: Three uses: 1. opt-in to receive an asset (sender and receiver are the same and the amount is 0)
</span><span class="noop">  //                   2. Transfer an Asset (amount is non-zero, and assumes the receiver had already opted-in before)
</span><span class="noop">  //                   3. Revoke an asset (having an asset asender, from which asset will be revoked)
</span><span class="noop">  configuration
</span><span class="noop">    &lt;assetTransferTxFields multiplicity=&#34;?&#34;&gt;
</span><span class="noop">      &lt;xferAsset&gt;     NoTValue &lt;/xferAsset&gt;
</span><span class="noop">      &lt;assetAmount&gt;   NoTValue &lt;/assetAmount&gt;
</span><span class="noop">      &lt;assetReceiver&gt; NoTValue &lt;/assetReceiver&gt;
</span><span class="noop">      &lt;assetASender&gt;  NoTValue &lt;/assetASender&gt;
</span><span class="noop">      &lt;assetCloseTo&gt;  NoTValue &lt;/assetCloseTo&gt;
</span><span class="noop">    &lt;/assetTransferTxFields&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Asset Freeze Transaction*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop"> configuration
</span><span class="noop">   &lt;assetFreezeTxFields multiplicity=&#34;?&#34;&gt;
</span><span class="noop">     &lt;freezeAccount&gt; NoTValue &lt;/freezeAccount&gt;
</span><span class="noop">     &lt;freezeAsset&gt;   NoTValue &lt;/freezeAsset&gt;
</span><span class="noop">     &lt;assetFrozen&gt;   NoTValue &lt;/assetFrozen&gt;
</span><span class="noop">   &lt;/assetFreezeTxFields&gt;
</span><span class="noop">
</span><span class="noop">endmodule
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Transaction Group State Representation
</span><span class="noop">--------------------------------------
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module ALGO-TXN
</span><span class="noop">  imports TXN-FIELDS
</span><span class="noop">  imports TEAL-TYPES
</span><span class="noop">  imports SET
</span><span class="noop">  imports LIST
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Transaction Group Configuration*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  // TODO: We also need to represent signed transactions (? -- maybe for later)
</span><span class="noop">  // Note: Signed Transaction: (Sig, MSig, LogicSig, Txn)
</span><span class="noop">  // Note: There can be up to 16 transactions in a group (?)
</span><span class="noop">  //       (see https://developer.algorand.org/docs/features/atomic_transfers/
</span><span class="noop">  // Note: Group-id is calculated by hashing the concatenation of its list of transactions.
</span><span class="noop">  //       Then, it is stored in the header field of each transaction in the list. (So hashing is performed
</span><span class="noop">  //       on the transactions with empty group-id fields?)
</span><span class="noop">
</span><span class="noop">  configuration
</span><span class="noop">      &lt;transactions&gt;
</span><span class="noop">        &lt;transaction multiplicity=&#34;*&#34; type=&#34;Map&#34;&gt;
</span><span class="noop">          &lt;txID&gt; &#34;&#34; &lt;/txID&gt;
</span><span class="noop">          &lt;txHeader/&gt;
</span><span class="noop">          &lt;txnTypeSpecificFields&gt;
</span><span class="noop">            &lt;payTxFields/&gt;
</span><span class="noop">            &lt;appCallTxFields/&gt;
</span><span class="noop">            &lt;keyRegTxFields/&gt;
</span><span class="noop">            &lt;assetConfigTxFields/&gt;
</span><span class="noop">            &lt;assetTransferTxFields/&gt;
</span><span class="noop">            &lt;assetFreezeTxFields/&gt;
</span><span class="noop">          &lt;/txnTypeSpecificFields&gt;
</span><span class="noop">          &lt;applyData&gt;
</span><span class="noop">            &lt;txScratch&gt;       .Map  &lt;/txScratch&gt;
</span><span class="noop">            &lt;txConfigAsset&gt;   0     &lt;/txConfigAsset&gt;
</span><span class="noop">            &lt;txApplicationID&gt; 0     &lt;/txApplicationID&gt;
</span><span class="noop">            &lt;log&gt;
</span><span class="noop">              &lt;logData&gt; .TValueList &lt;/logData&gt;
</span><span class="noop">              &lt;logSize&gt; 0:TValue    &lt;/logSize&gt;
</span><span class="noop">            &lt;/log&gt;
</span><span class="noop">          &lt;/applyData&gt;
</span><span class="noop">          &lt;txnExecutionContext&gt; .K &lt;/txnExecutionContext&gt;
</span><span class="noop">          &lt;resume&gt; false &lt;/resume&gt;
</span><span class="noop">        &lt;/transaction&gt;
</span><span class="noop">      &lt;/transactions&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Transaction ID Getter*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax String ::= getTxID(TransactionCell) [function, functional]
</span><span class="noop">  //---------------------------------------------------------------
</span><span class="miss">  rule getTxID(&lt;transaction&gt; &lt;txID&gt; ID &lt;/txID&gt; ... &lt;/transaction&gt;) =&gt; ID
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Transaction Group Accessors*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax String ::= getTxnGroupID(String) [function]
</span><span class="noop">  //------------------------------------------------
</span><span class="miss">  rule [[ getTxnGroupID(TXN_ID) =&gt; I ]]
</span><span class="noop">       &lt;transaction&gt; 
</span><span class="noop">         &lt;txID&gt; TXN_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupID&gt; I &lt;/groupID&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">
</span><span class="noop">  syntax Int ::= getTxnGroupIndex(String) [function]
</span><span class="noop">  //------------------------------------------------
</span><span class="hit">  rule [[ getTxnGroupIndex(TXN_ID) =&gt; I ]]
</span><span class="noop">       &lt;transaction&gt; 
</span><span class="noop">         &lt;txID&gt; TXN_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupIdx&gt; I &lt;/groupIdx&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">
</span><span class="noop">  syntax MaybeTValue ::= getTxnField(String, TxnField)                 [function]
</span><span class="noop">  syntax MaybeTValue ::= getTxnField(String, TxnaField, Int)           [function]
</span><span class="noop">  syntax TValueList  ::= getTxnField(String, TxnaField)                [function]
</span><span class="noop">  //-----------------------------------------------------------------------------
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, TxID) =&gt; normalize(I) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(TxID, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, Sender) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;sender&gt; X &lt;/sender&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Sender, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, Fee) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;fee&gt; X &lt;/fee&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Fee, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, FirstValid) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;firstValid&gt; X &lt;/firstValid&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(FirstValid, TYPE)
</span><span class="noop">
</span><span class="noop">  //  rule [[ getTxnField(I, FirstValidTime) =&gt; normalize(X) ]]
</span><span class="noop">  //    &lt;transaction&gt;
</span><span class="noop">  //      &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">  //      &lt;firstValidTime&gt; X &lt;/firstValidTime&gt;
</span><span class="noop">  //      ...
</span><span class="noop">  //    &lt;/transaction&gt;
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, LastValid) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;lastValid&gt; X &lt;/lastValid&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(LastValid, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, Note)  =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;note&gt; X &lt;/note&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Note, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, Lease)  =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;lease&gt; X &lt;/lease&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Lease, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, TxType)  =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;txType&gt; X &lt;/txType&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(TxType, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, TypeEnum)  =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; X &lt;/typeEnum&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(TypeEnum, X)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, GroupIndex)  =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;groupIdx&gt; X &lt;/groupIdx&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(GroupIndex, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, RekeyTo)  =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;rekeyTo&gt; X &lt;/rekeyTo&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(RekeyTo, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, Receiver) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;receiver&gt; X &lt;/receiver&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Receiver, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, Amount) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;amount&gt; X &lt;/amount&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Amount, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, CloseRemainderTo) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;closeRemainderTo&gt; X &lt;/closeRemainderTo&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(CloseRemainderTo, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, VotePK) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;votePk&gt; X &lt;/votePk&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(VotePK, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, SelectionPK) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;selectionPK&gt; X &lt;/selectionPK&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(SelectionPK, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, VoteFirst) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;voteFirst&gt; X &lt;/voteFirst&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(VoteFirst, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, VoteLast) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;voteLast&gt; X &lt;/voteLast&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(VoteLast, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, VoteKeyDilution) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;voteKeyDilution&gt; X &lt;/voteKeyDilution&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(VoteKeyDilution, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, XferAsset) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;xferAsset&gt; X &lt;/xferAsset&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(XferAsset, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, AssetAmount) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;assetAmount&gt; X &lt;/assetAmount&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(AssetAmount, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, AssetASender) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;assetASender&gt; X &lt;/assetASender&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(AssetASender, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, AssetReceiver) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;assetReceiver&gt; X &lt;/assetReceiver&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(AssetReceiver, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, AssetCloseTo) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;assetCloseTo&gt; X &lt;/assetCloseTo&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(AssetCloseTo, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, ApplicationID) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;applicationID&gt; X &lt;/applicationID&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ApplicationID, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, OnCompletion) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;onCompletion&gt; X &lt;/onCompletion&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(OnCompletion, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, ApplicationArgs, J) =&gt; normalize(getTValueAt(J, X)) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;applicationArgs&gt; X &lt;/applicationArgs&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ApplicationArgs, TYPE)
</span><span class="noop">     andBool 0 &lt;=Int J andBool J &lt;Int size(X)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ApplicationArgs) =&gt; X ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;applicationArgs&gt; X &lt;/applicationArgs&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ApplicationArgs, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, NumAppArgs) =&gt; size(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;applicationArgs&gt; X &lt;/applicationArgs&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(NumAppArgs, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, Accounts, 0) =&gt; normalize(A) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;sender&gt; A &lt;/sender&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Accounts, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, Accounts, J) =&gt; normalize(getTValueAt(J -Int 1, X)) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;accounts&gt; X &lt;/accounts&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Accounts, TYPE)
</span><span class="noop">     andBool 0 &lt;Int J andBool J &lt;=Int size(X)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, Accounts) =&gt; (A X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;sender&gt; A &lt;/sender&gt;
</span><span class="noop">         &lt;accounts&gt; X &lt;/accounts&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Accounts, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, NumAccounts) =&gt; size(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;accounts&gt; X &lt;/accounts&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(NumAccounts, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ApprovalProgram) =&gt; X ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;approvalProgram&gt; X &lt;/approvalProgram&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ApprovalProgram, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ClearStateProgram) =&gt; X ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;clearStateProgram&gt; X &lt;/clearStateProgram&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ClearStateProgram, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAsset) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configAsset&gt; X &lt;/configAsset&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAsset, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAssetTotal) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configTotal&gt; X &lt;/configTotal&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAssetTotal, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAssetDecimals) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configDecimals&gt; X &lt;/configDecimals&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAssetDecimals, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAssetDefaultFrozen) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configDefaultFrozen&gt; X &lt;/configDefaultFrozen&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAssetDefaultFrozen, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAssetUnitName) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configUnitName&gt; X &lt;/configUnitName&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAssetUnitName, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAssetName) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configAssetName&gt; X &lt;/configAssetName&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAssetName, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAssetURL) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configAssetURL&gt; X &lt;/configAssetURL&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAssetURL, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAssetMetaDataHash) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configMetaDataHash&gt; X &lt;/configMetaDataHash&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAssetMetaDataHash, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAssetManager) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configManagerAddr&gt; X &lt;/configManagerAddr&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAssetManager, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAssetReserve) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configReserveAddr&gt; X &lt;/configReserveAddr&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAssetReserve, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAssetFreeze) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configFreezeAddr&gt; X &lt;/configFreezeAddr&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAssetFreeze, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, ConfigAssetClawback) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;configClawbackAddr&gt; X &lt;/configClawbackAddr&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(ConfigAssetClawback, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, FreezeAsset) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;freezeAsset&gt; X &lt;/freezeAsset&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(FreezeAsset, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, FreezeAssetAccount) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;freezeAccount&gt; X &lt;/freezeAccount&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(FreezeAssetAccount, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, FreezeAssetFrozen) =&gt; normalize(X) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;assetFrozen&gt; X &lt;/assetFrozen&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(FreezeAssetFrozen, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, Applications, J) =&gt; normalize(getTValueAt(J, X)) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;foreignApps&gt; X &lt;/foreignApps&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Applications, TYPE)
</span><span class="noop">     andBool 0 &lt;=Int J andBool J &lt;Int size(X)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, Applications) =&gt; X ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;foreignApps&gt; X &lt;/foreignApps&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Applications, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, Assets, J) =&gt; normalize(getTValueAt(J, X)) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;foreignAssets&gt; X &lt;/foreignAssets&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Assets, TYPE)
</span><span class="noop">     andBool 0 &lt;=Int J andBool J &lt;Int size(X)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, Assets) =&gt; X ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;foreignAssets&gt; X &lt;/foreignAssets&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Assets, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, LastLog) =&gt; MSG ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;logData&gt; _ MSG:TBytes &lt;/logData&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(LastLog, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, LastLog) =&gt; MSG ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;logData&gt; MSG:TBytes &lt;/logData&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(LastLog, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, NumLogs) =&gt; size(LOGS) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;logData&gt; LOGS &lt;/logData&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(NumLogs, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, Logs, J) =&gt; normalize(getTValueAt(J, LOGS)) ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;logData&gt; LOGS &lt;/logData&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Logs, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, Logs) =&gt; LOGS ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;logData&gt; LOGS &lt;/logData&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(Logs, TYPE)
</span><span class="noop">
</span><span class="miss">  rule [[ getTxnField(I, CreatedApplicationID) =&gt; CREATED_APP ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;txApplicationID&gt; CREATED_APP &lt;/txApplicationID&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(CreatedApplicationID, TYPE)
</span><span class="noop">
</span><span class="hit">  rule [[ getTxnField(I, CreatedAssetID) =&gt; CREATED_ASSET ]]
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; I &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TYPE  &lt;/typeEnum&gt;
</span><span class="noop">         &lt;txConfigAsset&gt; CREATED_ASSET &lt;/txConfigAsset&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires #isValidForTxnType(CreatedAssetID, TYPE)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Failure*
</span><span class="noop">```k
</span><span class="hit">  rule getTxnField(_, _:TxnaField)    =&gt; .TValueList [owise]
</span><span class="hit">  rule getTxnField(_, _:TxnField    ) =&gt; NoTValue    [owise]
</span><span class="hit">  rule getTxnField(_, _, _          ) =&gt; NoTValue    [owise]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Other Helper Functions*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Bool ::= Int &#34;in_calledApps&#34; &#34;(&#34; TransactionsCell &#34;)&#34; [function]
</span><span class="noop">  //---------------------------------------------------------------------
</span><span class="miss">  rule I in_calledApps( &lt;transactions&gt;
</span><span class="noop">                          &lt;transaction&gt;
</span><span class="noop">                            &lt;txnTypeSpecificFields&gt;
</span><span class="noop">                              &lt;appCallTxFields&gt;
</span><span class="noop">                                &lt;applicationID&gt; APP_ID &lt;/applicationID&gt; ...
</span><span class="noop">                              &lt;/appCallTxFields&gt;
</span><span class="noop">                            &lt;/txnTypeSpecificFields&gt; ...
</span><span class="noop">                          &lt;/transaction&gt;
</span><span class="noop">                          REST
</span><span class="noop">                        &lt;/transactions&gt; )
</span><span class="noop">       =&gt; I in_calledApps(&lt;transactions&gt; REST &lt;/transactions&gt;)
</span><span class="noop">    requires I =/=K APP_ID
</span><span class="noop">
</span><span class="miss">  rule I in_calledApps( &lt;transactions&gt;
</span><span class="noop">                          &lt;transaction&gt;
</span><span class="noop">                            &lt;txnTypeSpecificFields&gt;
</span><span class="noop">                              &lt;appCallTxFields&gt;
</span><span class="noop">                                &lt;applicationID&gt; I &lt;/applicationID&gt; ...
</span><span class="noop">                              &lt;/appCallTxFields&gt;
</span><span class="noop">                            &lt;/txnTypeSpecificFields&gt; ...
</span><span class="noop">                          &lt;/transaction&gt;
</span><span class="noop">                          ...
</span><span class="noop">                        &lt;/transactions&gt; )
</span><span class="noop">       =&gt; true
</span><span class="noop">
</span><span class="miss">  rule _ in_calledApps( &lt;transactions&gt; .Bag &lt;/transactions&gt; ) =&gt; false
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Bytes ::= getAppAddress(Int) [function, functional]
</span><span class="noop">  //---------------------------------------------------------
</span><span class="hit">  rule getAppAddress(APP_ID) =&gt; b&#34;application&#34; +Bytes String2Bytes(Int2String(APP_ID))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Int ::= groupSize(String, TransactionsCell) [function]
</span><span class="noop">  //------------------------------------------------
</span><span class="hit">  rule groupSize( GROUP_ID,
</span><span class="noop">                  &lt;transactions&gt;
</span><span class="noop">                    &lt;transaction&gt;
</span><span class="noop">                      &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">                      ...
</span><span class="noop">                    &lt;/transaction&gt;
</span><span class="noop">                    REST
</span><span class="noop">                  &lt;/transactions&gt;)
</span><span class="noop">       =&gt; 1 +Int groupSize(GROUP_ID, &lt;transactions&gt; REST &lt;/transactions&gt;)
</span><span class="noop">
</span><span class="miss">  rule groupSize( GROUP_ID,
</span><span class="noop">                  &lt;transactions&gt;
</span><span class="noop">                    &lt;transaction&gt;
</span><span class="noop">                      &lt;groupID&gt; GROUP_ID&#39; &lt;/groupID&gt;
</span><span class="noop">                      ...
</span><span class="noop">                    &lt;/transaction&gt;
</span><span class="noop">                    REST
</span><span class="noop">                  &lt;/transactions&gt;)
</span><span class="noop">       =&gt; groupSize(GROUP_ID, &lt;transactions&gt; REST &lt;/transactions&gt;)
</span><span class="noop">    requires GROUP_ID =/=K GROUP_ID&#39;
</span><span class="noop">
</span><span class="hit">  rule groupSize( _, &lt;transactions&gt; .Bag &lt;/transactions&gt;) =&gt; 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Bool ::= String &#34;in_txns&#34; &#34;(&#34; TransactionsCell &#34;)&#34; [function]
</span><span class="noop">  // --------------------------------------------------------------
</span><span class="hit">  rule I in_txns( &lt;transactions&gt;
</span><span class="noop">                    &lt;transaction&gt;
</span><span class="noop">                      &lt;txID&gt; I &lt;/txID&gt; ...
</span><span class="noop">                    &lt;/transaction&gt; ...
</span><span class="noop">                  &lt;/transactions&gt; )
</span><span class="noop">       =&gt; true
</span><span class="noop">
</span><span class="hit">  rule I in_txns( &lt;transactions&gt;
</span><span class="noop">                    &lt;transaction&gt;
</span><span class="noop">                      &lt;txID&gt; I&#39; &lt;/txID&gt; ...
</span><span class="noop">                    &lt;/transaction&gt; REST
</span><span class="noop">                  &lt;/transactions&gt; )
</span><span class="noop">       =&gt; I in_txns( &lt;transactions&gt; REST &lt;/transactions&gt; )
</span><span class="noop">    requires I =/=K I&#39;
</span><span class="noop">
</span><span class="hit">  rule _ in_txns( &lt;transactions&gt; .Bag &lt;/transactions&gt; ) =&gt; false
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= #isValidForTxnType(TxnField,     Int) [function, functional]
</span><span class="noop">  syntax Bool ::= #isValidForTxnType(TxnaField,    Int) [function, functional]
</span><span class="noop">  // -------------------------------------------------------------
</span><span class="noop">  // all transaction types
</span><span class="hit">  rule #isValidForTxnType(_:TxnHeaderField  , I)    =&gt; 1 &lt;=Int I andBool I &lt;=Int 6
</span><span class="miss">  rule #isValidForTxnType(_:TxnaDynamicField, I)    =&gt; 1 &lt;=Int I andBool I &lt;=Int 6
</span><span class="hit">  rule #isValidForTxnType(_:TxnDynamicField , I)    =&gt; 1 &lt;=Int I andBool I &lt;=Int 6
</span><span class="noop">  // the pay transaction type
</span><span class="miss">  rule #isValidForTxnType(_:TxnPayField     , I)    =&gt; I ==Int 1
</span><span class="noop">  // the keyreg transaction type
</span><span class="miss">  rule #isValidForTxnType(_:TxnKeyregField  , I)    =&gt; I ==Int 2
</span><span class="noop">  // the config asset transaction type
</span><span class="miss">  rule #isValidForTxnType(_:TxnAcfgField    , I)    =&gt; I ==Int 3
</span><span class="noop">  // the asset transfer transaction type
</span><span class="miss">  rule #isValidForTxnType(_:TxnAxferField   , I)    =&gt; I ==Int 4
</span><span class="noop">  // the asset freeze transaction type
</span><span class="miss">  rule #isValidForTxnType(_:TxnAfrzField    , I)    =&gt; I ==Int 5
</span><span class="noop">  // the application call transaction type
</span><span class="hit">  rule #isValidForTxnType(_:TxnApplField  , I)    =&gt; I ==Int 6
</span><span class="hit">  rule #isValidForTxnType(_:TxnaField     , I)    =&gt; I ==Int 6
</span><span class="noop">  // catch-all failure case
</span><span class="miss">  rule #isValidForTxnType(_:TxnField  , _)    =&gt; false [owise]
</span><span class="miss">  rule #isValidForTxnType(_:TxnaField , _)    =&gt; false [owise]
</span><span class="noop">
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/itxn.md">avm/itxn.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">```k
</span><span class="noop">requires &#34;avm/txn.md&#34;
</span><span class="noop">requires &#34;avm/avm-configuration.md&#34;
</span><span class="noop">requires &#34;avm/avm-txn-deque.md&#34;
</span><span class="noop">requires &#34;avm/avm-execution.md&#34;
</span><span class="noop">requires &#34;avm/avm-initialization.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-types.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-fields.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-execution.md&#34;
</span><span class="noop">
</span><span class="noop">module ALGO-ITXN
</span><span class="noop">  imports ALGO-TXN
</span><span class="noop">  imports AVM-CONFIGURATION
</span><span class="noop">  imports AVM-INITIALIZATION
</span><span class="noop">  imports AVM-TXN-DEQUE
</span><span class="noop">  imports TEAL-TYPES
</span><span class="noop">  imports TEAL-FIELDS
</span><span class="noop">  imports TEAL-EXECUTION
</span><span class="noop">  imports MAP
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= #setItxnField(TxnFieldTop, TValue)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(Sender, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;sender&gt; _ =&gt; VAL &lt;/sender&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(Fee, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;fee&gt; _ =&gt; VAL &lt;/fee&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(Note, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;note&gt; _ =&gt; VAL &lt;/note&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(RekeyTo, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;rekeyTo&gt; _ =&gt; VAL &lt;/rekeyTo&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(TxType, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; 
</span><span class="noop">                   &lt;txType&gt; _ =&gt; VAL &lt;/txType&gt; 
</span><span class="noop">                   &lt;typeEnum&gt; _=&gt; typeString2Enum(VAL) &lt;/typeEnum&gt;
</span><span class="noop">                    ...
</span><span class="noop">                  &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(TypeEnum, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; 
</span><span class="noop">                   &lt;txType&gt; _ =&gt; typeEnum2String(VAL) &lt;/txType&gt; 
</span><span class="noop">                   &lt;typeEnum&gt; _ =&gt; VAL &lt;/typeEnum&gt;
</span><span class="noop">                   ...
</span><span class="noop">                  &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(_:TxnPayField, _) ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           .PayTxFieldsCell =&gt;
</span><span class="noop">           &lt;payTxFields&gt;
</span><span class="noop">             &lt;receiver&gt;         .Bytes &lt;/receiver&gt;
</span><span class="noop">             &lt;amount&gt;           0      &lt;/amount&gt;
</span><span class="noop">             &lt;closeRemainderTo&gt; .Bytes &lt;/closeRemainderTo&gt;
</span><span class="noop">           &lt;/payTxFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(Receiver, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;receiver&gt; _ =&gt; VAL &lt;/receiver&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(Amount, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;amount&gt; _ =&gt; VAL &lt;/amount&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(CloseRemainderTo, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;closeRemainderTo&gt; _ =&gt; VAL &lt;/closeRemainderTo&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(_:TxnKeyregField, _) ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           .KeyRegTxFieldsCell =&gt;
</span><span class="noop">           &lt;keyRegTxFields&gt;
</span><span class="noop">             &lt;votePk&gt;           .Bytes &lt;/votePk&gt;
</span><span class="noop">             &lt;selectionPK&gt;      .Bytes &lt;/selectionPK&gt;
</span><span class="noop">             &lt;voteFirst&gt;        0      &lt;/voteFirst&gt;
</span><span class="noop">             &lt;voteLast&gt;         0      &lt;/voteLast&gt;
</span><span class="noop">             &lt;voteKeyDilution&gt;  0      &lt;/voteKeyDilution&gt;
</span><span class="noop">             &lt;nonparticipation&gt; 0      &lt;/nonparticipation&gt;
</span><span class="noop">           &lt;/keyRegTxFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(VotePK, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;votePk&gt; _ =&gt; VAL &lt;/votePk&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(SelectionPK, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;selectionPK&gt; _ =&gt; VAL &lt;/selectionPK&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(VoteFirst, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;voteFirst&gt; _ =&gt; VAL &lt;/voteFirst&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(VoteLast, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;voteLast&gt; _ =&gt; VAL &lt;/voteLast&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(VoteKeyDilution, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;voteKeyDilution&gt; _ =&gt; VAL &lt;/voteKeyDilution&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(Nonparticipation, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;nonparticipation&gt; _ =&gt; VAL &lt;/nonparticipation&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(_:TxnAcfgField, _) ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           .AssetConfigTxFieldsCell =&gt;
</span><span class="noop">           &lt;assetConfigTxFields&gt;
</span><span class="noop">             &lt;configAsset&gt; 0 &lt;/configAsset&gt;
</span><span class="noop">             &lt;assetParams&gt;
</span><span class="noop">               &lt;configTotal&gt;         0                           &lt;/configTotal&gt;
</span><span class="noop">               &lt;configDecimals&gt;      0                           &lt;/configDecimals&gt;
</span><span class="noop">               &lt;configDefaultFrozen&gt; 0                           &lt;/configDefaultFrozen&gt;
</span><span class="noop">               &lt;configUnitName&gt;      .Bytes                      &lt;/configUnitName&gt;
</span><span class="noop">               &lt;configAssetName&gt;     .Bytes                      &lt;/configAssetName&gt;
</span><span class="noop">               &lt;configAssetURL&gt;      .Bytes                      &lt;/configAssetURL&gt;
</span><span class="noop">               &lt;configMetaDataHash&gt;  .Bytes                      &lt;/configMetaDataHash&gt;
</span><span class="noop">               &lt;configManagerAddr&gt;   getGlobalField(ZeroAddress) &lt;/configManagerAddr&gt;
</span><span class="noop">               &lt;configReserveAddr&gt;   getGlobalField(ZeroAddress) &lt;/configReserveAddr&gt;
</span><span class="noop">               &lt;configFreezeAddr&gt;    getGlobalField(ZeroAddress) &lt;/configFreezeAddr&gt;
</span><span class="noop">               &lt;configClawbackAddr&gt;  getGlobalField(ZeroAddress) &lt;/configClawbackAddr&gt;
</span><span class="noop">             &lt;/assetParams&gt;
</span><span class="noop">           &lt;/assetConfigTxFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(ConfigAsset, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configAsset&gt; _ =&gt; VAL &lt;/configAsset&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(ConfigAssetTotal, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configTotal&gt; _ =&gt; VAL &lt;/configTotal&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(ConfigAssetDecimals, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configDecimals&gt; _ =&gt; VAL &lt;/configDecimals&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(ConfigAssetDefaultFrozen, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configDefaultFrozen&gt; _ =&gt; VAL &lt;/configDefaultFrozen&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(ConfigAssetUnitName, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configUnitName&gt; _ =&gt; VAL &lt;/configUnitName&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(ConfigAssetName, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configAssetName&gt; _ =&gt; VAL &lt;/configAssetName&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(ConfigAssetURL, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configAssetURL&gt; _ =&gt; VAL &lt;/configAssetURL&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(ConfigAssetMetaDataHash, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configMetaDataHash&gt; _ =&gt; VAL &lt;/configMetaDataHash&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(ConfigAssetManager, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configManagerAddr&gt; _ =&gt; VAL &lt;/configManagerAddr&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(ConfigAssetReserve, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configReserveAddr&gt; _ =&gt; VAL &lt;/configReserveAddr&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(ConfigAssetFreeze, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configFreezeAddr&gt; _ =&gt; VAL &lt;/configFreezeAddr&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(ConfigAssetClawback, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;configClawbackAddr&gt; _ =&gt; VAL &lt;/configClawbackAddr&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(_:TxnAxferField, _) ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           .AssetTransferTxFieldsCell =&gt;
</span><span class="noop">           &lt;assetTransferTxFields&gt;
</span><span class="noop">             &lt;xferAsset&gt;     0                           &lt;/xferAsset&gt;
</span><span class="noop">             &lt;assetAmount&gt;   0                           &lt;/assetAmount&gt;
</span><span class="noop">             &lt;assetReceiver&gt; getGlobalField(ZeroAddress) &lt;/assetReceiver&gt;
</span><span class="noop">             &lt;assetASender&gt;  getGlobalField(ZeroAddress) &lt;/assetASender&gt;
</span><span class="noop">             &lt;assetCloseTo&gt;  getGlobalField(ZeroAddress) &lt;/assetCloseTo&gt;
</span><span class="noop">           &lt;/assetTransferTxFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(XferAsset, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;xferAsset&gt; _ =&gt; VAL &lt;/xferAsset&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(AssetAmount, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;assetAmount&gt; _ =&gt; VAL &lt;/assetAmount&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(AssetASender, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;assetASender&gt; _ =&gt; VAL &lt;/assetASender&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(AssetReceiver, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;assetReceiver&gt; _ =&gt; VAL &lt;/assetReceiver&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(AssetCloseTo, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;assetCloseTo&gt; _ =&gt; VAL &lt;/assetCloseTo&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(_:TxnAfrzField, _) ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           .AssetFreezeTxFieldsCell =&gt;
</span><span class="noop">           &lt;assetFreezeTxFields&gt;
</span><span class="noop">             &lt;freezeAccount&gt; getGlobalField(ZeroAddress) &lt;/freezeAccount&gt;
</span><span class="noop">             &lt;freezeAsset&gt;   0                           &lt;/freezeAsset&gt;
</span><span class="noop">             &lt;assetFrozen&gt;   0                           &lt;/assetFrozen&gt;
</span><span class="noop">           &lt;/assetFreezeTxFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(FreezeAsset, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;freezeAsset&gt; _ =&gt; VAL &lt;/freezeAsset&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(FreezeAssetAccount, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;freezeAccount&gt; _ =&gt; VAL &lt;/freezeAccount&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(FreezeAssetFrozen, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;assetFrozen&gt; _ =&gt; VAL &lt;/assetFrozen&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(FIELD, _) ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           .AppCallTxFieldsCell =&gt;
</span><span class="noop">           &lt;appCallTxFields&gt;
</span><span class="noop">             &lt;applicationID&gt;        0                    &lt;/applicationID&gt;
</span><span class="noop">             &lt;onCompletion&gt;         0                    &lt;/onCompletion&gt;
</span><span class="noop">             &lt;accounts&gt;             .TValueList          &lt;/accounts&gt;
</span><span class="noop">             &lt;approvalProgramSrc&gt;   (int 0):TealInputPgm &lt;/approvalProgramSrc&gt;
</span><span class="noop">             &lt;clearStateProgramSrc&gt; (int 0):TealInputPgm &lt;/clearStateProgramSrc&gt;
</span><span class="noop">             &lt;approvalProgram&gt;      .Bytes               &lt;/approvalProgram&gt;
</span><span class="noop">             &lt;clearStateProgram&gt;    .Bytes               &lt;/clearStateProgram&gt;
</span><span class="noop">             &lt;applicationArgs&gt;      .TValueList          &lt;/applicationArgs&gt;
</span><span class="noop">             &lt;foreignApps&gt;          .TValueList          &lt;/foreignApps&gt;
</span><span class="noop">             &lt;foreignAssets&gt;        .TValueList          &lt;/foreignAssets&gt;
</span><span class="noop">             &lt;globalStateSchema&gt;
</span><span class="noop">               &lt;globalNui&gt; 0 &lt;/globalNui&gt;
</span><span class="noop">               &lt;globalNbs&gt; 0 &lt;/globalNbs&gt;
</span><span class="noop">             &lt;/globalStateSchema&gt;
</span><span class="noop">             &lt;localStateSchema&gt;
</span><span class="noop">               &lt;localNui&gt; 0 &lt;/localNui&gt;
</span><span class="noop">               &lt;localNbs&gt; 0 &lt;/localNbs&gt;
</span><span class="noop">             &lt;/localStateSchema&gt;
</span><span class="noop">             &lt;extraProgramPages&gt;    0                    &lt;/extraProgramPages&gt;
</span><span class="noop">           &lt;/appCallTxFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">    requires isTxnApplField(FIELD) orBool isTxnaField(FIELD)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(ApplicationID, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;applicationID&gt; _ =&gt; VAL &lt;/applicationID&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">       
</span><span class="hit">  rule &lt;k&gt; #setItxnField(OnCompletion, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;onCompletion&gt; _ =&gt; VAL &lt;/onCompletion&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(ApprovalProgram, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;approvalProgram&gt; _ =&gt; VAL &lt;/approvalProgram&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(ClearStateProgram, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;clearStateProgram&gt; _ =&gt; VAL &lt;/clearStateProgram&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(ApplicationArgs, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;applicationArgs&gt; APP_ARGS =&gt; append(VAL, APP_ARGS) &lt;/applicationArgs&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #setItxnField(Accounts, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;accounts&gt; ACCOUNTS =&gt; append(VAL, ACCOUNTS) &lt;/accounts&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(Applications, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;foreignApps&gt; APPS =&gt; append(VAL, APPS) &lt;/foreignApps&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #setItxnField(Assets, VAL) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         ...
</span><span class="noop">         ListItem(&lt;transaction&gt; &lt;foreignAssets&gt; ASSETS =&gt; append(VAL, ASSETS) &lt;/foreignAssets&gt; ... &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax KItem ::= #checkItxn(TransactionCell)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkItxn(TXN) =&gt; (#checkItxnFieldsCoherent(TXN) ~&gt; #checkForReentrance(TXN)) ...&lt;/k&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= #checkForReentrance(TransactionCell)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkForReentrance(
</span><span class="noop">             &lt;transaction&gt;
</span><span class="noop">               &lt;txID&gt; _TX_ID &lt;/txID&gt;
</span><span class="noop">               &lt;txnTypeSpecificFields&gt;
</span><span class="noop">                 &lt;appCallTxFields&gt;
</span><span class="noop">                   &lt;applicationID&gt; APP_ID &lt;/applicationID&gt;
</span><span class="noop">                   ...
</span><span class="noop">                 &lt;/appCallTxFields&gt;
</span><span class="noop">               &lt;/txnTypeSpecificFields&gt;
</span><span class="noop">               ...
</span><span class="noop">             &lt;/transaction&gt;) =&gt; .
</span><span class="noop">             ...
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;activeApps&gt; AA &lt;/activeApps&gt;
</span><span class="noop">    requires notBool(APP_ID in AA )
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkForReentrance(
</span><span class="noop">             &lt;transaction&gt;
</span><span class="noop">               &lt;txID&gt; _TX_ID &lt;/txID&gt;
</span><span class="noop">               &lt;txnTypeSpecificFields&gt;
</span><span class="noop">                 &lt;appCallTxFields&gt;
</span><span class="noop">                   &lt;applicationID&gt; APP_ID &lt;/applicationID&gt;
</span><span class="noop">                   ...
</span><span class="noop">                 &lt;/appCallTxFields&gt;
</span><span class="noop">               &lt;/txnTypeSpecificFields&gt;
</span><span class="noop">               ...
</span><span class="noop">             &lt;/transaction&gt;) =&gt; panic(ITXN_REENTRY)
</span><span class="noop">             ...
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;activeApps&gt; AA &lt;/activeApps&gt;
</span><span class="noop">    requires APP_ID in AA
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkForReentrance(_) =&gt; . ...&lt;/k&gt;  [owise]
</span><span class="noop">
</span><span class="noop">  // Ensures the transaction is not malformed prior to executing it in a group. E.g., has fields set only for
</span><span class="noop">  // one type of transaction. This implementation does not yet allow unsetting of fields, e.g. setting them to
</span><span class="noop">  // a default value, allowing you to set more than one type of transaction field as long as all but one end
</span><span class="noop">  // up with only default values.
</span><span class="noop">  syntax KItem ::= #checkItxnFieldsCoherent(TransactionCell)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkItxnFieldsCoherent(
</span><span class="noop">         &lt;transaction&gt; 
</span><span class="noop">           &lt;txnTypeSpecificFields&gt;
</span><span class="noop">             &lt;payTxFields&gt; _ &lt;/payTxFields&gt;
</span><span class="noop">           &lt;/txnTypeSpecificFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;) =&gt; . ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkItxnFieldsCoherent(
</span><span class="noop">         &lt;transaction&gt; 
</span><span class="noop">           &lt;txnTypeSpecificFields&gt;
</span><span class="noop">             &lt;appCallTxFields&gt; _ &lt;/appCallTxFields&gt;
</span><span class="noop">           &lt;/txnTypeSpecificFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;) =&gt; . ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #checkItxnFieldsCoherent(
</span><span class="noop">         &lt;transaction&gt; 
</span><span class="noop">           &lt;txnTypeSpecificFields&gt;
</span><span class="noop">             &lt;keyRegTxFields&gt; _ &lt;/keyRegTxFields&gt;
</span><span class="noop">           &lt;/txnTypeSpecificFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;) =&gt; . ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkItxnFieldsCoherent(
</span><span class="noop">         &lt;transaction&gt; 
</span><span class="noop">           &lt;txnTypeSpecificFields&gt;
</span><span class="noop">             &lt;assetConfigTxFields&gt; _ &lt;/assetConfigTxFields&gt;
</span><span class="noop">           &lt;/txnTypeSpecificFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;) =&gt; . ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #checkItxnFieldsCoherent(
</span><span class="noop">         &lt;transaction&gt; 
</span><span class="noop">           &lt;txnTypeSpecificFields&gt;
</span><span class="noop">             &lt;assetTransferTxFields&gt; _ &lt;/assetTransferTxFields&gt;
</span><span class="noop">           &lt;/txnTypeSpecificFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;) =&gt; . ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #checkItxnFieldsCoherent(
</span><span class="noop">         &lt;transaction&gt; 
</span><span class="noop">           &lt;txnTypeSpecificFields&gt;
</span><span class="noop">             &lt;assetFreezeTxFields&gt; _ &lt;/assetFreezeTxFields&gt;
</span><span class="noop">           &lt;/txnTypeSpecificFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;) =&gt; . ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkItxnFieldsCoherent(&lt;transaction&gt; _T &lt;/transaction&gt;) =&gt; panic(TXN_INVALID) ...&lt;/k&gt; [owise]
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= #checkItxns(List)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkItxns((ListItem(T:TransactionCell) REST)) =&gt; (#checkItxn(T) ~&gt; #checkItxns(REST)) ...&lt;/k&gt;
</span><span class="hit">  rule &lt;k&gt; #checkItxns(.List) =&gt; . ...&lt;/k&gt;
</span><span class="noop">
</span><span class="noop">  syntax AlgorandCommand ::= #evalTxGroup()
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= #executeItxnGroup()
</span><span class="noop">  //----------------------------------
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #executeItxnGroup() =&gt; (#saveState() ~&gt; #pushItxns() ~&gt; #evalTxGroup()) ...&lt;/k&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= #pushItxns()
</span><span class="noop">  //---------------------------
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #pushItxns() =&gt; (#pushTxnFront(&lt;txID&gt; Int2String(TXN_ID) &lt;/txID&gt;) ~&gt; #pushItxns()) ...&lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt; _OTHER_ITXNS:List (ListItem(
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           &lt;txID&gt; _ &lt;/txID&gt;
</span><span class="noop">           &lt;txHeader&gt;
</span><span class="noop">             &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">             TX_HEADER
</span><span class="noop">           &lt;/txHeader&gt;
</span><span class="noop">           TXN_BODY
</span><span class="noop">         &lt;/transaction&gt;
</span><span class="noop">         ) =&gt; .List)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">       &lt;transactions&gt;
</span><span class="noop">         (.Bag =&gt;
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           &lt;txID&gt; Int2String(TXN_ID) &lt;/txID&gt;
</span><span class="noop">           &lt;txHeader&gt;
</span><span class="noop">             &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">             TX_HEADER
</span><span class="noop">           &lt;/txHeader&gt;
</span><span class="noop">           TXN_BODY
</span><span class="noop">         &lt;/transaction&gt;)
</span><span class="noop">         _TXNS
</span><span class="noop">       &lt;/transactions&gt;
</span><span class="noop">       &lt;nextTxnID&gt; TXN_ID =&gt; TXN_ID +Int 1 &lt;/nextTxnID&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #pushItxns() =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt; .List &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= #saveState()
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #saveState() =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTxnExecution&gt; C &lt;/currentTxnExecution&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TXN_ID &lt;/txID&gt;
</span><span class="noop">         &lt;txnExecutionContext&gt;
</span><span class="noop">           _ =&gt; &lt;currentTxnExecution&gt; C &lt;/currentTxnExecution&gt;
</span><span class="noop">         &lt;/txnExecutionContext&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= #loadFromGroupInner(Int, TxnField)
</span><span class="noop">  syntax KItem ::= #loadFromGroupInner(Int, TxnaField, Int)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #loadFromGroupInner(GROUP_IDX, FIELD) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;lastTxnGroupID&gt; LAST_GROUP &lt;/lastTxnGroupID&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; ({getTxnField(TX_ID, FIELD)}:&gt;TValue : XS) &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; SS =&gt; SS +Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupID&gt; LAST_GROUP &lt;/groupID&gt;
</span><span class="noop">         &lt;groupIdx&gt; GROUP_IDX &lt;/groupIdx&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires isTValue(getTxnField(TX_ID, FIELD))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #loadFromGroupInner(GROUP_IDX, FIELD, IDX) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;lastTxnGroupID&gt; LAST_GROUP &lt;/lastTxnGroupID&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; ({getTxnField(TX_ID, FIELD, IDX)}:&gt;TValue : XS) &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; SS =&gt; SS +Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupID&gt; LAST_GROUP &lt;/groupID&gt;
</span><span class="noop">         &lt;groupIdx&gt; GROUP_IDX &lt;/groupIdx&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires isTValue(getTxnField(TX_ID, FIELD, IDX))
</span><span class="noop">
</span><span class="noop">  syntax Int ::= getLastItxnGroupIdx()  [function]
</span><span class="noop">
</span><span class="hit">  rule [[ getLastItxnGroupIdx() =&gt; countTxnsInGroup(&lt;transactions&gt; TXNS &lt;/transactions&gt;, GROUP) -Int 1 ]]
</span><span class="noop">       &lt;transactions&gt; TXNS &lt;/transactions&gt;
</span><span class="noop">       &lt;lastTxnGroupID&gt; GROUP &lt;/lastTxnGroupID&gt;
</span><span class="noop">
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/avm-configuration.md">avm/avm-configuration.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">```k
</span><span class="noop">requires &#34;avm/blockchain.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-syntax.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-stack.md&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Algorand Vitual Machine State
</span><span class="noop">-----------------------------
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module AVM-CONFIGURATION
</span><span class="noop">  imports INT
</span><span class="noop">  imports LIST
</span><span class="noop">  imports SET
</span><span class="noop">  imports ALGO-BLOCKCHAIN
</span><span class="noop">  imports TEAL-INTERPRETER-STATE
</span><span class="noop">  imports TEAL-SYNTAX
</span><span class="noop">
</span><span class="noop">  configuration
</span><span class="noop">    &lt;kavm&gt;
</span><span class="noop">      &lt;k&gt; $PGM:AVMSimulation &lt;/k&gt;
</span><span class="noop">      &lt;returncode exit=&#34;&#34;&gt; 4 &lt;/returncode&gt; // the simulator exit code
</span><span class="noop">      &lt;returnstatus&gt;                       // the exit status message
</span><span class="noop">        &#34;Failure - AVM is stuck&#34;
</span><span class="noop">      &lt;/returnstatus&gt;
</span><span class="noop">      &lt;paniccode&gt; 0 &lt;/paniccode&gt;
</span><span class="noop">
</span><span class="noop">      // The transaction group as submitted
</span><span class="noop">      &lt;transactions/&gt;
</span><span class="noop">
</span><span class="noop">      // Transaction can create inner transactions, and we chose to treat them similarly to the outer ones.
</span><span class="noop">      // We add them into an execution deque --- inner transactions are executed right after their parent one.
</span><span class="noop">      // Initially, the execution deque will contain the transactions from the submitted group (up to `MaxTxGroupSize`, 16 currently).
</span><span class="noop">      // Outer transactions are referred to by their actual `txID`s. Inner transaction will be assigned &#34;fake&#34; `txID`s,
</span><span class="noop">      // starting from `MaxTxGroupSize` (currently 16).
</span><span class="noop">      &lt;avmExecution&gt;
</span><span class="noop">
</span><span class="noop">        // The ID of the transaction currently being executed
</span><span class="noop">        &lt;currentTx&gt; &#34;0&#34; &lt;/currentTx&gt;
</span><span class="noop">
</span><span class="noop">        // The top of the deque is the currently executing transaction, followed by the next transaction which will be 
</span><span class="noop">        // executed when this one is (completely) finished, etc.
</span><span class="noop">        &lt;txnDeque&gt;
</span><span class="noop">          &lt;deque&gt;         .List &lt;/deque&gt;
</span><span class="noop">          &lt;dequeIndexSet&gt; .Set  &lt;/dequeIndexSet&gt;
</span><span class="noop">        &lt;/txnDeque&gt;
</span><span class="noop">
</span><span class="noop">        // The execution context of the current transaction.
</span><span class="noop">        &lt;currentTxnExecution&gt;
</span><span class="noop">          // Globals are mostly immutable during the group execution,
</span><span class="noop">          // besides the application-related fields: CurrentApplicationID, CreatorID
</span><span class="noop">          // and CurrentApplicationAddress
</span><span class="noop">          &lt;globals/&gt;
</span><span class="noop">
</span><span class="noop">          // the `&lt;teal&gt;` cell will control evaluation of TEAL code of the current transaction.
</span><span class="noop">          // The semantics of TEAL has *read-only* access to the `&lt;blockchain&gt;` cell
</span><span class="noop">          // and *read-write* access to the `&lt;effects&gt;` cell.
</span><span class="noop">          &lt;teal/&gt;
</span><span class="noop">
</span><span class="noop">          // the effects of the transaction. Upon approval of the transaction,
</span><span class="noop">          // its effects will be applied onto the `&lt;blockchain&gt;` cell.
</span><span class="noop">          // TODO: how to represent effects? We need to track changes to accounts, assets and apps.
</span><span class="noop">          &lt;effects&gt; .List &lt;/effects&gt;
</span><span class="noop">
</span><span class="noop">          // The group ID of the last inner transaction group that was (directly) executed by the current transaction
</span><span class="noop">          &lt;lastTxnGroupID&gt; &#34;&#34; &lt;/lastTxnGroupID&gt;
</span><span class="noop">
</span><span class="noop">        &lt;/currentTxnExecution&gt;
</span><span class="noop">
</span><span class="noop">        // The inner transaction group that is currently being constructed using `itxn_begin`, `itxn_next`, `itxn_field`, but
</span><span class="noop">        // which has not yet been executed using `itxn_submit`
</span><span class="noop">        &lt;innerTransactions&gt; .List &lt;/innerTransactions&gt;
</span><span class="noop">
</span><span class="noop">        // Applications which are currently on the call stack. This cell is needed so that we can check for re-entrant
</span><span class="noop">        // app calls. The `&lt;txnDeque&gt;` is not sufficient for this because it contains transactions that were not yet called but 
</span><span class="noop">        // will be called further back in the call stack. 
</span><span class="noop">        &lt;activeApps&gt; .Set &lt;/activeApps&gt;
</span><span class="noop">
</span><span class="noop">        // Accounts for which a check will be made at the end of the top-level transaction group to ensure their balance is at 
</span><span class="noop">        // or above their minimum balance
</span><span class="noop">        &lt;touchedAccounts&gt; .Set &lt;/touchedAccounts&gt;
</span><span class="noop">
</span><span class="noop">      &lt;/avmExecution&gt;
</span><span class="noop">
</span><span class="noop">      // The blockchain state will be incrementally updated after
</span><span class="noop">      // each transaction in the group. If one of the transactions fails,
</span><span class="noop">      // the state will be rolled back to the one before execution the group.
</span><span class="noop">      &lt;blockchain/&gt;
</span><span class="noop">
</span><span class="noop">      // A ;-separated concatenation of their source code of TEAL contracts
</span><span class="noop">      // should be supplied as `-cTEAL_PROGRAMS` configuration variuable
</span><span class="noop">      // argument ot `krun`
</span><span class="noop">      &lt;tealPrograms&gt; $TEAL_PROGRAMS:TealPrograms &lt;/tealPrograms&gt;
</span><span class="noop">    &lt;/kavm&gt;
</span><span class="noop">
</span><span class="noop">  // Top-level control of the semantics.
</span><span class="noop">  // Defined in `avm-execution.md`
</span><span class="noop">  syntax AVMSimulation
</span><span class="noop">  syntax AlgorandCommand
</span><span class="noop">
</span><span class="noop">  // Control of transaction evaluation
</span><span class="noop">  // Defined in `avm-execution.md`
</span><span class="noop">  syntax TxnCommand
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">## Lookup for kavm configuration
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  //--------------------------------------
</span><span class="hit">  rule [[ getCurrentTxn() =&gt; I ]]
</span><span class="noop">    &lt;currentTx&gt; I &lt;/currentTx&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">## Panic behaviors
</span><span class="noop">
</span><span class="noop">### Internal panic behaviors
</span><span class="noop">
</span><span class="noop">These panic behaviors indicate that internal assumptions of the semantics were violated.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax InternalPanic ::= String
</span><span class="noop">  syntax InternalPanic ::= &#34;TXN_DEQUE_ERROR&#34; [macro]
</span><span class="noop">  //------------------------------------------------
</span><span class="hit">  rule TXN_DEQUE_ERROR =&gt; &#34;attempt to push a duplicate or missing transaction into deque&#34;
</span><span class="noop">
</span><span class="noop">  syntax AlgorandCommand ::= #internalPanic(InternalPanic)
</span><span class="noop">  //----------------------------------------------------------
</span><span class="miss">  rule &lt;k&gt; #internalPanic(S) ~&gt; _ =&gt; .K &lt;/k&gt;
</span><span class="noop">       &lt;returncode&gt; 4 =&gt; 3 &lt;/returncode&gt;
</span><span class="noop">       &lt;returnstatus&gt; _ =&gt; &#34;Failure - internal error: &#34; +String S
</span><span class="noop">       &lt;/returnstatus&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### AVM panic behaviors
</span><span class="noop">
</span><span class="noop">These are AVM-specific panic behaviors, caused by issues like depleted balances, missing apps, etc.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax String ::= &#34;MIN_BALANCE_VIOLATION&#34;   [macro]
</span><span class="noop">  syntax String ::= &#34;UNSUPPORTED_TXN_TYPE&#34;    [macro]
</span><span class="noop">  syntax String ::= &#34;ASSET_FROZEN_FOR_SENDER&#34; [macro]
</span><span class="noop">  syntax String ::= &#34;ASSET_NOT_OPT_IN&#34;        [macro]
</span><span class="noop">  syntax String ::= &#34;UNKNOWN_ADDRESS&#34;         [macro]
</span><span class="noop">  syntax String ::= &#34;ASSET_NO_PERMISSION&#34;     [macro]
</span><span class="noop">
</span><span class="noop">  //------------------------------------------------
</span><span class="hit">  rule MIN_BALANCE_VIOLATION   =&gt; &#34;account&#39;s balance falls below its allowed minimum balance&#34;
</span><span class="hit">  rule UNSUPPORTED_TXN_TYPE    =&gt; &#34;attempt to execute an unsupported transaction type&#34;
</span><span class="hit">  rule ASSET_FROZEN_FOR_SENDER =&gt; &#34;attempt to send frozen asset holdings&#34;
</span><span class="hit">  rule ASSET_NOT_OPT_IN        =&gt; &#34;either sender or receiver have not opted into asset&#34;
</span><span class="hit">  rule UNKNOWN_ADDRESS         =&gt; &#34;address is not in the &lt;accountsMap&gt;&#34;
</span><span class="hit">  rule ASSET_NO_PERMISSION     =&gt; &#34;sender does not have permission to modify asset&#34;
</span><span class="noop">
</span><span class="noop">  syntax Int ::= panicCode(String)  [function]
</span><span class="noop">  //------------------------------------------
</span><span class="hit">  rule panicCode(MIN_BALANCE_VIOLATION) =&gt; 36
</span><span class="miss">  rule panicCode(UNSUPPORTED_TXN_TYPE) =&gt; 37
</span><span class="miss">  rule panicCode(ASSET_FROZEN_FOR_SENDER) =&gt; 38
</span><span class="miss">  rule panicCode(ASSET_NOT_OPT_IN) =&gt; 39
</span><span class="miss">  rule panicCode(UNKNOWN_ADDRESS) =&gt; 40
</span><span class="miss">  rule panicCode(ASSET_NO_PERMISSION) =&gt; 41
</span><span class="noop">
</span><span class="noop">  syntax AlgorandCommand ::= #avmPanic(String, String)
</span><span class="noop">  //-------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #avmPanic(TXN_ID, S) ~&gt; _ =&gt; .K &lt;/k&gt;
</span><span class="noop">       &lt;returncode&gt; _ =&gt; 3 &lt;/returncode&gt;
</span><span class="noop">       &lt;returnstatus&gt; _ =&gt; &#34;Failure - when executing transaction &#34; +String TXN_ID
</span><span class="noop">                           +String &#34;: &#34; +String S
</span><span class="noop">       &lt;/returnstatus&gt;
</span><span class="noop">       &lt;paniccode&gt; _ =&gt; panicCode(S) &lt;/paniccode&gt;
</span><span class="noop">
</span><span class="noop">endmodule
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">TEAL Interpreter State
</span><span class="noop">----------------------
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module TEAL-INTERPRETER-STATE
</span><span class="noop">  imports TEAL-SYNTAX
</span><span class="noop">  imports TEAL-STACK
</span><span class="noop">  imports MAP
</span><span class="noop">  imports INT
</span><span class="noop">  imports LIST
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Stateless and stateful TEAL programs are parameterized by slightly different
</span><span class="noop">input state. All TEAL programs have access to the:
</span><span class="noop">
</span><span class="noop">-   stack
</span><span class="noop">-   call stack
</span><span class="noop">-   scratch memory
</span><span class="noop">-   containing transaction and transaction group
</span><span class="noop">-   globals
</span><span class="noop">
</span><span class="noop">Stateless TEAL programs additionally have access to the:
</span><span class="noop">
</span><span class="noop">-   logic signature arguments
</span><span class="noop">
</span><span class="noop">Stateful TEAL programs additionally have access to:
</span><span class="noop">
</span><span class="noop">-   local and global application state
</span><span class="noop">-   application state for foreign applications
</span><span class="noop">-   asset parameters for foreign assets
</span><span class="noop">
</span><span class="noop">Note: our configuration also contains a return code. However, this return code
</span><span class="noop">is _not_ a return code in the sense of TEAL; rather, it is a return code in the
</span><span class="noop">sense of POSIX process semantics. This return code is used by the test harness
</span><span class="noop">to determine when a test has succeeded/failed.
</span><span class="noop">
</span><span class="noop">To perform jumps, we maintain a map of labels to their program addresses and a `&lt;jumped&gt;` cell that tracks if the last executed opcode triggered a jump.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax LabelMap ::= Map
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= Label &#34;in_labels&#34; LabelMap [function]
</span><span class="noop">  // --------------------------------------------------
</span><span class="hit">  rule L in_labels LL =&gt; L in_keys(LL)
</span><span class="noop">
</span><span class="noop">  syntax Int ::= getLabelAddress(Label) [function]
</span><span class="noop">  // ---------------------------------------------
</span><span class="hit">  rule [[ getLabelAddress(L) =&gt; {LL[L]}:&gt;Int ]]
</span><span class="noop">       &lt;labels&gt; LL &lt;/labels&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">A subroutine call in TEAL is essentially an unconditional branch to a label, which also saves the program address of the next instruction on the call stack.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax CallStack ::= List
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  configuration
</span><span class="noop">    &lt;teal&gt;
</span><span class="noop">      &lt;pc&gt; 0 &lt;/pc&gt;
</span><span class="noop">      &lt;program&gt; .Map &lt;/program&gt;
</span><span class="noop">      &lt;mode&gt; undefined &lt;/mode&gt;
</span><span class="noop">      &lt;version&gt; 1 &lt;/version&gt;               // the default TEAL version is 1 if no #pragma version is specified
</span><span class="noop">      &lt;stack&gt; .TStack &lt;/stack&gt;             // stores UInt64 or Bytes
</span><span class="noop">      &lt;stacksize&gt; 0 &lt;/stacksize&gt;           // current stack size
</span><span class="noop">      &lt;jumped&gt; false &lt;/jumped&gt;             // `true` if the previous opcode triggered a jump
</span><span class="noop">      &lt;labels&gt; .Map &lt;/labels&gt;              // a map from labels seen so far in a program
</span><span class="noop">                                           // to their corresponding program addresses, Label |-&gt; Int
</span><span class="noop">      &lt;callStack&gt; .List &lt;/callStack&gt;
</span><span class="noop">      &lt;scratch&gt; .Map &lt;/scratch&gt;            // Int |-&gt; TValue
</span><span class="noop">      &lt;intcblock&gt; .Map &lt;/intcblock&gt;        // (currently not used)
</span><span class="noop">      &lt;bytecblock&gt; .Map &lt;/bytecblock&gt;      // (currently not used)
</span><span class="noop">    &lt;/teal&gt;
</span><span class="noop">
</span><span class="noop">  syntax TealExecutionOp ::= #initApp( Int )
</span><span class="noop">                           | #initSmartSig()
</span><span class="noop">                           | #restoreContext()
</span><span class="noop">                           | #initContext()
</span><span class="noop">                           | #startExecution()
</span><span class="noop">                           | #finalizeExecution()
</span><span class="noop">                           | #fetchOpcode()
</span><span class="noop">                           | #incrementPC()
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/avm-execution.md">avm/avm-execution.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">```k
</span><span class="noop">requires &#34;avm/blockchain.md&#34;
</span><span class="noop">requires &#34;avm/constants.md&#34;
</span><span class="noop">requires &#34;avm/txn.md&#34;
</span><span class="noop">requires &#34;avm/itxn.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-syntax.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-driver.md&#34;
</span><span class="noop">requires &#34;avm/avm-configuration.md&#34;
</span><span class="noop">requires &#34;avm/avm-initialization.md&#34;
</span><span class="noop">requires &#34;avm/avm-txn-deque.md&#34;
</span><span class="noop">
</span><span class="noop">module AVM-EXECUTION-SYNTAX
</span><span class="noop">  imports INT
</span><span class="noop">  imports LIST
</span><span class="noop">  imports BYTES
</span><span class="noop">  imports AVM-CONSTANTS
</span><span class="noop">  imports ALGO-BLOCKCHAIN
</span><span class="noop">  imports ALGO-TXN
</span><span class="noop">  imports ALGO-ITXN
</span><span class="noop">  imports AVM-CONFIGURATION
</span><span class="noop">  imports AVM-INITIALIZATION
</span><span class="noop">  imports TEAL-SYNTAX
</span><span class="noop">  imports TEAL-DRIVER
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Top-level model control rules
</span><span class="noop">-----------------------------
</span><span class="noop">
</span><span class="noop">The model has a number of top-level rules that will control the configuration initialisation, trigger execution, etc.
</span><span class="noop">A sequence of `AlgorandCommand`s will be supplied as `$PGM` to `krun`.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AVMSimulation ::= &#34;.AS&#34;
</span><span class="noop">                         | AlgorandCommand &#34;;&#34; AVMSimulation
</span><span class="noop">  // -------------------------------------------------------
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; .AS                  =&gt; .        ... &lt;/k&gt;
</span><span class="hit">  rule &lt;k&gt; AC; .AS              =&gt; AC       ... &lt;/k&gt;
</span><span class="hit">  rule &lt;k&gt; AC; AS:AVMSimulation =&gt; AC ~&gt; AS ... &lt;/k&gt;
</span><span class="noop">    requires AS =/=K .AS
</span><span class="noop">
</span><span class="noop">  syntax AlgorandCommand
</span><span class="noop">
</span><span class="noop">endmodule
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module AVM-EXECUTION
</span><span class="noop">  imports AVM-EXECUTION-SYNTAX
</span><span class="noop">  imports AVM-TXN-DEQUE
</span><span class="noop">  imports ALGO-TXN
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Transaction Group Evaluation
</span><span class="noop">----------------------------
</span><span class="noop">
</span><span class="noop">### Transaction execution pipeline
</span><span class="noop">
</span><span class="noop">The `#evalTxs()` rule calls the `#evalTx()` rule until the transaction deque is empty.
</span><span class="noop">The transactions can push new (inner) transactions into the front of `txnDeque` and they
</span><span class="noop">will be executed immediately after their parent transaction, provided it has been accepted.
</span><span class="noop">
</span><span class="noop">If one of the transactions is denied (including the inner ones), the group evaluation stops
</span><span class="noop">and the current configuration is frozen for examination.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #setMode(TealMode)
</span><span class="noop">  //-------------------------------------------
</span><span class="miss">  rule &lt;k&gt; #setMode(MODE) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;mode&gt; _ =&gt; MODE &lt;/mode&gt;
</span><span class="noop">  
</span><span class="noop">  // #evalTxGroup
</span><span class="noop">  //---------------------------------------
</span><span class="hit">  rule &lt;k&gt; #evalTxGroup() =&gt; #initTxGroup() ~&gt; #initTxnIndexMap() ~&gt; #evalNextTx() ...&lt;/k&gt;
</span><span class="noop">
</span><span class="noop">  syntax AlgorandCommand ::= #evalNextTx()
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; (#evalNextTx() ~&gt; _) =&gt; #getNextTxn() ~&gt; #evalTx() ~&gt; #popTxnFront() ~&gt; #evalNextTx() &lt;/k&gt;
</span><span class="noop">       &lt;deque&gt; TXN_DEQUE &lt;/deque&gt;
</span><span class="noop">    requires TXN_DEQUE =/=K .List
</span><span class="noop">
</span><span class="noop">  // Minimum balances are only checked at the conclusion of the outer-level group.
</span><span class="hit">  rule &lt;k&gt; #evalNextTx() =&gt; #checkSufficientBalance() ... &lt;/k&gt;
</span><span class="noop">      &lt;returncode&gt; _ =&gt; 0 &lt;/returncode&gt;
</span><span class="noop">      &lt;returnstatus&gt; _ =&gt; &#34;Success - transaction group accepted&#34;
</span><span class="noop">      &lt;/returnstatus&gt;
</span><span class="noop">      &lt;deque&gt; .List &lt;/deque&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Executing next transaction
</span><span class="noop">
</span><span class="noop">The execution flow of a single transaction is as follows:
</span><span class="noop">* pop transaction from deque
</span><span class="noop">* check signature
</span><span class="noop">* (optional) eval stateless TEAL, if the transaction is signed by a logic signature
</span><span class="noop">* (optional) eval stateful TEAL, if the transaction is an application call
</span><span class="noop">* apply effects if accepted
</span><span class="noop">
</span><span class="noop">All transactions will be signed, either by a normal account or by a logic signature.
</span><span class="noop">The signature verification process will either check the signature itself, or evaluate
</span><span class="noop">the attached stateless TEAL if the transaction is logicsig-signed.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #evalTx()
</span><span class="noop">  //----------------------------------
</span><span class="hit">  rule &lt;k&gt; #evalTx() =&gt; 
</span><span class="noop">             #initContext()
</span><span class="noop">          ~&gt; #checkTxnSignature() 
</span><span class="noop">          ~&gt; #executeTxn(TXN_TYPE) 
</span><span class="noop">       ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TXN_ID &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; TXN_TYPE &lt;/typeEnum&gt;
</span><span class="noop">         &lt;resume&gt; false =&gt; true &lt;/resume&gt;
</span><span class="noop">         &lt;sender&gt; SENDER_ADDR &lt;/sender&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;touchedAccounts&gt; .Set =&gt; SetItem(SENDER_ADDR) ...&lt;/touchedAccounts&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #evalTx() =&gt; #restoreContext() ~&gt; #evalTeal() ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TXN_ID &lt;/txID&gt;
</span><span class="noop">         &lt;typeEnum&gt; _TXN_TYPE &lt;/typeEnum&gt;
</span><span class="noop">         &lt;resume&gt; true &lt;/resume&gt;
</span><span class="noop">         &lt;sender&gt; SENDER_ADDR &lt;/sender&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;touchedAccounts&gt; .Set =&gt; SetItem(SENDER_ADDR) ...&lt;/touchedAccounts&gt;
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Check signature
</span><span class="noop">
</span><span class="noop">The first step of transaction evaluation is to check that its signature is valid. There are several options to sign a transaction,
</span><span class="noop">and we would like to address them uniformly. A transactions can by signed by:
</span><span class="noop">
</span><span class="noop">* a regular account
</span><span class="noop">* a multi-signature account
</span><span class="noop">* a logic signature contract account
</span><span class="noop">
</span><span class="noop">TODO: augment the configuration in `modules/common/txn.md` to support signed transactions.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #checkTxnSignature()
</span><span class="noop">  //---------------------------------------------
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkTxnSignature() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">For now, we do not check signatures *here*, hence this operation is noop.
</span><span class="noop">We check logic signatures in an ad-hoc way for payments and asset transfers at a later step.
</span><span class="noop">
</span><span class="noop">#### Post-evaluation operations
</span><span class="noop">
</span><span class="noop">Clear local state
</span><span class="noop">
</span><span class="noop">case 1: clear state from own created app
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #clearState( TValue, TValue )
</span><span class="noop">  //------------------------------------------------------
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #clearState(APP_ID, ADDR) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           (&lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt; APP_ID &lt;/optInAppID&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInApp&gt;) =&gt; .Bag
</span><span class="noop">           ...
</span><span class="noop">         &lt;/appsOptedIn&gt;
</span><span class="noop">         &lt;appsCreated&gt;
</span><span class="noop">           &lt;appID&gt; APP_ID &lt;/appID&gt;
</span><span class="noop">           &lt;localNumInts&gt;     LOCAL_INTS      &lt;/localNumInts&gt;
</span><span class="noop">           &lt;localNumBytes&gt;    LOCAL_BYTES     &lt;/localNumBytes&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/appsCreated&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BALANCE =&gt; MIN_BALANCE 
</span><span class="noop">                                -Int (PARAM_APP_OPTIN_FLAT 
</span><span class="noop">                                +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_UINT_MIN_BALANCE) 
</span><span class="noop">                                  *Int LOCAL_INTS)
</span><span class="noop">                                +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_BYTES_MIN_BALANCE) 
</span><span class="noop">                                  *Int LOCAL_BYTES))
</span><span class="noop">         &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">case 1: clear state from other&#39;s created app
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #clearState(APP_ID, ADDR) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           (&lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt; APP_ID &lt;/optInAppID&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInApp&gt;) =&gt; .Bag
</span><span class="noop">           ...
</span><span class="noop">         &lt;/appsOptedIn&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BALANCE =&gt; MIN_BALANCE 
</span><span class="noop">                                -Int (PARAM_APP_OPTIN_FLAT 
</span><span class="noop">                                +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_UINT_MIN_BALANCE) 
</span><span class="noop">                                  *Int LOCAL_INTS)
</span><span class="noop">                                +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_BYTES_MIN_BALANCE) 
</span><span class="noop">                                  *Int LOCAL_BYTES))
</span><span class="noop">         &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">       &lt;appsCreated&gt;
</span><span class="noop">         &lt;appID&gt; APP_ID &lt;/appID&gt;
</span><span class="noop">         &lt;localNumInts&gt;     LOCAL_INTS      &lt;/localNumInts&gt;
</span><span class="noop">         &lt;localNumBytes&gt;    LOCAL_BYTES     &lt;/localNumBytes&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/appsCreated&gt;
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Update application programs
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #updatePrograms( TValue, KItem, KItem )
</span><span class="noop">  //----------------------------------------------------------------
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #updatePrograms(APP_ID, APPROVAL_PGM, CLEAR_STATE_PGM) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP_ID &lt;/appID&gt;
</span><span class="noop">         &lt;approvalPgmSrc&gt; _ =&gt; APPROVAL_PGM &lt;/approvalPgmSrc&gt;
</span><span class="noop">         &lt;clearStatePgmSrc&gt; _ =&gt; CLEAR_STATE_PGM &lt;/clearStatePgmSrc&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Delete application
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #deleteApplication( TValue )
</span><span class="noop">  //------------------------------------------------------
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #deleteApplication(APP_ID) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;appsCreated&gt;
</span><span class="noop">           ((&lt;app&gt;
</span><span class="noop">             &lt;appID&gt; APP_ID &lt;/appID&gt;
</span><span class="noop">             &lt;globalNumInts&gt;    GLOBAL_INTS     &lt;/globalNumInts&gt;
</span><span class="noop">             &lt;globalNumBytes&gt;   GLOBAL_BYTES    &lt;/globalNumBytes&gt;
</span><span class="noop">             &lt;extraPages&gt;    EXTRA_PAGES     &lt;/extraPages&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/app&gt;) =&gt; .Bag) ...
</span><span class="noop">         &lt;/appsCreated&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BALANCE =&gt; MIN_BALANCE 
</span><span class="noop">                                -Int (((1 +Int EXTRA_PAGES) *Int PARAM_APP_PAGE_FLAT) 
</span><span class="noop">                                +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_UINT_MIN_BALANCE) 
</span><span class="noop">                                  *Int GLOBAL_INTS)
</span><span class="noop">                                +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_BYTES_MIN_BALANCE) 
</span><span class="noop">                                  *Int GLOBAL_BYTES))
</span><span class="noop">         &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Close asset account to
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #closeTo(TValue, TValue, TValue)
</span><span class="noop">  //---------------------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #closeTo(ASSET_ID, FROM, CLOSE_TO) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; FROM &lt;/address&gt;
</span><span class="noop">         &lt;assetsOptedIn&gt;
</span><span class="noop">           (&lt;optInAsset&gt;
</span><span class="noop">             &lt;optInAssetID&gt; ASSET_ID &lt;/optInAssetID&gt;
</span><span class="noop">             &lt;optInAssetBalance&gt; BALANCE &lt;/optInAssetBalance&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInAsset&gt;) =&gt; .Bag
</span><span class="noop">           ...
</span><span class="noop">         &lt;/assetsOptedIn&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BALANCE =&gt; MIN_BALANCE -Int PARAM_MIN_BALANCE &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; CLOSE_TO &lt;/address&gt;
</span><span class="noop">         &lt;optInAsset&gt;
</span><span class="noop">           &lt;optInAssetID&gt; ASSET_ID &lt;/optInAssetID&gt;
</span><span class="noop">           &lt;optInAssetBalance&gt; PREV_BALANCE =&gt; PREV_BALANCE +Int BALANCE &lt;/optInAssetBalance&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/optInAsset&gt;
</span><span class="noop">           ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Add asset to account
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #giveAsset(TValue, TValue, TValue)
</span><span class="noop">  //-----------------------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #giveAsset(ASSET_ID, ACCOUNT, AMOUNT) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ACCOUNT &lt;/address&gt;
</span><span class="noop">         &lt;optInAsset&gt;
</span><span class="noop">           &lt;optInAssetID&gt; ASSET_ID &lt;/optInAssetID&gt;
</span><span class="noop">           &lt;optInAssetBalance&gt; BALANCE =&gt; BALANCE +Int AMOUNT &lt;/optInAssetBalance&gt;
</span><span class="noop">           &lt;optInAssetFrozen&gt; 0 &lt;/optInAssetFrozen&gt;
</span><span class="noop">         &lt;/optInAsset&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">       requires (BALANCE +Int AMOUNT) &gt;=Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #checkSufficientBalance()
</span><span class="noop">  //--------------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #checkSufficientBalance() =&gt; (#checkSufficientBalance(ADDR) ~&gt; #checkSufficientBalance()) ...&lt;/k&gt;
</span><span class="noop">       &lt;touchedAccounts&gt; (SetItem(ADDR) =&gt; .Set) ...&lt;/touchedAccounts&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkSufficientBalance() =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;touchedAccounts&gt; .Set &lt;/touchedAccounts&gt;
</span><span class="noop">  
</span><span class="noop">  syntax AlgorandCommand ::= #checkSufficientBalance(Bytes)
</span><span class="noop">  //-------------------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #checkSufficientBalance(ADDR) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;balance&gt; BALANCE &lt;/balance&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BALANCE &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires BALANCE &gt;=Int MIN_BALANCE
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #checkSufficientBalance(ADDR) =&gt; #avmPanic(TX_ID, MIN_BALANCE_VIOLATION) ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;balance&gt; BALANCE &lt;/balance&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BALANCE &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires BALANCE &lt;Int MIN_BALANCE
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### (Optional) Eval TEAL
</span><span class="noop">
</span><span class="noop">There are two types of TEAL programs:
</span><span class="noop">* *Stateful*: application calls trigger evaluation of the application&#39;s approval/clear state program.
</span><span class="noop">* *Stateless*: payment, asset transfer and possibly other transactions can carry a logic signature that
</span><span class="noop">needs to be evaluated to approve/deny the transaction.
</span><span class="noop">
</span><span class="noop">##### Stateful
</span><span class="noop">
</span><span class="noop">Application call transactions trigger the execution of the contract&#39;s approval or clear state program, assuming that the contract exists.
</span><span class="noop">We do not consider the special case of contract creation (deployment) here, it will be addressed in the later rules.
</span><span class="noop">TODO: address contact creation.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #evalTeal()
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #evalTeal() =&gt; #startExecution() ~&gt; #saveScratch() ... &lt;/k&gt;
</span><span class="noop">       &lt;returncode&gt;           _ =&gt; 4                           &lt;/returncode&gt;   // (re-)initialize the code
</span><span class="noop">       &lt;returnstatus&gt;         _ =&gt;&#34;Failure - program is stuck&#34; &lt;/returnstatus&gt; // and status with &#34;in-progress&#34; values
</span><span class="noop">
</span><span class="noop">  syntax AlgorandCommand ::= #loadInputPgm( TealInputPgm )
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #loadInputPgm(PGM) =&gt; OpaqueTeal(PGM) ...&lt;/k&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">##### Stateless
</span><span class="noop">
</span><span class="noop">#### Apply transaction&#39;s effects
</span><span class="noop">
</span><span class="noop">Alter the network state with the effects of an approved transaction. Note that payments
</span><span class="noop">and asset transfers can still fail at that point.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #executeTxn(TValue) // transaction type, as defined in `teal-constants.md`
</span><span class="noop">  // -------------------------------------------
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">* **Payment**
</span><span class="noop">
</span><span class="noop">Overflow on subtraction is impossible because the minimum balance is at least 0.1 Algo.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #executeTxn(@pay) =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;     TXN_ID   &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;   SENDER   &lt;/sender&gt;
</span><span class="noop">         &lt;receiver&gt; RECEIVER &lt;/receiver&gt;
</span><span class="noop">         &lt;amount&gt;   AMOUNT   &lt;/amount&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; SENDER &lt;/address&gt;
</span><span class="noop">         &lt;balance&gt; SENDER_BALANCE =&gt; SENDER_BALANCE -Int AMOUNT &lt;/balance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; RECEIVER &lt;/address&gt;
</span><span class="noop">         &lt;balance&gt; RECEIVER_BALANCE =&gt; RECEIVER_BALANCE +Int AMOUNT &lt;/balance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">       &lt;touchedAccounts&gt; (.Set =&gt; SetItem(RECEIVER)) ...&lt;/touchedAccounts&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #executeTxn(@pay) =&gt; panic(INSUFFICIENT_FUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;     TXN_ID   &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;   SENDER   &lt;/sender&gt;
</span><span class="noop">         &lt;amount&gt;   AMOUNT   &lt;/amount&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; SENDER &lt;/address&gt;
</span><span class="noop">         &lt;balance&gt; SENDER_BALANCE &lt;/balance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires SENDER_BALANCE -Int AMOUNT &lt;Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #executeTxn(@pay) =&gt; #avmPanic(TXN_ID, UNKNOWN_ADDRESS) ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;     TXN_ID   &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;   SENDER   &lt;/sender&gt;
</span><span class="noop">         &lt;amount&gt;   _AMOUNT   &lt;/amount&gt;
</span><span class="noop">         &lt;receiver&gt; RECEIVER &lt;/receiver&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;accountsMap&gt;
</span><span class="noop">         AMAP
</span><span class="noop">       &lt;/accountsMap&gt;
</span><span class="noop">    requires notBool ( SENDER in_accounts (&lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;) )
</span><span class="noop">      orBool notBool ( RECEIVER in_accounts (&lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;) )
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">* **Key Registration**
</span><span class="noop">
</span><span class="noop">Not supported.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; #executeTxn(@keyreg) =&gt; #avmPanic(TXN_ID, UNSUPPORTED_TXN_TYPE) ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">* **Asset Configuration**
</span><span class="noop">
</span><span class="noop">Create asset
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #executeTxn(@acfg) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;                TXN_ID         &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;              SENDER         &lt;/sender&gt;
</span><span class="noop">         &lt;configAsset&gt;         0              &lt;/configAsset&gt;
</span><span class="noop">         &lt;configTotal&gt;         TOTAL          &lt;/configTotal&gt;
</span><span class="noop">         &lt;configDecimals&gt;      DECIMALS       &lt;/configDecimals&gt;
</span><span class="noop">         &lt;configDefaultFrozen&gt; DEFAULT_FROZEN &lt;/configDefaultFrozen&gt;
</span><span class="noop">         &lt;configUnitName&gt;      UNIT_NAME      &lt;/configUnitName&gt;
</span><span class="noop">         &lt;configAssetName&gt;     NAME           &lt;/configAssetName&gt;
</span><span class="noop">         &lt;configAssetURL&gt;      ASSET_URL      &lt;/configAssetURL&gt;
</span><span class="noop">         &lt;configMetaDataHash&gt;  METADATA_HASH  &lt;/configMetaDataHash&gt;
</span><span class="noop">         &lt;configManagerAddr&gt;   MANAGER_ADDR   &lt;/configManagerAddr&gt;
</span><span class="noop">         &lt;configReserveAddr&gt;   RESERVE_ADDR   &lt;/configReserveAddr&gt;
</span><span class="noop">         &lt;configFreezeAddr&gt;    FREEZE_ADDR    &lt;/configFreezeAddr&gt;
</span><span class="noop">         &lt;configClawbackAddr&gt;  CLAWB_ADDR     &lt;/configClawbackAddr&gt;
</span><span class="noop">         &lt;txConfigAsset&gt;       _ =&gt; ASSET_ID  &lt;/txConfigAsset&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">
</span><span class="noop">       &lt;nextAssetID&gt; ASSET_ID =&gt; ASSET_ID +Int 1 &lt;/nextAssetID&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; SENDER &lt;/address&gt;
</span><span class="noop">         &lt;assetsCreated&gt;
</span><span class="noop">           ASSETS =&gt;
</span><span class="noop">           (&lt;asset&gt;
</span><span class="noop">             &lt;assetID&gt;            ASSET_ID       &lt;/assetID&gt;
</span><span class="noop">             &lt;assetName&gt;          NAME           &lt;/assetName&gt;
</span><span class="noop">             &lt;assetUnitName&gt;      UNIT_NAME      &lt;/assetUnitName&gt;
</span><span class="noop">             &lt;assetTotal&gt;         TOTAL          &lt;/assetTotal&gt;
</span><span class="noop">             &lt;assetDecimals&gt;      DECIMALS       &lt;/assetDecimals&gt;
</span><span class="noop">             &lt;assetDefaultFrozen&gt; DEFAULT_FROZEN &lt;/assetDefaultFrozen&gt;
</span><span class="noop">             &lt;assetURL&gt;           ASSET_URL      &lt;/assetURL&gt;
</span><span class="noop">             &lt;assetMetaDataHash&gt;  METADATA_HASH  &lt;/assetMetaDataHash&gt;
</span><span class="noop">             &lt;assetManagerAddr&gt;   MANAGER_ADDR   &lt;/assetManagerAddr&gt;
</span><span class="noop">             &lt;assetReserveAddr&gt;   RESERVE_ADDR   &lt;/assetReserveAddr&gt;
</span><span class="noop">             &lt;assetFreezeAddr&gt;    FREEZE_ADDR    &lt;/assetFreezeAddr&gt;
</span><span class="noop">             &lt;assetClawbackAddr&gt;  CLAWB_ADDR     &lt;/assetClawbackAddr&gt;
</span><span class="noop">           &lt;/asset&gt;
</span><span class="noop">           ASSETS)
</span><span class="noop">         &lt;/assetsCreated&gt;
</span><span class="noop">         &lt;assetsOptedIn&gt;
</span><span class="noop">           ASSETS_OPTED_IN =&gt;
</span><span class="noop">           &lt;optInAsset&gt;
</span><span class="noop">             &lt;optInAssetID&gt;      ASSET_ID       &lt;/optInAssetID&gt;
</span><span class="noop">             &lt;optInAssetBalance&gt; TOTAL          &lt;/optInAssetBalance&gt;
</span><span class="noop">             &lt;optInAssetFrozen&gt;  DEFAULT_FROZEN &lt;/optInAssetFrozen&gt;
</span><span class="noop">           &lt;/optInAsset&gt;
</span><span class="noop">           ASSETS_OPTED_IN
</span><span class="noop">         &lt;/assetsOptedIn&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BALANCE =&gt; MIN_BALANCE +Int PARAM_MIN_BALANCE &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">       &lt;assetCreator&gt; .Map =&gt; (ASSET_ID |-&gt; SENDER) ...&lt;/assetCreator&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Modify asset
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; #executeTxn(@acfg) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;                TXN_ID          &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;              SENDER          &lt;/sender&gt;
</span><span class="noop">         &lt;configAsset&gt;         ASSET_ID:TValue &lt;/configAsset&gt;
</span><span class="noop">         &lt;configManagerAddr&gt;   MANAGER_ADDR    &lt;/configManagerAddr&gt;
</span><span class="noop">         &lt;configReserveAddr&gt;   RESERVE_ADDR    &lt;/configReserveAddr&gt;
</span><span class="noop">         &lt;configFreezeAddr&gt;    FREEZE_ADDR     &lt;/configFreezeAddr&gt;
</span><span class="noop">         &lt;configClawbackAddr&gt;  CLAWB_ADDR      &lt;/configClawbackAddr&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;asset&gt;
</span><span class="noop">         &lt;assetID&gt;            ASSET_ID               &lt;/assetID&gt;
</span><span class="noop">         &lt;assetManagerAddr&gt;   SENDER =&gt; MANAGER_ADDR &lt;/assetManagerAddr&gt;
</span><span class="noop">         &lt;assetReserveAddr&gt;   _ =&gt; RESERVE_ADDR      &lt;/assetReserveAddr&gt;
</span><span class="noop">         &lt;assetFreezeAddr&gt;    _ =&gt; FREEZE_ADDR       &lt;/assetFreezeAddr&gt;
</span><span class="noop">         &lt;assetClawbackAddr&gt;  _ =&gt; CLAWB_ADDR        &lt;/assetClawbackAddr&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/asset&gt;
</span><span class="noop">    requires isTValue(MANAGER_ADDR) 
</span><span class="noop">      orBool isTValue(RESERVE_ADDR) 
</span><span class="noop">      orBool isTValue(FREEZE_ADDR) 
</span><span class="noop">      orBool isTValue(CLAWB_ADDR)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Destroy asset
</span><span class="noop">
</span><span class="noop">&#34;A Destroy Transaction is issued to remove an asset from the Algorand ledger. To destroy an existing asset on
</span><span class="noop">Algorand, the original creator must be in possession of all units of the asset and the manager must send and
</span><span class="noop">therefore authorize the transaction.&#34;
</span><span class="noop">
</span><span class="noop">&#34;This transaction differentiates itself from an Asset Creation transaction in that it contains an asset ID
</span><span class="noop">(caid) pointing to the asset to be destroyed. It differentiates itself from an Asset Reconfiguration
</span><span class="noop">transaction by the lack of any asset parameters.&#34;&#34;
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #executeTxn(@acfg) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;                TXN_ID          &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;              SENDER          &lt;/sender&gt;
</span><span class="noop">         &lt;configAsset&gt;         ASSET_ID:TValue &lt;/configAsset&gt;
</span><span class="noop">         &lt;configManagerAddr&gt;   NoTValue        &lt;/configManagerAddr&gt;
</span><span class="noop">         &lt;configReserveAddr&gt;   NoTValue        &lt;/configReserveAddr&gt;
</span><span class="noop">         &lt;configFreezeAddr&gt;    NoTValue        &lt;/configFreezeAddr&gt;
</span><span class="noop">         &lt;configClawbackAddr&gt;  NoTValue        &lt;/configClawbackAddr&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; CREATOR &lt;/address&gt;
</span><span class="noop">         &lt;assetsCreated&gt;
</span><span class="noop">           (&lt;asset&gt;
</span><span class="noop">             &lt;assetID&gt;            ASSET_ID &lt;/assetID&gt;
</span><span class="noop">             &lt;assetManagerAddr&gt;   SENDER   &lt;/assetManagerAddr&gt;
</span><span class="noop">             &lt;assetTotal&gt;         BALANCE  &lt;/assetTotal&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/asset&gt;) =&gt; .Bag
</span><span class="noop">           ...
</span><span class="noop">         &lt;/assetsCreated&gt;
</span><span class="noop">         &lt;assetsOptedIn&gt;
</span><span class="noop">           (&lt;optInAsset&gt;
</span><span class="noop">             &lt;optInAssetID&gt;      ASSET_ID &lt;/optInAssetID&gt;
</span><span class="noop">             &lt;optInAssetBalance&gt; BALANCE  &lt;/optInAssetBalance&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInAsset&gt;) =&gt; .Bag
</span><span class="noop">           ...
</span><span class="noop">         &lt;/assetsOptedIn&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BALANCE =&gt; MIN_BALANCE -Int PARAM_MIN_BALANCE &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">       &lt;assetCreator&gt; (ASSET_ID |-&gt; CREATOR) =&gt; .Map ...&lt;/assetCreator&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Modify/delete asset no permission case
</span><span class="noop">
</span><span class="noop">TODO split into other cases?
</span><span class="noop">  - user or asset doesn&#39;t exist
</span><span class="noop">  - sender not manager of the asset
</span><span class="noop">  - Original creator doesn&#39;t have all the funds when trying to delete
</span><span class="noop">  - Maybe more?
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; #executeTxn(@acfg) =&gt; #avmPanic(TXN_ID, ASSET_NO_PERMISSION) ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt; [owise]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">* **Asset Transfer**
</span><span class="noop">
</span><span class="noop">Asset transfer goes through if:
</span><span class="noop">- both sender and receiver opted into the asset
</span><span class="noop">- sender has enough holdings
</span><span class="noop">- sender&#39;s holdings are not frozen
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #executeTxn(@axfer) =&gt; 
</span><span class="noop">                #giveAsset(ASSET_ID, SENDER, 0 -Int AMOUNT) 
</span><span class="noop">             ~&gt; #giveAsset(ASSET_ID, RECEIVER, AMOUNT) 
</span><span class="noop">           ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID   &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;        SENDER   &lt;/sender&gt;
</span><span class="noop">         &lt;xferAsset&gt;     ASSET_ID &lt;/xferAsset&gt;
</span><span class="noop">         &lt;assetReceiver&gt; RECEIVER &lt;/assetReceiver&gt;
</span><span class="noop">         &lt;assetAmount&gt;   AMOUNT   &lt;/assetAmount&gt;
</span><span class="noop">         &lt;assetCloseTo&gt;  NoTValue &lt;/assetCloseTo&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires hasOptedInAsset(ASSET_ID, SENDER)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Asset transfer with a non-zero amount fails if:
</span><span class="noop">- either the sender or the receiver have not opted in;
</span><span class="noop">- sender&#39;s holdings are frozen
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; #executeTxn(@axfer) =&gt; #avmPanic(TXN_ID, ASSET_NOT_OPT_IN) ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID   &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;        SENDER   &lt;/sender&gt;
</span><span class="noop">         &lt;xferAsset&gt;     ASSET_ID &lt;/xferAsset&gt;
</span><span class="noop">         &lt;assetCloseTo&gt;  NoTValue &lt;/assetCloseTo&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; SENDER &lt;/address&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; RECEIVER &lt;/address&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires SENDER =/=K RECEIVER
</span><span class="noop">      andBool (notBool hasOptedInAsset(ASSET_ID, SENDER)
</span><span class="noop">        orBool notBool hasOptedInAsset(ASSET_ID, RECEIVER))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #executeTxn(@axfer) =&gt; #avmPanic(TXN_ID, ASSET_FROZEN_FOR_SENDER) ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID   &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;        SENDER   &lt;/sender&gt;
</span><span class="noop">         &lt;xferAsset&gt;     ASSET_ID &lt;/xferAsset&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; SENDER &lt;/address&gt;
</span><span class="noop">         &lt;optInAsset&gt;
</span><span class="noop">           &lt;optInAssetID&gt;      ASSET_ID       &lt;/optInAssetID&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/optInAsset&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires hasOptedInAsset(ASSET_ID, SENDER)
</span><span class="noop">     andBool (getOptInAssetField(AssetFrozen, SENDER, ASSET_ID) ==K 1)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">**Asset opt-in** is a special case of asset transfer: a transfer of zero to self.
</span><span class="noop">
</span><span class="noop">Asset opt-in goes through if:
</span><span class="noop">- asset exists
</span><span class="noop">- sender has not yet opted into the asset
</span><span class="noop">- amount is zero
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #executeTxn(@axfer) =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID   &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;        SENDER   &lt;/sender&gt;
</span><span class="noop">         &lt;xferAsset&gt;     ASSET_ID &lt;/xferAsset&gt;
</span><span class="noop">         &lt;assetReceiver&gt; SENDER   &lt;/assetReceiver&gt;
</span><span class="noop">         &lt;assetAmount&gt;   0        &lt;/assetAmount&gt;
</span><span class="noop">         &lt;assetCloseTo&gt;  NoTValue &lt;/assetCloseTo&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; SENDER &lt;/address&gt;
</span><span class="noop">         &lt;assetsOptedIn&gt;
</span><span class="noop">           ASSETS_OPTED_IN =&gt;
</span><span class="noop">           &lt;optInAsset&gt;
</span><span class="noop">             &lt;optInAssetID&gt;      ASSET_ID &lt;/optInAssetID&gt;
</span><span class="noop">             &lt;optInAssetBalance&gt; 0 &lt;/optInAssetBalance&gt;
</span><span class="noop">             &lt;optInAssetFrozen&gt;
</span><span class="noop">               getAssetParamsField(AssetDefaultFrozen, ASSET_ID)
</span><span class="noop">             &lt;/optInAssetFrozen&gt;
</span><span class="noop">           &lt;/optInAsset&gt;
</span><span class="noop">           ASSETS_OPTED_IN
</span><span class="noop">         &lt;/assetsOptedIn&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BALANCE =&gt; MIN_BALANCE +Int PARAM_MIN_BALANCE &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires assetCreated(ASSET_ID)
</span><span class="noop">     andBool notBool hasOptedInAsset(ASSET_ID, SENDER)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">**Asset opt-out** is a special case of asset transfer: a transfer with the AssetCloseTo field set.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #executeTxn(@axfer) =&gt; 
</span><span class="noop">                #giveAsset(ASSET_ID, SENDER, 0 -Int AMOUNT) 
</span><span class="noop">             ~&gt; #giveAsset(ASSET_ID, RECEIVER, AMOUNT) 
</span><span class="noop">             ~&gt; #closeTo(ASSET_ID, SENDER, CLOSE_TO)
</span><span class="noop">           ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID          &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;        SENDER          &lt;/sender&gt;
</span><span class="noop">         &lt;xferAsset&gt;     ASSET_ID        &lt;/xferAsset&gt;
</span><span class="noop">         &lt;assetReceiver&gt; RECEIVER        &lt;/assetReceiver&gt;
</span><span class="noop">         &lt;assetAmount&gt;   AMOUNT          &lt;/assetAmount&gt;
</span><span class="noop">         &lt;assetCloseTo&gt;  CLOSE_TO:TValue &lt;/assetCloseTo&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">* **Asset Freeze**
</span><span class="noop">
</span><span class="noop">Not supported.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; #executeTxn(@afrz) =&gt; #avmPanic(TXN_ID, UNSUPPORTED_TXN_TYPE) ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">* **Application Call**
</span><span class="noop">
</span><span class="noop">App create
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #executeTxn(@appl) =&gt; #executeAppl(APP_ID) ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;                 TXN_ID              &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;               SENDER              &lt;/sender&gt;
</span><span class="noop">         &lt;applicationID&gt;        0                   &lt;/applicationID&gt;
</span><span class="noop">         &lt;approvalProgramSrc&gt;   APPROVAL_PGM_SRC    &lt;/approvalProgramSrc&gt;
</span><span class="noop">         &lt;clearStateProgramSrc&gt; CLEAR_STATE_PGM_SRC &lt;/clearStateProgramSrc&gt;
</span><span class="noop">         &lt;approvalProgram&gt;      APPROVAL_PGM        &lt;/approvalProgram&gt;
</span><span class="noop">         &lt;clearStateProgram&gt;    CLEAR_STATE_PGM     &lt;/clearStateProgram&gt;
</span><span class="noop">         &lt;globalNui&gt;            GLOBAL_INTS         &lt;/globalNui&gt;
</span><span class="noop">         &lt;globalNbs&gt;            GLOBAL_BYTES        &lt;/globalNbs&gt;
</span><span class="noop">         &lt;localNui&gt;             LOCAL_INTS          &lt;/localNui&gt;
</span><span class="noop">         &lt;localNbs&gt;             LOCAL_BYTES         &lt;/localNbs&gt;
</span><span class="noop">         &lt;extraProgramPages&gt;    EXTRA_PAGES         &lt;/extraProgramPages&gt;
</span><span class="noop">         &lt;txApplicationID&gt;      _ =&gt; APP_ID         &lt;/txApplicationID&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;accountsMap&gt;
</span><span class="noop">         &lt;account&gt;
</span><span class="noop">           &lt;address&gt; SENDER &lt;/address&gt;
</span><span class="noop">           &lt;minBalance&gt; MIN_BALANCE =&gt; MIN_BALANCE 
</span><span class="noop">                                  +Int ((1 +Int EXTRA_PAGES) *Int PARAM_APP_PAGE_FLAT) 
</span><span class="noop">                                  +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_UINT_MIN_BALANCE) 
</span><span class="noop">                                    *Int GLOBAL_INTS)
</span><span class="noop">                                  +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_BYTES_MIN_BALANCE)
</span><span class="noop">                                    *Int GLOBAL_BYTES)
</span><span class="noop">           &lt;/minBalance&gt;
</span><span class="noop">           &lt;appsCreated&gt;
</span><span class="noop">             APPS =&gt;
</span><span class="noop">             &lt;app&gt;
</span><span class="noop">               &lt;appID&gt;            APP_ID              &lt;/appID&gt;
</span><span class="noop">               &lt;approvalPgmSrc&gt;   APPROVAL_PGM_SRC    &lt;/approvalPgmSrc&gt;
</span><span class="noop">               &lt;clearStatePgmSrc&gt; CLEAR_STATE_PGM_SRC &lt;/clearStatePgmSrc&gt;
</span><span class="noop">               &lt;approvalPgm&gt;      APPROVAL_PGM        &lt;/approvalPgm&gt;
</span><span class="noop">               &lt;clearStatePgm&gt;    CLEAR_STATE_PGM     &lt;/clearStatePgm&gt;
</span><span class="noop">               &lt;globalNumInts&gt;       GLOBAL_INTS         &lt;/globalNumInts&gt;
</span><span class="noop">               &lt;globalNumBytes&gt;      GLOBAL_BYTES        &lt;/globalNumBytes&gt;
</span><span class="noop">               &lt;localNumInts&gt;        LOCAL_INTS          &lt;/localNumInts&gt;
</span><span class="noop">               &lt;localNumBytes&gt;       LOCAL_BYTES         &lt;/localNumBytes&gt;
</span><span class="noop">               &lt;extraPages&gt;       EXTRA_PAGES         &lt;/extraPages&gt;
</span><span class="noop">               ...
</span><span class="noop">             &lt;/app&gt;
</span><span class="noop">             APPS
</span><span class="noop">           &lt;/appsCreated&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/account&gt;
</span><span class="noop">         (.Bag =&gt;
</span><span class="noop">         (&lt;account&gt;
</span><span class="noop">           &lt;address&gt; getAppAddress(APP_ID) &lt;/address&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/account&gt;))
</span><span class="noop">         ...
</span><span class="noop">       &lt;/accountsMap&gt;
</span><span class="noop">       &lt;appCreator&gt; (.Map =&gt; (APP_ID |-&gt; SENDER)) ... &lt;/appCreator&gt;
</span><span class="noop">       &lt;nextAppID&gt; APP_ID =&gt; APP_ID +Int 1 &lt;/nextAppID&gt;
</span><span class="noop">    requires notBool(APP_ID in_apps(&lt;appsCreated&gt; APPS &lt;/appsCreated&gt;))
</span><span class="noop">     andBool GLOBAL_INTS +Int GLOBAL_BYTES &lt;=Int PARAM_MAX_GLOBAL_KEYS
</span><span class="noop">     andBool LOCAL_INTS  +Int LOCAL_BYTES  &lt;=Int PARAM_MAX_LOCAL_KEYS
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #executeTxn(@appl) =&gt; #executeAppl(APP_ID) ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;                 TXN_ID              &lt;/txID&gt;
</span><span class="noop">         &lt;applicationID&gt;        APP_ID:TValue       &lt;/applicationID&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">  requires APP_ID =/=K 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">NoOp
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #executeAppl(TValue)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #executeAppl(APP_ID) =&gt; 
</span><span class="noop">               #initApp(APP_ID) 
</span><span class="noop">            ~&gt; #loadInputPgm(APPROVAL_PGM) 
</span><span class="noop">            ~&gt; #evalTeal() 
</span><span class="noop">            ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID        &lt;/txID&gt;
</span><span class="noop">         &lt;onCompletion&gt;  @ NoOp        &lt;/onCompletion&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt;          APP_ID       &lt;/appID&gt;
</span><span class="noop">         &lt;approvalPgmSrc&gt; APPROVAL_PGM &lt;/approvalPgmSrc&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">OptIn
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">
</span><span class="noop">// Case 1: user different from app creator is opting in
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #executeAppl(APP_ID) =&gt; 
</span><span class="noop">               #initApp(APP_ID) 
</span><span class="noop">            ~&gt; #loadInputPgm(APPROVAL_PGM)
</span><span class="noop">            ~&gt; #evalTeal()
</span><span class="noop">            ...
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID  &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;        SENDER  &lt;/sender&gt;
</span><span class="noop">         &lt;onCompletion&gt;  @ OptIn &lt;/onCompletion&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; SENDER &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           OPTED_IN_APPS =&gt;
</span><span class="noop">           &lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt;   APP_ID &lt;/optInAppID&gt;
</span><span class="noop">             &lt;localInts&gt; .Map   &lt;/localInts&gt;
</span><span class="noop">             &lt;localBytes&gt; .Map   &lt;/localBytes&gt;
</span><span class="noop">           &lt;/optInApp&gt;
</span><span class="noop">           OPTED_IN_APPS
</span><span class="noop">         &lt;/appsOptedIn&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BALANCE =&gt; MIN_BALANCE 
</span><span class="noop">                                +Int PARAM_APP_OPTIN_FLAT
</span><span class="noop">                                +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_UINT_MIN_BALANCE)
</span><span class="noop">                                      *Int LOCAL_INTS)
</span><span class="noop">                                +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_BYTES_MIN_BALANCE)
</span><span class="noop">                                      *Int LOCAL_BYTES)
</span><span class="noop">         &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt;          APP_ID       &lt;/appID&gt;
</span><span class="noop">         &lt;approvalPgmSrc&gt; APPROVAL_PGM &lt;/approvalPgmSrc&gt;
</span><span class="noop">         &lt;localNumInts&gt;      LOCAL_INTS   &lt;/localNumInts&gt;
</span><span class="noop">         &lt;localNumBytes&gt;     LOCAL_BYTES  &lt;/localNumBytes&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">     requires notBool hasOptedInApp(APP_ID, SENDER)
</span><span class="noop">
</span><span class="noop">// Case 2: app creator is opting in to their own app
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #executeAppl(APP_ID) =&gt; 
</span><span class="noop">               #initApp(APP_ID) 
</span><span class="noop">            ~&gt; #loadInputPgm(APPROVAL_PGM) 
</span><span class="noop">            ~&gt; #evalTeal()
</span><span class="noop">            ...
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID  &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;        SENDER  &lt;/sender&gt;
</span><span class="noop">         &lt;onCompletion&gt;  @ OptIn &lt;/onCompletion&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; SENDER &lt;/address&gt;
</span><span class="noop">         &lt;appsCreated&gt;
</span><span class="noop">           &lt;app&gt;
</span><span class="noop">             &lt;appID&gt;          APP_ID       &lt;/appID&gt;
</span><span class="noop">             &lt;approvalPgmSrc&gt; APPROVAL_PGM &lt;/approvalPgmSrc&gt;
</span><span class="noop">             &lt;localNumInts&gt;      LOCAL_INTS   &lt;/localNumInts&gt;
</span><span class="noop">             &lt;localNumBytes&gt;     LOCAL_BYTES  &lt;/localNumBytes&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/app&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/appsCreated&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           OPTED_IN_APPS =&gt;
</span><span class="noop">           &lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt;   APP_ID &lt;/optInAppID&gt;
</span><span class="noop">             &lt;localInts&gt; .Map        &lt;/localInts&gt;
</span><span class="noop">             &lt;localBytes&gt; .Map        &lt;/localBytes&gt;
</span><span class="noop">           &lt;/optInApp&gt;
</span><span class="noop">           OPTED_IN_APPS
</span><span class="noop">         &lt;/appsOptedIn&gt;
</span><span class="noop">         &lt;minBalance&gt; MIN_BALANCE =&gt; MIN_BALANCE 
</span><span class="noop">                                +Int PARAM_APP_OPTIN_FLAT 
</span><span class="noop">                                +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_UINT_MIN_BALANCE) 
</span><span class="noop">                                  *Int LOCAL_INTS)
</span><span class="noop">                                +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_BYTES_MIN_BALANCE) 
</span><span class="noop">                                  *Int LOCAL_BYTES)
</span><span class="noop">         &lt;/minBalance&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">     requires notBool hasOptedInApp(APP_ID, SENDER)
</span><span class="noop">
</span><span class="noop">// Case 3: needed because of bug?
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #executeAppl(APP_ID) =&gt; 
</span><span class="noop">               #initApp(APP_ID) 
</span><span class="noop">            ~&gt; #loadInputPgm(APPROVAL_PGM) 
</span><span class="noop">            ~&gt; #evalTeal()
</span><span class="noop">            ...
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID  &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;        SENDER  &lt;/sender&gt;
</span><span class="noop">         &lt;onCompletion&gt;  @ OptIn &lt;/onCompletion&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">         &lt;accountsMap&gt;
</span><span class="noop">         &lt;account&gt;
</span><span class="noop">           &lt;address&gt; SENDER &lt;/address&gt;
</span><span class="noop">           &lt;appsCreated&gt;
</span><span class="noop">             &lt;app&gt;
</span><span class="noop">               &lt;appID&gt;          APP_ID       &lt;/appID&gt;
</span><span class="noop">               &lt;approvalPgmSrc&gt; APPROVAL_PGM &lt;/approvalPgmSrc&gt;
</span><span class="noop">               &lt;localNumInts&gt;      LOCAL_INTS   &lt;/localNumInts&gt;
</span><span class="noop">               &lt;localNumBytes&gt;     LOCAL_BYTES  &lt;/localNumBytes&gt;
</span><span class="noop">               ...
</span><span class="noop">             &lt;/app&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/appsCreated&gt;
</span><span class="noop">           &lt;appsOptedIn&gt;
</span><span class="noop">             OPTED_IN_APPS =&gt;
</span><span class="noop">             &lt;optInApp&gt;
</span><span class="noop">               &lt;optInAppID&gt;   APP_ID &lt;/optInAppID&gt;
</span><span class="noop">               &lt;localInts&gt; .Map   &lt;/localInts&gt;
</span><span class="noop">               &lt;localBytes&gt; .Map   &lt;/localBytes&gt;
</span><span class="noop">             &lt;/optInApp&gt;
</span><span class="noop">             OPTED_IN_APPS
</span><span class="noop">           &lt;/appsOptedIn&gt;
</span><span class="noop">           &lt;minBalance&gt; MIN_BALANCE =&gt; MIN_BALANCE 
</span><span class="noop">                                  +Int PARAM_APP_OPTIN_FLAT 
</span><span class="noop">                                  +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_UINT_MIN_BALANCE) 
</span><span class="noop">                                    *Int LOCAL_INTS)
</span><span class="noop">                                  +Int ((PARAM_MIN_BALANCE_PER_ENTRY +Int PARAM_BYTES_MIN_BALANCE) 
</span><span class="noop">                                    *Int LOCAL_BYTES)
</span><span class="noop">           &lt;/minBalance&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/account&gt;
</span><span class="noop">       &lt;/accountsMap&gt;
</span><span class="noop">     requires notBool hasOptedInApp(APP_ID, SENDER)
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">CloseOut
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt;
</span><span class="noop">         #executeAppl(APP_ID) =&gt; 
</span><span class="noop">              #initApp(APP_ID)
</span><span class="noop">           ~&gt; #loadInputPgm(APPROVAL_PGM)
</span><span class="noop">           ~&gt; #evalTeal() 
</span><span class="noop">           ~&gt; #clearState(APP_ID, SENDER)
</span><span class="noop">         ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID        &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;        SENDER        &lt;/sender&gt;
</span><span class="noop">         &lt;onCompletion&gt;  @ CloseOut    &lt;/onCompletion&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt;          APP_ID       &lt;/appID&gt;
</span><span class="noop">         &lt;approvalPgmSrc&gt; APPROVAL_PGM &lt;/approvalPgmSrc&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">ClearState
</span><span class="noop">
</span><span class="noop">TODO make sure `#clearState` runs even when a panic is generated
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt;
</span><span class="noop">         #executeAppl(APP_ID) =&gt; 
</span><span class="noop">              #initApp(APP_ID)
</span><span class="noop">           ~&gt; #loadInputPgm(CLEAR_STATE_PGM)
</span><span class="noop">           ~&gt; #evalTeal() 
</span><span class="noop">           ~&gt; #clearState(APP_ID, SENDER)
</span><span class="noop">         ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID        &lt;/txID&gt;
</span><span class="noop">         &lt;sender&gt;        SENDER        &lt;/sender&gt;
</span><span class="noop">         &lt;onCompletion&gt; @ ClearState   &lt;/onCompletion&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt;            APP_ID          &lt;/appID&gt;
</span><span class="noop">         &lt;clearStatePgmSrc&gt; CLEAR_STATE_PGM &lt;/clearStatePgmSrc&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">UpdateApplication
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt;
</span><span class="noop">         #executeAppl(APP_ID) =&gt; 
</span><span class="noop">              #initApp(APP_ID)
</span><span class="noop">           ~&gt; #loadInputPgm(APPROVAL_PGM)
</span><span class="noop">           ~&gt; #evalTeal() 
</span><span class="noop">           ~&gt; #updatePrograms(APP_ID, NEW_APPROVAL_PGM, NEW_CLEAR_STATE_PGM)
</span><span class="noop">         ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;                 TXN_ID              &lt;/txID&gt;
</span><span class="noop">         &lt;onCompletion&gt;         @ UpdateApplication &lt;/onCompletion&gt;
</span><span class="noop">         &lt;approvalProgramSrc&gt;   NEW_APPROVAL_PGM    &lt;/approvalProgramSrc&gt;
</span><span class="noop">         &lt;clearStateProgramSrc&gt; NEW_CLEAR_STATE_PGM &lt;/clearStateProgramSrc&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt;          APP_ID       &lt;/appID&gt;
</span><span class="noop">         &lt;approvalPgmSrc&gt; APPROVAL_PGM &lt;/approvalPgmSrc&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">DeleteApplication
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt;
</span><span class="noop">         #executeAppl(APP_ID) =&gt; 
</span><span class="noop">              #initApp(APP_ID)
</span><span class="noop">           ~&gt; #loadInputPgm(APPROVAL_PGM)
</span><span class="noop">           ~&gt; #evalTeal() 
</span><span class="noop">           ~&gt; #deleteApplication(APP_ID)
</span><span class="noop">         ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt;          TXN_ID              &lt;/txID&gt;
</span><span class="noop">         &lt;onCompletion&gt;  @ DeleteApplication &lt;/onCompletion&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt;          APP_ID       &lt;/appID&gt;
</span><span class="noop">         &lt;approvalPgmSrc&gt; APPROVAL_PGM &lt;/approvalPgmSrc&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">       &lt;appCreator&gt; (APP_ID |-&gt; _) =&gt; .Map ... &lt;/appCreator&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">* **Layer-2 transactions**
</span><span class="noop">
</span><span class="noop">Not supported.
</span><span class="noop">TODO: determine if we need to support them an all.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; #executeTxn(@ccfg) =&gt; #avmPanic(TXN_ID, UNSUPPORTED_TXN_TYPE) ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #executeTxn(@ccall) =&gt; #avmPanic(TXN_ID, UNSUPPORTED_TXN_TYPE) ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #executeTxn(@cfx) =&gt; #avmPanic(TXN_ID, UNSUPPORTED_TXN_TYPE) ... &lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">* **Future transaction types**
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/avm-initialization.md">avm/avm-initialization.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">```k
</span><span class="noop">requires &#34;avm/blockchain.md&#34;
</span><span class="noop">requires &#34;avm/avm-configuration.md&#34;
</span><span class="noop">
</span><span class="noop">module AVM-INITIALIZATION
</span><span class="noop">  imports INT
</span><span class="noop">  imports LIST
</span><span class="noop">  imports STRING
</span><span class="noop">  imports BYTES
</span><span class="noop">  imports ALGO-BLOCKCHAIN
</span><span class="noop">  imports AVM-CONFIGURATION
</span><span class="noop">  imports AVM-TXN-DEQUE
</span><span class="noop">  imports TEAL-CONSTANTS
</span><span class="noop">  imports ALGO-TXN
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">This module contains the rules that will initialize AVM with the Algorand blockchain state
</span><span class="noop">and the supplied transaction group.
</span><span class="noop">
</span><span class="noop">AVM Initialization
</span><span class="noop">------------------
</span><span class="noop">
</span><span class="noop">Initialize the network state with *concrete* test data.
</span><span class="noop">The ordered in which these rules are applied matters! Details TBD.
</span><span class="noop">TODO: provide a default safe order.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #initTxGroup()
</span><span class="noop">                           | #initGlobals()
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">The transaction is initialized first.
</span><span class="noop">
</span><span class="noop">### Transaction Group Initialization
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #initTxGroup() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Transactions
</span><span class="noop">
</span><span class="noop">By convention, we initialise the `&lt;groupIdx&gt;` cell, which tracks the transaction&#39;s position
</span><span class="noop">withing the group, with it&#39;s `&lt;txID&gt;`. Transaction IDs will be assigned sequentially.
</span><span class="noop">
</span><span class="noop">**TODO**: transaction IDs and group indices need be assigned differently for real blockchain transactions.
</span><span class="noop">
</span><span class="noop">#### Payment Transaction
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= &#34;addPaymentTx&#34; SenderCell ReceiverCell AmountCell
</span><span class="noop">  //-----------------------------------------------------------------------------------
</span><span class="hit">  rule &lt;k&gt; addPaymentTx &lt;sender&gt;   SENDER   &lt;/sender&gt;
</span><span class="noop">                        &lt;receiver&gt; RECEIVER &lt;/receiver&gt;
</span><span class="noop">                        &lt;amount&gt;   AMOUNT   &lt;/amount&gt;
</span><span class="noop">       =&gt; #pushTxnBack(&lt;txID&gt; Int2String(ID) &lt;/txID&gt;)
</span><span class="noop">           ...
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;transactions&gt;
</span><span class="noop">         TXNS =&gt;
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           &lt;txID&gt; Int2String(ID) &lt;/txID&gt;
</span><span class="noop">           &lt;txHeader&gt;
</span><span class="noop">             &lt;sender&gt;      SENDER   &lt;/sender&gt;
</span><span class="noop">             &lt;txType&gt;      &#34;pay&#34;    &lt;/txType&gt;
</span><span class="noop">             &lt;typeEnum&gt;    @ pay    &lt;/typeEnum&gt;
</span><span class="noop">             &lt;groupID&gt;     Int2String(GROUP_ID) &lt;/groupID&gt;
</span><span class="noop">             &lt;groupIdx&gt;    groupSize(Int2String(GROUP_ID), &lt;transactions&gt; TXNS &lt;/transactions&gt;) &lt;/groupIdx&gt;    // for testing, we make these the same as sequential TxIDs
</span><span class="noop">             ...                              // other fields will receive default values
</span><span class="noop">           &lt;/txHeader&gt;
</span><span class="noop">           &lt;payTxFields&gt;
</span><span class="noop">             &lt;receiver&gt;         RECEIVER &lt;/receiver&gt;
</span><span class="noop">             &lt;amount&gt;           AMOUNT &lt;/amount&gt;
</span><span class="noop">             &lt;closeRemainderTo&gt; .Bytes &lt;/closeRemainderTo&gt;
</span><span class="noop">           &lt;/payTxFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;
</span><span class="noop">         TXNS
</span><span class="noop">       &lt;/transactions&gt;
</span><span class="noop">       &lt;nextGroupID&gt; GROUP_ID &lt;/nextGroupID&gt;
</span><span class="noop">       &lt;nextTxnID&gt; ID =&gt; ID +Int 1 &lt;/nextTxnID&gt;
</span><span class="noop">       requires notBool (Int2String(ID) in_txns(&lt;transactions&gt; TXNS &lt;/transactions&gt;))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Application Call Transaction
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= &#34;addAppCallTx&#34; SenderCell ApplicationIDCell
</span><span class="noop">                                            OnCompletionCell AccountsCell
</span><span class="noop">                                            ApplicationArgsCell ForeignAppsCell 
</span><span class="noop">                                            ForeignAssetsCell
</span><span class="noop">                                            GlobalNuiCell GlobalNbsCell
</span><span class="noop">                                            LocalNuiCell LocalNbsCell
</span><span class="noop">                                            ExtraProgramPagesCell
</span><span class="noop">                                            &#34;&lt;approvalPgmIdx&gt;&#34; Int &#34;&lt;/approvalPgmIdx&gt;&#34;
</span><span class="noop">                                            &#34;&lt;clearStatePgmIdx&gt;&#34; Int &#34;&lt;/clearStatePgmIdx&gt;&#34;
</span><span class="noop">  //-----------------------------------------------------------
</span><span class="hit">  rule &lt;k&gt; addAppCallTx &lt;sender&gt;            SENDER          &lt;/sender&gt;
</span><span class="noop">                        &lt;applicationID&gt;     APP_ID          &lt;/applicationID&gt;
</span><span class="noop">                        &lt;onCompletion&gt;      ON_COMPLETION   &lt;/onCompletion&gt;
</span><span class="noop">                        &lt;accounts&gt;          ACCOUNTS        &lt;/accounts&gt;
</span><span class="noop">                        &lt;applicationArgs&gt;   ARGS            &lt;/applicationArgs&gt;
</span><span class="noop">                        &lt;foreignApps&gt;       APPS            &lt;/foreignApps&gt;
</span><span class="noop">                        &lt;foreignAssets&gt;     ASSETS          &lt;/foreignAssets&gt;
</span><span class="noop">                        &lt;globalNui&gt;         GLOBAL_INTS     &lt;/globalNui&gt;
</span><span class="noop">                        &lt;globalNbs&gt;         GLOBAL_BYTES    &lt;/globalNbs&gt;
</span><span class="noop">                        &lt;localNui&gt;          LOCAL_INTS      &lt;/localNui&gt;
</span><span class="noop">                        &lt;localNbs&gt;          LOCAL_BYTES     &lt;/localNbs&gt;
</span><span class="noop">                        &lt;extraProgramPages&gt; EXTRA_PAGES     &lt;/extraProgramPages&gt;
</span><span class="noop">                        &lt;approvalPgmIdx&gt;    APPROVAL_IDX    &lt;/approvalPgmIdx&gt;
</span><span class="noop">                        &lt;clearStatePgmIdx&gt;  CLEAR_STATE_IDX &lt;/clearStatePgmIdx&gt;
</span><span class="noop">       =&gt; #pushTxnBack(&lt;txID&gt; Int2String(ID) &lt;/txID&gt;)
</span><span class="noop">           ...
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;transactions&gt;
</span><span class="noop">         TXNS =&gt;
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           &lt;txID&gt; Int2String(ID) &lt;/txID&gt;
</span><span class="noop">           &lt;txHeader&gt;
</span><span class="noop">             &lt;sender&gt;   SENDER   &lt;/sender&gt;
</span><span class="noop">             &lt;txType&gt;   &#34;appl&#34;   &lt;/txType&gt;
</span><span class="noop">             &lt;typeEnum&gt; @ appl   &lt;/typeEnum&gt;
</span><span class="noop">             &lt;groupID&gt;  Int2String(GROUP_ID) &lt;/groupID&gt;
</span><span class="noop">             &lt;groupIdx&gt; groupSize(Int2String(GROUP_ID), &lt;transactions&gt; TXNS &lt;/transactions&gt;) &lt;/groupIdx&gt; // for testing, we make these the same as sequential TxIDs
</span><span class="noop">             ...                           // other fields will receive default values
</span><span class="noop">           &lt;/txHeader&gt;
</span><span class="noop">           &lt;appCallTxFields&gt;
</span><span class="noop">             &lt;applicationID&gt;        APP_ID               &lt;/applicationID&gt;
</span><span class="noop">             &lt;onCompletion&gt;         ON_COMPLETION        &lt;/onCompletion&gt;
</span><span class="noop">             &lt;accounts&gt;             ACCOUNTS             &lt;/accounts&gt;
</span><span class="noop">             &lt;applicationArgs&gt;      convertToBytes(ARGS) &lt;/applicationArgs&gt;
</span><span class="noop">             &lt;foreignApps&gt;          APPS                 &lt;/foreignApps&gt;
</span><span class="noop">             &lt;foreignAssets&gt;        ASSETS               &lt;/foreignAssets&gt;
</span><span class="noop">             &lt;globalNui&gt;            GLOBAL_INTS          &lt;/globalNui&gt;
</span><span class="noop">             &lt;globalNbs&gt;            GLOBAL_BYTES         &lt;/globalNbs&gt;
</span><span class="noop">             &lt;localNui&gt;             LOCAL_INTS           &lt;/localNui&gt;
</span><span class="noop">             &lt;localNbs&gt;             LOCAL_BYTES          &lt;/localNbs&gt;
</span><span class="noop">             &lt;extraProgramPages&gt;    EXTRA_PAGES          &lt;/extraProgramPages&gt;
</span><span class="noop">             &lt;approvalProgramSrc&gt;   getTealByIndex(TEAL_PGMS_LIST, APPROVAL_IDX)    &lt;/approvalProgramSrc&gt;
</span><span class="noop">             &lt;clearStateProgramSrc&gt; getTealByIndex(TEAL_PGMS_LIST, CLEAR_STATE_IDX) &lt;/clearStateProgramSrc&gt;
</span><span class="noop">             ...                            // other fields will receive default values
</span><span class="noop">           &lt;/appCallTxFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;
</span><span class="noop">         TXNS
</span><span class="noop">       &lt;/transactions&gt;
</span><span class="noop">       &lt;nextGroupID&gt; GROUP_ID &lt;/nextGroupID&gt;
</span><span class="noop">       &lt;nextTxnID&gt; ID =&gt; ID +Int 1 &lt;/nextTxnID&gt;
</span><span class="noop">       &lt;tealPrograms&gt; TEAL_PGMS_LIST &lt;/tealPrograms&gt;
</span><span class="noop">       requires notBool (Int2String(ID) in_txns(&lt;transactions&gt; TXNS &lt;/transactions&gt;))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Globals Initialization
</span><span class="noop">
</span><span class="noop">To now the group size, we need to count the transactions in the group:
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Int ::= countTxns(TransactionsCell) [function, functional]
</span><span class="noop">  // ---------------------------------------------------------------
</span><span class="noop">
</span><span class="hit">  rule countTxns(&lt;transactions&gt; &lt;transaction&gt; _ &lt;/transaction&gt; REST &lt;/transactions&gt;)
</span><span class="noop">       =&gt; 1 +Int countTxns(&lt;transactions&gt; REST &lt;/transactions&gt;)
</span><span class="hit">  rule countTxns(&lt;transactions&gt; .Bag &lt;/transactions&gt;)
</span><span class="noop">       =&gt; 0
</span><span class="noop">
</span><span class="noop">  syntax Int ::= countTxnsInGroup(TransactionsCell, String) [function, functional]
</span><span class="noop">  // --------------------------------------------------------------------------
</span><span class="noop">
</span><span class="hit">  rule countTxnsInGroup(&lt;transactions&gt; &lt;transaction&gt; &lt;groupID&gt; GROUP &lt;/groupID&gt; ... &lt;/transaction&gt; REST &lt;/transactions&gt;, GROUP)
</span><span class="noop">       =&gt; 1 +Int countTxnsInGroup(&lt;transactions&gt; REST &lt;/transactions&gt;, GROUP)
</span><span class="hit">  rule countTxnsInGroup(&lt;transactions&gt; &lt;transaction&gt; &lt;groupID&gt; GROUP&#39; &lt;/groupID&gt; ... &lt;/transaction&gt; REST &lt;/transactions&gt;, GROUP)
</span><span class="noop">       =&gt; countTxnsInGroup(&lt;transactions&gt; REST &lt;/transactions&gt;, GROUP)
</span><span class="noop">    requires GROUP&#39; =/=K GROUP
</span><span class="hit">  rule countTxnsInGroup(&lt;transactions&gt; .Bag &lt;/transactions&gt;, _)
</span><span class="noop">       =&gt; 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">The semantics does not currently care about block production, therefore the `&lt;globalRound&gt; `
</span><span class="noop">and ` &lt;latestTimestamp&gt;` are initialized with somewhat arbitrary values.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #initGlobals() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;globals&gt;
</span><span class="noop">         &lt;groupSize&gt;            _ =&gt; countTxns(&lt;transactions&gt; TXNS &lt;/transactions&gt;) &lt;/groupSize&gt;
</span><span class="noop">         &lt;globalRound&gt;          _ =&gt; 6 &lt;/globalRound&gt;
</span><span class="noop">         &lt;latestTimestamp&gt;      _ =&gt; 50  &lt;/latestTimestamp&gt;
</span><span class="noop">         &lt;currentApplicationID&gt; _ =&gt; 0 &lt;/currentApplicationID&gt;
</span><span class="noop">         &lt;currentApplicationAddress&gt; _ =&gt; .Bytes &lt;/currentApplicationAddress&gt;
</span><span class="noop">       &lt;/globals&gt;
</span><span class="noop">       &lt;transactions&gt; TXNS &lt;/transactions&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Blockchain Initialization
</span><span class="noop">
</span><span class="noop">The Algorand network state comprises accounts, apps (smart contracts) and assets.
</span><span class="noop">In the configuration, we store the apps&#39; and assets&#39; data in the account of their creator;
</span><span class="noop">hence we initialize the accounts first, leaving their created and opted-in apps and assets empty,
</span><span class="noop">and then initialize them with separate rules.
</span><span class="noop">
</span><span class="noop">#### Accounts Initialization
</span><span class="noop">
</span><span class="noop">We do not currently model rewards, hence we initilize the network participation-related cells with arbitrary values.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= &#34;addAccount&#34; AddressCell BalanceCell
</span><span class="noop">  //--------------------------------------------------------
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; addAccount &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">                      &lt;balance&gt; BALANCE &lt;/balance&gt;
</span><span class="noop">       =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;accountsMap&gt;
</span><span class="noop">         ACCOUNTS =&gt;
</span><span class="noop">         &lt;account&gt;
</span><span class="noop">           &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">           &lt;balance&gt; BALANCE    &lt;/balance&gt;
</span><span class="noop">           &lt;key&gt; ADDR &lt;/key&gt;
</span><span class="noop">           &lt;appsCreated&gt; .Bag &lt;/appsCreated&gt;
</span><span class="noop">           &lt;appsOptedIn&gt; .Bag &lt;/appsOptedIn&gt;
</span><span class="noop">           &lt;assetsCreated&gt; .Bag &lt;/assetsCreated&gt;
</span><span class="noop">           &lt;assetsOptedIn&gt; .Bag &lt;/assetsOptedIn&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/account&gt;
</span><span class="noop">         ACCOUNTS
</span><span class="noop">       &lt;/accountsMap&gt;
</span><span class="noop">      requires notBool (ADDR in_accounts(&lt;accountsMap&gt; ACCOUNTS &lt;/accountsMap&gt;))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Apps Initialization
</span><span class="noop">
</span><span class="noop">The app initialization rules must be used *after* initializing accounts.
</span><span class="noop">TODO: initialize an account for the app to receive/send funds.
</span><span class="noop">      the address should be derived from AppID as in https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/#using-a-smart-contract-as-an-escrow
</span><span class="noop">
</span><span class="noop">```python
</span><span class="noop"># app ID of 1’s address
</span><span class="noop">python3 -c &#34;import algosdk.encoding as e; print(e.encode_address(e.checksum(b&#39;appID&#39;+(1).to_bytes(8, &#39;big&#39;))))&#34;
</span><span class="noop">WCS6TVPJRBSARHLN2326LRU5BYVJZUKI2VJ53CAWKYYHDE455ZGKANWMGM
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Assets Initialization
</span><span class="noop">
</span><span class="noop">The asset initialization rule must be used *after* initializing accounts.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= &#34;addAssetConfigTx&#34; SenderCell ConfigAssetCell ConfigTotalCell
</span><span class="noop">                                                ConfigDecimalsCell ConfigDefaultFrozenCell ConfigUnitNameCell
</span><span class="noop">                                                ConfigAssetNameCell ConfigAssetURLCell ConfigMetaDataHashCell
</span><span class="noop">                                                ConfigManagerAddrCell ConfigReserveAddrCell
</span><span class="noop">                                                ConfigFreezeAddrCell ConfigClawbackAddrCell
</span><span class="noop">  //-----------------------------------------------------------
</span><span class="hit">  rule &lt;k&gt; addAssetConfigTx &lt;sender&gt;              SENDER        &lt;/sender&gt;
</span><span class="noop">                            &lt;configAsset&gt;         ASSET_ID      &lt;/configAsset&gt;
</span><span class="noop">                            &lt;configTotal&gt;         TOTAL         &lt;/configTotal&gt;
</span><span class="noop">                            &lt;configDecimals&gt;      DECIMALS      &lt;/configDecimals&gt;
</span><span class="noop">                            &lt;configDefaultFrozen&gt; FROZEN        &lt;/configDefaultFrozen&gt;
</span><span class="noop">                            &lt;configUnitName&gt;      UNIT_NAME     &lt;/configUnitName&gt;
</span><span class="noop">                            &lt;configAssetName&gt;     NAME          &lt;/configAssetName&gt;
</span><span class="noop">                            &lt;configAssetURL&gt;      ASSET_URL     &lt;/configAssetURL&gt;
</span><span class="noop">                            &lt;configMetaDataHash&gt;  METADATA_HASH &lt;/configMetaDataHash&gt;
</span><span class="noop">                            &lt;configManagerAddr&gt;   MGR_ADDR      &lt;/configManagerAddr&gt;
</span><span class="noop">                            &lt;configReserveAddr&gt;   RES_ADDR      &lt;/configReserveAddr&gt;
</span><span class="noop">                            &lt;configFreezeAddr&gt;    FRZ_ADDR      &lt;/configFreezeAddr&gt;
</span><span class="noop">                            &lt;configClawbackAddr&gt;  CLB_ADDR      &lt;/configClawbackAddr&gt;
</span><span class="noop">       =&gt; #pushTxnBack(&lt;txID&gt; Int2String(TXN_ID) &lt;/txID&gt;)
</span><span class="noop">           ...
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;transactions&gt;
</span><span class="noop">         TXNS =&gt;
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           &lt;txID&gt; Int2String(TXN_ID) &lt;/txID&gt;
</span><span class="noop">           &lt;txHeader&gt;
</span><span class="noop">             &lt;sender&gt;      SENDER   &lt;/sender&gt;
</span><span class="noop">             &lt;txType&gt;      &#34;acfg&#34;   &lt;/txType&gt;
</span><span class="noop">             &lt;typeEnum&gt;    @ acfg   &lt;/typeEnum&gt;
</span><span class="noop">             &lt;groupID&gt;     Int2String(GROUP_ID) &lt;/groupID&gt;
</span><span class="noop">             &lt;groupIdx&gt;    groupSize(Int2String(GROUP_ID), &lt;transactions&gt; TXNS &lt;/transactions&gt;) &lt;/groupIdx&gt; // for testing, we make these the same as sequential TxIDs
</span><span class="noop">             ...                           // other fields will receive default values
</span><span class="noop">           &lt;/txHeader&gt;
</span><span class="noop">           &lt;assetConfigTxFields&gt;
</span><span class="noop">             &lt;configAsset&gt; ASSET_ID &lt;/configAsset&gt;           // the asset ID
</span><span class="noop">             &lt;assetParams&gt;
</span><span class="noop">               &lt;configTotal&gt;         TOTAL         &lt;/configTotal&gt;
</span><span class="noop">               &lt;configDecimals&gt;      DECIMALS      &lt;/configDecimals&gt;
</span><span class="noop">               &lt;configDefaultFrozen&gt; FROZEN        &lt;/configDefaultFrozen&gt;
</span><span class="noop">               &lt;configUnitName&gt;      UNIT_NAME     &lt;/configUnitName&gt;
</span><span class="noop">               &lt;configAssetName&gt;     NAME          &lt;/configAssetName&gt;
</span><span class="noop">               &lt;configAssetURL&gt;      ASSET_URL     &lt;/configAssetURL&gt;
</span><span class="noop">               &lt;configManagerAddr&gt;   MGR_ADDR      &lt;/configManagerAddr&gt;
</span><span class="noop">               &lt;configMetaDataHash&gt;  METADATA_HASH &lt;/configMetaDataHash&gt;
</span><span class="noop">               &lt;configReserveAddr&gt;   RES_ADDR      &lt;/configReserveAddr&gt;
</span><span class="noop">               &lt;configFreezeAddr&gt;    FRZ_ADDR      &lt;/configFreezeAddr&gt;
</span><span class="noop">               &lt;configClawbackAddr&gt;  CLB_ADDR      &lt;/configClawbackAddr&gt;
</span><span class="noop">             &lt;/assetParams&gt;
</span><span class="noop">           &lt;/assetConfigTxFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;
</span><span class="noop">         TXNS
</span><span class="noop">       &lt;/transactions&gt;
</span><span class="noop">       &lt;nextGroupID&gt; GROUP_ID &lt;/nextGroupID&gt;
</span><span class="noop">       &lt;nextTxnID&gt; TXN_ID =&gt; TXN_ID +Int 1 &lt;/nextTxnID&gt;
</span><span class="noop">       requires notBool (Int2String(TXN_ID) in_txns(&lt;transactions&gt; TXNS &lt;/transactions&gt;))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Asset transfer
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= &#34;addAssetTransferTx&#34; SenderCell XferAssetCell AssetAmountCell
</span><span class="noop">                                                  AssetASenderCell AssetReceiverCell AssetCloseToCell
</span><span class="noop">  //-----------------------------------------------------------------------------------------------
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; addAssetTransferTx &lt;sender&gt;        SENDER        &lt;/sender&gt;
</span><span class="noop">                              &lt;xferAsset&gt;     ASSET_ID      &lt;/xferAsset&gt;
</span><span class="noop">                              &lt;assetAmount&gt;   AMOUNT        &lt;/assetAmount&gt;
</span><span class="noop">                              &lt;assetASender&gt;  CLAWBACK_FROM &lt;/assetASender&gt;
</span><span class="noop">                              &lt;assetReceiver&gt; RECEIVER      &lt;/assetReceiver&gt;
</span><span class="noop">                              &lt;assetCloseTo&gt;  CLOSE_TO      &lt;/assetCloseTo&gt;
</span><span class="noop">           =&gt; #pushTxnBack(&lt;txID&gt; Int2String(TXN_ID) &lt;/txID&gt;)
</span><span class="noop">           ...
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;transactions&gt;
</span><span class="noop">         TXNS =&gt;
</span><span class="noop">         &lt;transaction&gt;
</span><span class="noop">           &lt;txID&gt; Int2String(TXN_ID) &lt;/txID&gt;
</span><span class="noop">           &lt;txHeader&gt;
</span><span class="noop">             &lt;sender&gt;   SENDER   &lt;/sender&gt;
</span><span class="noop">             &lt;txType&gt;   &#34;axfer&#34;  &lt;/txType&gt;
</span><span class="noop">             &lt;typeEnum&gt; @ axfer  &lt;/typeEnum&gt;
</span><span class="noop">             &lt;groupID&gt;  Int2String(GROUP_ID) &lt;/groupID&gt;
</span><span class="noop">             &lt;groupIdx&gt; groupSize(Int2String(GROUP_ID), &lt;transactions&gt; TXNS &lt;/transactions&gt;) &lt;/groupIdx&gt; // for testing, we make these the same as sequential TxIDs
</span><span class="noop">             ...                         // other fields will receive default values
</span><span class="noop">           &lt;/txHeader&gt;
</span><span class="noop">           &lt;assetTransferTxFields&gt;
</span><span class="noop">             &lt;xferAsset&gt;     ASSET_ID      &lt;/xferAsset&gt;
</span><span class="noop">             &lt;assetAmount&gt;   AMOUNT        &lt;/assetAmount&gt;
</span><span class="noop">             &lt;assetASender&gt;  CLAWBACK_FROM &lt;/assetASender&gt;
</span><span class="noop">             &lt;assetReceiver&gt; RECEIVER      &lt;/assetReceiver&gt;
</span><span class="noop">             &lt;assetCloseTo&gt;  CLOSE_TO      &lt;/assetCloseTo&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/assetTransferTxFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;
</span><span class="noop">         TXNS
</span><span class="noop">       &lt;/transactions&gt;
</span><span class="noop">       &lt;nextGroupID&gt; GROUP_ID &lt;/nextGroupID&gt;
</span><span class="noop">       &lt;nextTxnID&gt; TXN_ID =&gt; TXN_ID +Int 1 &lt;/nextTxnID&gt;
</span><span class="noop">       requires notBool (Int2String(TXN_ID) in_txns(&lt;transactions&gt; TXNS &lt;/transactions&gt;))
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Teal Programs Declaration
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= &#34;declareTealSource&#34; String
</span><span class="noop">  //------------------------------------------------
</span><span class="hit">  rule &lt;k&gt; declareTealSource _ =&gt; .K ... &lt;/k&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Transaction Index Initialization
</span><span class="noop">
</span><span class="noop">Traverse the `&lt;transactions&gt;` cell and index the relation of group ids with transaction ids
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax AlgorandCommand ::= #initTxnIndexMap()
</span><span class="noop">  //-------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #initTxnIndexMap() =&gt; #initTxnIndexMap(collectTxnIds(&lt;transactions&gt; TXNS &lt;/transactions&gt;)) ... &lt;/k&gt;
</span><span class="noop">       &lt;transactions&gt; TXNS &lt;/transactions&gt;
</span><span class="noop">
</span><span class="noop">  syntax AlgorandCommand ::= #initTxnIndexMap(List)
</span><span class="noop">  //-----------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #initTxnIndexMap(ListItem(TXN_ID) REST) =&gt; #initTxnIndexMap(ListItem(TXN_ID) REST) ... &lt;/k&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TXN_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;txnIndexMap&gt;
</span><span class="noop">          ITEMS =&gt;
</span><span class="noop">          &lt;txnIndexMapGroup&gt;
</span><span class="noop">            &lt;txnIndexMapGroupKey&gt; GROUP_ID &lt;/txnIndexMapGroupKey&gt;
</span><span class="noop">            &lt;txnIndexMapGroupValues&gt; .Map &lt;/txnIndexMapGroupValues&gt;
</span><span class="noop">          &lt;/txnIndexMapGroup&gt;
</span><span class="noop">          ITEMS
</span><span class="noop">       &lt;/txnIndexMap&gt;
</span><span class="noop">    requires notBool (group_id_in_index_map(GROUP_ID))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #initTxnIndexMap(ListItem(TXN_ID) REST) =&gt; #initTxnIndexMap(REST) ... &lt;/k&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TXN_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">         &lt;groupIdx&gt; GROUP_IDX &lt;/groupIdx&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;txnIndexMap&gt;
</span><span class="noop">          &lt;txnIndexMapGroup&gt;
</span><span class="noop">            &lt;txnIndexMapGroupKey&gt; GROUP_ID &lt;/txnIndexMapGroupKey&gt;
</span><span class="noop">            &lt;txnIndexMapGroupValues&gt; VALUES =&gt; VALUES[GROUP_IDX &lt;- TXN_ID] &lt;/txnIndexMapGroupValues&gt;
</span><span class="noop">          &lt;/txnIndexMapGroup&gt;
</span><span class="noop">          ...
</span><span class="noop">       &lt;/txnIndexMap&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #initTxnIndexMap(.List) =&gt; .K ... &lt;/k&gt;
</span><span class="noop">
</span><span class="noop">  syntax List ::= collectTxnIds(TransactionsCell) [function, functional]
</span><span class="noop">  //--------------------------------------------------------------------
</span><span class="hit">  rule collectTxnIds(&lt;transactions&gt; .Bag &lt;/transactions&gt;) =&gt; .List
</span><span class="hit">  rule collectTxnIds(&lt;transactions&gt; &lt;transaction&gt; &lt;txID&gt; TXN_ID &lt;/txID&gt; ... &lt;/transaction&gt; TXNS &lt;/transactions&gt;)
</span><span class="noop">    =&gt; ListItem(TXN_ID) collectTxnIds(&lt;transactions&gt; TXNS &lt;/transactions&gt;)
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= &#34;group_id_in_index_map&#34; &#34;(&#34; String &#34;)&#34; [function, functional]
</span><span class="noop">  //---------------------------------------------------------------------------
</span><span class="hit">  rule [[ group_id_in_index_map(GROUP_ID) =&gt; true ]]
</span><span class="noop">       &lt;txnIndexMapGroupKey&gt; GROUP_ID &lt;/txnIndexMapGroupKey&gt;
</span><span class="hit">  rule group_id_in_index_map(_GROUP_ID) =&gt; false [owise]
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/avm-limits.md">avm/avm-limits.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">```k
</span><span class="noop">requires &#34;avm/teal/teal-syntax.md&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">AVM Limits
</span><span class="noop">===========
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module AVM-LIMITS
</span><span class="noop">  imports TEAL-SYNTAX
</span><span class="noop">
</span><span class="noop">  // Size limits
</span><span class="noop">  syntax Int ::= &#34;MAX_STACK_DEPTH&#34;     [macro]
</span><span class="noop">  syntax Int ::= &#34;MAX_CALLSTACK_DEPTH&#34; [macro]
</span><span class="noop">  syntax Int ::= &#34;MAX_SCRATCH_SIZE&#34;    [macro]
</span><span class="noop">  syntax Int ::= &#34;LogicSigMaxSize&#34;     [macro]
</span><span class="noop">  syntax Int ::= &#34;LogicSigMaxCost&#34;     [macro]
</span><span class="noop">  syntax Int ::= &#34;MaxAppProgramLen&#34;    [macro]
</span><span class="noop">  syntax Int ::= &#34;MaxAppProgramCost&#34;   [macro]
</span><span class="noop">  syntax Int ::= &#34;MAX_BYTEARRAY_LEN&#34;   [macro]
</span><span class="noop">  syntax Int ::= &#34;MAX_BYTE_MATH_SIZE&#34;  [macro]
</span><span class="noop">  syntax Int ::= &#34;MaxTxGroupSize&#34;      [macro]
</span><span class="noop">  // -----------------------------------------
</span><span class="hit">  rule MAX_STACK_DEPTH     =&gt; 1000
</span><span class="noop">  // TODO: find out the real restriction. 32 is a random number.
</span><span class="hit">  rule MAX_CALLSTACK_DEPTH =&gt; 32
</span><span class="hit">  rule MAX_SCRATCH_SIZE    =&gt; 256
</span><span class="miss">  rule LogicSigMaxSize     =&gt; 1000
</span><span class="miss">  rule LogicSigMaxCost     =&gt; 20000
</span><span class="miss">  rule MaxAppProgramLen    =&gt; 1024
</span><span class="miss">  rule MaxAppProgramCost   =&gt; 700
</span><span class="hit">  rule MAX_BYTEARRAY_LEN   =&gt; 4096
</span><span class="noop">  // MAX_BYTE_MATH_SIZE is the limit of byte strings supplied as input to byte math opcodes
</span><span class="hit">  rule MAX_BYTE_MATH_SIZE  =&gt; 64
</span><span class="miss">  rule MaxTxGroupSize      =&gt; 16
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/avm-txn-deque.md">avm/avm-txn-deque.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">Transaction Execution Deque
</span><span class="noop">===========================
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module AVM-TXN-DEQUE
</span><span class="noop">  imports LIST
</span><span class="noop">  imports SET
</span><span class="noop">  imports AVM-CONFIGURATION
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">The semantics maintains a deque that tracks the order in which the transactions will be executed.
</span><span class="noop">The deque will contain integer identifiers of transactions as tracked by the `&lt;txID&gt;` cell
</span><span class="noop">of a `&lt;transaction&gt;` cell.
</span><span class="noop">
</span><span class="noop">Note that the deque operations only *read* the `&lt;transactions&gt;` cell, and will panic of a transaction
</span><span class="noop">is not present there.
</span><span class="noop">
</span><span class="noop">**Operations**:
</span><span class="noop">
</span><span class="noop">* push a transaction to the back of the deque;
</span><span class="noop">* push a transaction to the front of the deque;
</span><span class="noop">* pop a transaction from the front of the deque.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TxnDeque ::= List
</span><span class="noop">  //----------------------
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Push to the back
</span><span class="noop">
</span><span class="noop">This operation adds a transaction id to the *back* of the deque, scheduling it for evaluation
</span><span class="noop">after all preceding transactions. Panic if the transaction is missing or is already
</span><span class="noop">scheduled for evaluation.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TxnDequeCommand ::= #pushTxnBack(TxIDCell)
</span><span class="noop">  //-----------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #pushTxnBack(&lt;txID&gt; TXN_ID &lt;/txID&gt;) =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;txnDeque&gt;
</span><span class="noop">         &lt;deque&gt; TXNS =&gt; TXNS ListItem(TXN_ID) &lt;/deque&gt;
</span><span class="noop">         &lt;dequeIndexSet&gt; INDICES =&gt; SetItem(TXN_ID) INDICES  &lt;/dequeIndexSet&gt;
</span><span class="noop">       &lt;/txnDeque&gt;
</span><span class="noop">       &lt;transactions&gt; TS &lt;/transactions&gt;
</span><span class="noop">       requires notBool (TXN_ID in INDICES)
</span><span class="noop">        andBool TXN_ID in_txns(&lt;transactions&gt; TS &lt;/transactions&gt;)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #pushTxnBack(&lt;txID&gt; TXN_ID &lt;/txID&gt;) =&gt; #internalPanic(TXN_DEQUE_ERROR) ... &lt;/k&gt;
</span><span class="noop">       &lt;dequeIndexSet&gt; INDICES &lt;/dequeIndexSet&gt;
</span><span class="noop">       requires TXN_ID in INDICES
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #pushTxnBack(&lt;txID&gt; TXN_ID &lt;/txID&gt;) =&gt; #internalPanic(TXN_DEQUE_ERROR) ... &lt;/k&gt;
</span><span class="noop">       &lt;transactions&gt; TS &lt;/transactions&gt;
</span><span class="noop">    requires notBool (TXN_ID in_txns(&lt;transactions&gt; TS &lt;/transactions&gt;))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Push to the front
</span><span class="noop">
</span><span class="noop">This operation adds a transaction id to the *front* of the deque, scheduling it
</span><span class="noop">to be evaluated as next transaction. Panic if the transaction is missing or is already
</span><span class="noop">scheduled for evaluation.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TxnDequeCommand ::= #pushTxnFront(TxIDCell)
</span><span class="noop">  //-----------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #pushTxnFront(&lt;txID&gt; TXN_ID &lt;/txID&gt;) =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;txnDeque&gt;
</span><span class="noop">         &lt;deque&gt; TXNS =&gt; ListItem(TXN_ID) TXNS &lt;/deque&gt;
</span><span class="noop">         &lt;dequeIndexSet&gt; INDICES =&gt; SetItem(TXN_ID) INDICES  &lt;/dequeIndexSet&gt;
</span><span class="noop">       &lt;/txnDeque&gt;
</span><span class="noop">       &lt;transactions&gt; TS &lt;/transactions&gt;
</span><span class="noop">       requires notBool (TXN_ID in INDICES)
</span><span class="noop">        andBool TXN_ID in_txns(&lt;transactions&gt; TS &lt;/transactions&gt;)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #pushTxnFront(&lt;txID&gt; TXN_ID &lt;/txID&gt;) =&gt; #internalPanic(TXN_DEQUE_ERROR) ... &lt;/k&gt;
</span><span class="noop">       &lt;dequeIndexSet&gt; INDICES &lt;/dequeIndexSet&gt;
</span><span class="noop">       requires TXN_ID in INDICES
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #pushTxnFront(&lt;txID&gt; TXN_ID &lt;/txID&gt;) =&gt; #internalPanic(TXN_DEQUE_ERROR) ... &lt;/k&gt;
</span><span class="noop">       &lt;transactions&gt; TS &lt;/transactions&gt;
</span><span class="noop">    requires notBool (TXN_ID in_txns(&lt;transactions&gt; TS &lt;/transactions&gt;))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Pop from the front
</span><span class="noop">
</span><span class="noop">This operation pops a transaction id from the front of the queue and sets it as the
</span><span class="noop">`&lt;currentTx&gt;`, triggering its evaluation by the AVM.
</span><span class="noop">Panics if the deque is empty.
</span><span class="noop">
</span><span class="noop">**NOTE**: we intentionally do not remove the id from the `&lt;dequeIndexSet&gt;`, so if the group,
</span><span class="noop">for some reason, contains duplicate ids, the semantics will panic.
</span><span class="noop">In Algorand, transaction ids are supposed to be unique, so this should never happen. But if it does,
</span><span class="noop">we will know immediately, since `#pushTxnFront()`/`#pushTxnBack()` would panic.
</span><span class="noop">
</span><span class="noop">**NOTE**: the check that the id is present in `&lt;transactions&gt;` will have already been performed by
</span><span class="noop">`#pushTxnFront()`/`#pushTxnBack()`.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TxnDequeCommand ::= #getNextTxn()
</span><span class="hit">  rule &lt;k&gt; #getNextTxn() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;deque&gt; ListItem(TXN_ID) _TXNS &lt;/deque&gt;
</span><span class="noop">       &lt;currentTx&gt; _ =&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #getNextTxn() =&gt; #internalPanic(TXN_DEQUE_ERROR) ... &lt;/k&gt;
</span><span class="noop">       &lt;deque&gt; .List &lt;/deque&gt;
</span><span class="noop">
</span><span class="noop">  syntax TxnDequeCommand ::= #popTxnFront()
</span><span class="noop">  //-----------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #popTxnFront() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;deque&gt; ListItem(_TXN_ID) TXNS =&gt; TXNS &lt;/deque&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #popTxnFront() =&gt; #internalPanic(TXN_DEQUE_ERROR) ... &lt;/k&gt;
</span><span class="noop">       &lt;deque&gt; .List &lt;/deque&gt;
</span><span class="noop">
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/teal/teal-constants.md">avm/teal/teal-constants.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">TEAL Integer Constants
</span><span class="noop">======================
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">requires &#34;avm/teal/teal-types.md&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">TEAL has a set of integer constants which may be passed as arguments to the
</span><span class="noop">`int` psuedo-operation.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module TEAL-CONSTANTS
</span><span class="noop">  import TEAL-TYPES-SYNTAX
</span><span class="noop">  import BYTES
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">A pusedo unsigned 64-bit integer is an immediate argument to an `int`
</span><span class="noop">psuedo-operation.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax PseudoTUInt64 ::= TUInt64
</span><span class="noop">                         | TUInt64Token
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Transaction Types
</span><span class="noop">-----------------
</span><span class="noop">
</span><span class="noop">- unknown transaction type (invalid transaction)
</span><span class="noop">- payment
</span><span class="noop">- key registration
</span><span class="noop">- asset configuration (create, configure, or destroy asset types)
</span><span class="noop">- asset transfer (transfer, accept, or clawback a given asset)
</span><span class="noop">- assert freeze (prevent account from send/receiving asset)
</span><span class="noop">- application call (invoke stateful TEAL program)
</span><span class="noop">- off-chain contract configuration (create, configure, or destory contract)
</span><span class="noop">- off-chain contract call (call a contract)
</span><span class="noop">- off-chain contract effects group (record effects of contract)
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TUInt64Token ::= &#34;unknown&#34;
</span><span class="noop">                        | &#34;pay&#34;
</span><span class="noop">                        | &#34;keyreg&#34;
</span><span class="noop">                        | &#34;acfg&#34;
</span><span class="noop">                        | &#34;axfer&#34;
</span><span class="noop">                        | &#34;afrz&#34;
</span><span class="noop">                        | &#34;appl&#34;
</span><span class="noop">                        | &#34;ccfg&#34;
</span><span class="noop">                        | &#34;ccall&#34;
</span><span class="noop">                        | &#34;cfx&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Oncompletion Action Types
</span><span class="noop">-------------------------
</span><span class="noop">
</span><span class="noop">For application call transactions (`appl`), this value defines what additional
</span><span class="noop">actions occur when the transaction completes.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TUInt64Token ::= &#34;NoOp&#34;
</span><span class="noop">                        | &#34;OptIn&#34;
</span><span class="noop">                        | &#34;CloseOut&#34;
</span><span class="noop">                        | &#34;ClearState&#34;
</span><span class="noop">                        | &#34;UpdateApplication&#34;
</span><span class="noop">                        | &#34;DeleteApplication&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TValue ::= normalizeI(PseudoTUInt64) [function, functional]
</span><span class="noop">  // ---------------------------------------------------------------
</span><span class="hit">  rule normalizeI(V:TUInt64) =&gt; V
</span><span class="noop">
</span><span class="noop">  // Oncompletion Action Types
</span><span class="noop">  // -----------------
</span><span class="hit">  rule normalizeI(NoOp             ) =&gt; 0
</span><span class="hit">  rule normalizeI(OptIn            ) =&gt; 1
</span><span class="hit">  rule normalizeI(CloseOut         ) =&gt; 2
</span><span class="hit">  rule normalizeI(ClearState       ) =&gt; 3
</span><span class="miss">  rule normalizeI(UpdateApplication) =&gt; 4
</span><span class="miss">  rule normalizeI(DeleteApplication) =&gt; 5
</span><span class="noop">
</span><span class="noop">  // Transaction Types
</span><span class="noop">  // -------------------------
</span><span class="miss">  rule normalizeI(unknown          ) =&gt; 0
</span><span class="hit">  rule normalizeI(pay              ) =&gt; 1
</span><span class="miss">  rule normalizeI(keyreg           ) =&gt; 2
</span><span class="hit">  rule normalizeI(acfg             ) =&gt; 3
</span><span class="miss">  rule normalizeI(axfer            ) =&gt; 4
</span><span class="miss">  rule normalizeI(afrz             ) =&gt; 5
</span><span class="hit">  rule normalizeI(appl             ) =&gt; 6
</span><span class="miss">  rule normalizeI(ccfg             ) =&gt; 7
</span><span class="miss">  rule normalizeI(ccall            ) =&gt; 8
</span><span class="miss">  rule normalizeI(cfx              ) =&gt; 9
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">  syntax Int ::= &#34;@&#34; TUInt64Token [macro]
</span><span class="noop">  // ------------------------------------
</span><span class="hit">  rule @ NoOp              =&gt; 0
</span><span class="hit">  rule @ OptIn             =&gt; 1
</span><span class="hit">  rule @ CloseOut          =&gt; 2
</span><span class="hit">  rule @ ClearState        =&gt; 3
</span><span class="hit">  rule @ UpdateApplication =&gt; 4
</span><span class="hit">  rule @ DeleteApplication =&gt; 5
</span><span class="noop">
</span><span class="hit">  rule @ unknown           =&gt; 0
</span><span class="hit">  rule @ pay               =&gt; 1
</span><span class="hit">  rule @ keyreg            =&gt; 2
</span><span class="hit">  rule @ acfg              =&gt; 3
</span><span class="hit">  rule @ axfer             =&gt; 4
</span><span class="hit">  rule @ afrz              =&gt; 5
</span><span class="hit">  rule @ appl              =&gt; 6
</span><span class="hit">  rule @ ccfg              =&gt; 7
</span><span class="hit">  rule @ ccall             =&gt; 8
</span><span class="hit">  rule @ cfx               =&gt; 9
</span><span class="noop">
</span><span class="noop">  syntax Int ::= typeString2Enum(Bytes) [function]
</span><span class="noop">  //----------------------------------------------
</span><span class="miss">  rule typeString2Enum(b&#34;unknown&#34;) =&gt; @ unknown
</span><span class="miss">  rule typeString2Enum(b&#34;pay&#34;)     =&gt; @ pay
</span><span class="miss">  rule typeString2Enum(b&#34;keyreg&#34;)  =&gt; @ keyreg
</span><span class="miss">  rule typeString2Enum(b&#34;acfg&#34;)    =&gt; @ acfg
</span><span class="miss">  rule typeString2Enum(b&#34;axfer&#34;)   =&gt; @ axfer
</span><span class="miss">  rule typeString2Enum(b&#34;afrz&#34;)    =&gt; @ afrz
</span><span class="miss">  rule typeString2Enum(b&#34;appl&#34;)    =&gt; @ appl
</span><span class="miss">  rule typeString2Enum(b&#34;ccfg&#34;)    =&gt; @ ccfg
</span><span class="miss">  rule typeString2Enum(b&#34;ccall&#34;)   =&gt; @ ccall
</span><span class="miss">  rule typeString2Enum(b&#34;cfx&#34;)     =&gt; @ cfx
</span><span class="noop">
</span><span class="noop">  syntax Bytes ::= typeEnum2String(Int) [function]
</span><span class="noop">  //----------------------------------------------
</span><span class="miss">  rule typeEnum2String(@ unknown) =&gt; b&#34;unknown&#34;
</span><span class="hit">  rule typeEnum2String(@ pay)     =&gt; b&#34;pay&#34;
</span><span class="miss">  rule typeEnum2String(@ keyreg)  =&gt; b&#34;keyreg&#34;
</span><span class="hit">  rule typeEnum2String(@ acfg)    =&gt; b&#34;acfg&#34;
</span><span class="miss">  rule typeEnum2String(@ axfer)   =&gt; b&#34;axfer&#34;
</span><span class="miss">  rule typeEnum2String(@ afrz)    =&gt; b&#34;afrz&#34;
</span><span class="hit">  rule typeEnum2String(@ appl)    =&gt; b&#34;appl&#34;
</span><span class="miss">  rule typeEnum2String(@ ccfg)    =&gt; b&#34;ccfg&#34;
</span><span class="miss">  rule typeEnum2String(@ ccall)   =&gt; b&#34;ccal&#34;
</span><span class="miss">  rule typeEnum2String(@ cfx)     =&gt; b&#34;cfx&#34;
</span><span class="noop">
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/teal/teal-driver.md">avm/teal/teal-driver.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
1510 &nbsp;
1511 &nbsp;
1512 &nbsp;
1513 &nbsp;
1514 &nbsp;
1515 &nbsp;
1516 &nbsp;
1517 &nbsp;
1518 &nbsp;
1519 &nbsp;
1520 &nbsp;
1521 &nbsp;
1522 &nbsp;
1523 &nbsp;
1524 &nbsp;
1525 &nbsp;
1526 &nbsp;
1527 &nbsp;
1528 &nbsp;
1529 &nbsp;
1530 &nbsp;
1531 &nbsp;
1532 &nbsp;
1533 &nbsp;
1534 &nbsp;
1535 &nbsp;
1536 &nbsp;
1537 &nbsp;
1538 &nbsp;
1539 &nbsp;
1540 &nbsp;
1541 &nbsp;
1542 &nbsp;
1543 &nbsp;
1544 &nbsp;
1545 &nbsp;
1546 &nbsp;
1547 &nbsp;
1548 &nbsp;
1549 &nbsp;
1550 &nbsp;
1551 &nbsp;
1552 &nbsp;
1553 &nbsp;
1554 &nbsp;
1555 &nbsp;
1556 &nbsp;
1557 &nbsp;
1558 &nbsp;
1559 &nbsp;
1560 &nbsp;
1561 &nbsp;
1562 &nbsp;
1563 &nbsp;
1564 &nbsp;
1565 &nbsp;
1566 &nbsp;
1567 &nbsp;
1568 &nbsp;
1569 &nbsp;
1570 &nbsp;
1571 &nbsp;
1572 &nbsp;
1573 &nbsp;
1574 &nbsp;
1575 &nbsp;
1576 &nbsp;
1577 &nbsp;
1578 &nbsp;
1579 &nbsp;
1580 &nbsp;
1581 &nbsp;
1582 &nbsp;
1583 &nbsp;
1584 &nbsp;
1585 &nbsp;
1586 &nbsp;
1587 &nbsp;
1588 &nbsp;
1589 &nbsp;
1590 &nbsp;
1591 &nbsp;
1592 &nbsp;
1593 &nbsp;
1594 &nbsp;
1595 &nbsp;
1596 &nbsp;
1597 &nbsp;
1598 &nbsp;
1599 &nbsp;
1600 &nbsp;
1601 &nbsp;
1602 &nbsp;
1603 &nbsp;
1604 &nbsp;
1605 &nbsp;
1606 &nbsp;
1607 &nbsp;
1608 &nbsp;
1609 &nbsp;
1610 &nbsp;
1611 &nbsp;
1612 &nbsp;
1613 &nbsp;
1614 &nbsp;
1615 &nbsp;
1616 &nbsp;
1617 &nbsp;
1618 &nbsp;
1619 &nbsp;
1620 &nbsp;
1621 &nbsp;
1622 &nbsp;
1623 &nbsp;
1624 &nbsp;
1625 &nbsp;
1626 &nbsp;
1627 &nbsp;
1628 &nbsp;
1629 &nbsp;
1630 &nbsp;
1631 &nbsp;
1632 &nbsp;
1633 &nbsp;
1634 &nbsp;
1635 &nbsp;
1636 &nbsp;
1637 &nbsp;
1638 &nbsp;
1639 &nbsp;
1640 &nbsp;
1641 &nbsp;
1642 &nbsp;
1643 &nbsp;
1644 &nbsp;
1645 &nbsp;
1646 &nbsp;
1647 &nbsp;
1648 &nbsp;
1649 &nbsp;
1650 &nbsp;
1651 &nbsp;
1652 &nbsp;
1653 &nbsp;
1654 &nbsp;
1655 &nbsp;
1656 &nbsp;
1657 &nbsp;
1658 &nbsp;
1659 &nbsp;
1660 &nbsp;
1661 &nbsp;
1662 &nbsp;
1663 &nbsp;
1664 &nbsp;
1665 &nbsp;
1666 &nbsp;
1667 &nbsp;
1668 &nbsp;
1669 &nbsp;
1670 &nbsp;
1671 &nbsp;
1672 &nbsp;
1673 &nbsp;
1674 &nbsp;
1675 &nbsp;
1676 &nbsp;
1677 &nbsp;
1678 &nbsp;
1679 &nbsp;
1680 &nbsp;
1681 &nbsp;
1682 &nbsp;
1683 &nbsp;
1684 &nbsp;
1685 &nbsp;
1686 &nbsp;
1687 &nbsp;
1688 &nbsp;
1689 &nbsp;
1690 &nbsp;
1691 &nbsp;
1692 &nbsp;
1693 &nbsp;
1694 &nbsp;
1695 &nbsp;
1696 &nbsp;
1697 &nbsp;
1698 &nbsp;
1699 &nbsp;
1700 &nbsp;
1701 &nbsp;
1702 &nbsp;
1703 &nbsp;
1704 &nbsp;
1705 &nbsp;
1706 &nbsp;
1707 &nbsp;
1708 &nbsp;
1709 &nbsp;
1710 &nbsp;
1711 &nbsp;
1712 &nbsp;
1713 &nbsp;
1714 &nbsp;
1715 &nbsp;
1716 &nbsp;
1717 &nbsp;
1718 &nbsp;
1719 &nbsp;
1720 &nbsp;
1721 &nbsp;
1722 &nbsp;
1723 &nbsp;
1724 &nbsp;
1725 &nbsp;
1726 &nbsp;
1727 &nbsp;
1728 &nbsp;
1729 &nbsp;
1730 &nbsp;
1731 &nbsp;
1732 &nbsp;
1733 &nbsp;
1734 &nbsp;
1735 &nbsp;
1736 &nbsp;
1737 &nbsp;
1738 &nbsp;
1739 &nbsp;
1740 &nbsp;
1741 &nbsp;
1742 &nbsp;
1743 &nbsp;
1744 &nbsp;
1745 &nbsp;
1746 &nbsp;
1747 &nbsp;
1748 &nbsp;
1749 &nbsp;
1750 &nbsp;
1751 &nbsp;
1752 &nbsp;
1753 &nbsp;
1754 &nbsp;
1755 &nbsp;
1756 &nbsp;
1757 &nbsp;
1758 &nbsp;
1759 &nbsp;
1760 &nbsp;
1761 &nbsp;
1762 &nbsp;
1763 &nbsp;
1764 &nbsp;
1765 &nbsp;
1766 &nbsp;
1767 &nbsp;
1768 &nbsp;
1769 &nbsp;
1770 &nbsp;
1771 &nbsp;
1772 &nbsp;
1773 &nbsp;
1774 &nbsp;
1775 &nbsp;
1776 &nbsp;
1777 &nbsp;
1778 &nbsp;
1779 &nbsp;
1780 &nbsp;
1781 &nbsp;
1782 &nbsp;
1783 &nbsp;
1784 &nbsp;
1785 &nbsp;
1786 &nbsp;
1787 &nbsp;
1788 &nbsp;
1789 &nbsp;
1790 &nbsp;
1791 &nbsp;
1792 &nbsp;
1793 &nbsp;
1794 &nbsp;
1795 &nbsp;
1796 &nbsp;
1797 &nbsp;
1798 &nbsp;
1799 &nbsp;
1800 &nbsp;
1801 &nbsp;
1802 &nbsp;
1803 &nbsp;
1804 &nbsp;
1805 &nbsp;
1806 &nbsp;
1807 &nbsp;
1808 &nbsp;
1809 &nbsp;
1810 &nbsp;
1811 &nbsp;
1812 &nbsp;
1813 &nbsp;
1814 &nbsp;
1815 &nbsp;
1816 &nbsp;
1817 &nbsp;
1818 &nbsp;
1819 &nbsp;
1820 &nbsp;
1821 &nbsp;
1822 &nbsp;
1823 &nbsp;
1824 &nbsp;
1825 &nbsp;
1826 &nbsp;
1827 &nbsp;
1828 &nbsp;
1829 &nbsp;
1830 &nbsp;
1831 &nbsp;
1832 &nbsp;
1833 &nbsp;
1834 &nbsp;
1835 &nbsp;
1836 &nbsp;
1837 &nbsp;
1838 &nbsp;
1839 &nbsp;
1840 &nbsp;
1841 &nbsp;
1842 &nbsp;
1843 &nbsp;
1844 &nbsp;
1845 &nbsp;
1846 &nbsp;
1847 &nbsp;
1848 &nbsp;
1849 &nbsp;
1850 &nbsp;
1851 &nbsp;
1852 &nbsp;
1853 &nbsp;
1854 &nbsp;
1855 &nbsp;
1856 &nbsp;
1857 &nbsp;
1858 &nbsp;
1859 &nbsp;
1860 &nbsp;
1861 &nbsp;
1862 &nbsp;
1863 &nbsp;
1864 &nbsp;
1865 &nbsp;
1866 &nbsp;
1867 &nbsp;
1868 &nbsp;
1869 &nbsp;
1870 &nbsp;
1871 &nbsp;
1872 &nbsp;
1873 &nbsp;
1874 &nbsp;
1875 &nbsp;
1876 &nbsp;
1877 &nbsp;
1878 &nbsp;
1879 &nbsp;
1880 &nbsp;
1881 &nbsp;
1882 &nbsp;
1883 &nbsp;
1884 &nbsp;
1885 &nbsp;
1886 &nbsp;
1887 &nbsp;
1888 &nbsp;
1889 &nbsp;
1890 &nbsp;
1891 &nbsp;
1892 &nbsp;
1893 &nbsp;
1894 &nbsp;
1895 &nbsp;
1896 &nbsp;
1897 &nbsp;
1898 &nbsp;
1899 &nbsp;
1900 &nbsp;
1901 &nbsp;
1902 &nbsp;
1903 &nbsp;
1904 &nbsp;
1905 &nbsp;
1906 &nbsp;
1907 &nbsp;
1908 &nbsp;
1909 &nbsp;
1910 &nbsp;
1911 &nbsp;
1912 &nbsp;
1913 &nbsp;
1914 &nbsp;
1915 &nbsp;
1916 &nbsp;
1917 &nbsp;
1918 &nbsp;
1919 &nbsp;
1920 &nbsp;
1921 &nbsp;
1922 &nbsp;
1923 &nbsp;
1924 &nbsp;
1925 &nbsp;
1926 &nbsp;
1927 &nbsp;
1928 &nbsp;
1929 &nbsp;
1930 &nbsp;
1931 &nbsp;
1932 &nbsp;
1933 &nbsp;
1934 &nbsp;
1935 &nbsp;
1936 &nbsp;
1937 &nbsp;
1938 &nbsp;
1939 &nbsp;
1940 &nbsp;
1941 &nbsp;
1942 &nbsp;
1943 &nbsp;
1944 &nbsp;
1945 &nbsp;
1946 &nbsp;
1947 &nbsp;
1948 &nbsp;
1949 &nbsp;
1950 &nbsp;
1951 &nbsp;
1952 &nbsp;
1953 &nbsp;
1954 &nbsp;
1955 &nbsp;
1956 &nbsp;
1957 &nbsp;
1958 &nbsp;
1959 &nbsp;
1960 &nbsp;
1961 &nbsp;
1962 &nbsp;
1963 &nbsp;
1964 &nbsp;
1965 &nbsp;
1966 &nbsp;
1967 &nbsp;
1968 &nbsp;
1969 &nbsp;
1970 &nbsp;
1971 &nbsp;
1972 &nbsp;
1973 &nbsp;
1974 &nbsp;
1975 &nbsp;
1976 &nbsp;
1977 &nbsp;
1978 &nbsp;
1979 &nbsp;
1980 &nbsp;
1981 &nbsp;
1982 &nbsp;
1983 &nbsp;
1984 &nbsp;
1985 &nbsp;
1986 &nbsp;
1987 &nbsp;
1988 &nbsp;
1989 &nbsp;
1990 &nbsp;
1991 &nbsp;
1992 &nbsp;
1993 &nbsp;
1994 &nbsp;
1995 &nbsp;
1996 &nbsp;
1997 &nbsp;
1998 &nbsp;
1999 &nbsp;
2000 &nbsp;
2001 &nbsp;
2002 &nbsp;
2003 &nbsp;
2004 &nbsp;
2005 &nbsp;
2006 &nbsp;
2007 &nbsp;
2008 &nbsp;
2009 &nbsp;
2010 &nbsp;
2011 &nbsp;
2012 &nbsp;
2013 &nbsp;
2014 &nbsp;
2015 &nbsp;
2016 &nbsp;
2017 &nbsp;
2018 &nbsp;
2019 &nbsp;
2020 &nbsp;
2021 &nbsp;
2022 &nbsp;
2023 &nbsp;
2024 &nbsp;
2025 &nbsp;
2026 &nbsp;
2027 &nbsp;
2028 &nbsp;
2029 &nbsp;
2030 &nbsp;
2031 &nbsp;
2032 &nbsp;
2033 &nbsp;
2034 &nbsp;
2035 &nbsp;
2036 &nbsp;
2037 &nbsp;
2038 &nbsp;
2039 &nbsp;
2040 &nbsp;
2041 &nbsp;
2042 &nbsp;
2043 &nbsp;
2044 &nbsp;
2045 &nbsp;
2046 &nbsp;
2047 &nbsp;
2048 &nbsp;
2049 &nbsp;
2050 &nbsp;
2051 &nbsp;
2052 &nbsp;
2053 &nbsp;
2054 &nbsp;
2055 &nbsp;
2056 &nbsp;
2057 &nbsp;
2058 &nbsp;
2059 &nbsp;
2060 &nbsp;
2061 &nbsp;
2062 &nbsp;
2063 &nbsp;
2064 &nbsp;
2065 &nbsp;
2066 &nbsp;
2067 &nbsp;
2068 &nbsp;
2069 &nbsp;
2070 &nbsp;
2071 &nbsp;
2072 &nbsp;
2073 &nbsp;
2074 &nbsp;
2075 &nbsp;
2076 &nbsp;
2077 &nbsp;
2078 &nbsp;
2079 &nbsp;
2080 &nbsp;
2081 &nbsp;
2082 &nbsp;
2083 &nbsp;
2084 &nbsp;
2085 &nbsp;
2086 &nbsp;
2087 &nbsp;
2088 &nbsp;
2089 &nbsp;
2090 &nbsp;
2091 &nbsp;
2092 &nbsp;
2093 &nbsp;
2094 &nbsp;
2095 &nbsp;
2096 &nbsp;
2097 &nbsp;
2098 &nbsp;
2099 &nbsp;
2100 &nbsp;
2101 &nbsp;
2102 &nbsp;
2103 &nbsp;
2104 &nbsp;
2105 &nbsp;
2106 &nbsp;
2107 &nbsp;
2108 &nbsp;
2109 &nbsp;
2110 &nbsp;
2111 &nbsp;
2112 &nbsp;
2113 &nbsp;
2114 &nbsp;
2115 &nbsp;
2116 &nbsp;
2117 &nbsp;
2118 &nbsp;
2119 &nbsp;
2120 &nbsp;
2121 &nbsp;
2122 &nbsp;
2123 &nbsp;
2124 &nbsp;
2125 &nbsp;
2126 &nbsp;
2127 &nbsp;
2128 &nbsp;
2129 &nbsp;
2130 &nbsp;
2131 &nbsp;
2132 &nbsp;
2133 &nbsp;
2134 &nbsp;
2135 &nbsp;
2136 &nbsp;
2137 &nbsp;
2138 &nbsp;
2139 &nbsp;
2140 &nbsp;
2141 &nbsp;
2142 &nbsp;
2143 &nbsp;
2144 &nbsp;
2145 &nbsp;
2146 &nbsp;
2147 &nbsp;
2148 &nbsp;
2149 &nbsp;
2150 &nbsp;
2151 &nbsp;
2152 &nbsp;
2153 &nbsp;
2154 &nbsp;
2155 &nbsp;
2156 &nbsp;
2157 &nbsp;
2158 &nbsp;
2159 &nbsp;
2160 &nbsp;
2161 &nbsp;
2162 &nbsp;
2163 &nbsp;
2164 &nbsp;
2165 &nbsp;
2166 &nbsp;
2167 &nbsp;
2168 &nbsp;
2169 &nbsp;
2170 &nbsp;
2171 &nbsp;
2172 &nbsp;
2173 &nbsp;
2174 &nbsp;
2175 &nbsp;
2176 &nbsp;
2177 &nbsp;
2178 &nbsp;
2179 &nbsp;
2180 &nbsp;
2181 &nbsp;
2182 &nbsp;
2183 &nbsp;
2184 &nbsp;
2185 &nbsp;
2186 &nbsp;
2187 &nbsp;
2188 &nbsp;
2189 &nbsp;
2190 &nbsp;
2191 &nbsp;
2192 &nbsp;
2193 &nbsp;
2194 &nbsp;
2195 &nbsp;
2196 &nbsp;
2197 &nbsp;
2198 &nbsp;
2199 &nbsp;
2200 &nbsp;
2201 &nbsp;
2202 &nbsp;
2203 &nbsp;
2204 &nbsp;
2205 &nbsp;
2206 &nbsp;
2207 &nbsp;
2208 &nbsp;
2209 &nbsp;
2210 &nbsp;
2211 &nbsp;
2212 &nbsp;
2213 &nbsp;
2214 &nbsp;
2215 &nbsp;
2216 &nbsp;
2217 &nbsp;
2218 &nbsp;
2219 &nbsp;
2220 &nbsp;
2221 &nbsp;
2222 &nbsp;
2223 &nbsp;
2224 &nbsp;
2225 &nbsp;
2226 &nbsp;
2227 &nbsp;
2228 &nbsp;
2229 &nbsp;
2230 &nbsp;
2231 &nbsp;
2232 &nbsp;
2233 &nbsp;
2234 &nbsp;
2235 &nbsp;
2236 &nbsp;
2237 &nbsp;
2238 &nbsp;
2239 &nbsp;
2240 &nbsp;
2241 &nbsp;
2242 &nbsp;
2243 &nbsp;
2244 &nbsp;
2245 &nbsp;
2246 &nbsp;
2247 &nbsp;
2248 &nbsp;
2249 &nbsp;
2250 &nbsp;
2251 &nbsp;
2252 &nbsp;
2253 &nbsp;
2254 &nbsp;
2255 &nbsp;
2256 &nbsp;
2257 &nbsp;
2258 &nbsp;
2259 &nbsp;
2260 &nbsp;
2261 &nbsp;
2262 &nbsp;
2263 &nbsp;
2264 &nbsp;
2265 &nbsp;
2266 &nbsp;
2267 &nbsp;
2268 &nbsp;
2269 &nbsp;
2270 &nbsp;
2271 &nbsp;
2272 &nbsp;
2273 &nbsp;
2274 &nbsp;
2275 &nbsp;
2276 &nbsp;
2277 &nbsp;
2278 &nbsp;
2279 &nbsp;
2280 &nbsp;
2281 &nbsp;
2282 &nbsp;
2283 &nbsp;
2284 &nbsp;
2285 &nbsp;
2286 &nbsp;
2287 &nbsp;
2288 &nbsp;
2289 &nbsp;
2290 &nbsp;
2291 &nbsp;
2292 &nbsp;
2293 &nbsp;
2294 &nbsp;
2295 &nbsp;
2296 &nbsp;
2297 &nbsp;
2298 &nbsp;
2299 &nbsp;
2300 &nbsp;
2301 &nbsp;
2302 &nbsp;
2303 &nbsp;
2304 &nbsp;
2305 &nbsp;
2306 &nbsp;
2307 &nbsp;
2308 &nbsp;
2309 &nbsp;
2310 &nbsp;
2311 &nbsp;
2312 &nbsp;
2313 &nbsp;
2314 &nbsp;
2315 &nbsp;
2316 &nbsp;
2317 &nbsp;
2318 &nbsp;
2319 &nbsp;
2320 &nbsp;
2321 &nbsp;
2322 &nbsp;
2323 &nbsp;
2324 &nbsp;
2325 &nbsp;
2326 &nbsp;
2327 &nbsp;
2328 &nbsp;
2329 &nbsp;
2330 &nbsp;
2331 &nbsp;
2332 &nbsp;
2333 &nbsp;
2334 &nbsp;
2335 &nbsp;
2336 &nbsp;
2337 &nbsp;
2338 &nbsp;
2339 &nbsp;
2340 &nbsp;
2341 &nbsp;
2342 &nbsp;
2343 &nbsp;
2344 &nbsp;
2345 &nbsp;
2346 &nbsp;
2347 &nbsp;
2348 &nbsp;
2349 &nbsp;
2350 &nbsp;
2351 &nbsp;
2352 &nbsp;
2353 &nbsp;
2354 &nbsp;
2355 &nbsp;
2356 &nbsp;
2357 &nbsp;
2358 &nbsp;
2359 &nbsp;
2360 &nbsp;
2361 &nbsp;
2362 &nbsp;
2363 &nbsp;
2364 &nbsp;
2365 &nbsp;
2366 &nbsp;
2367 &nbsp;
2368 &nbsp;
2369 &nbsp;
2370 &nbsp;
2371 &nbsp;
2372 &nbsp;
2373 &nbsp;
2374 &nbsp;
2375 &nbsp;
2376 &nbsp;
2377 &nbsp;
2378 &nbsp;
2379 &nbsp;
2380 &nbsp;
2381 &nbsp;
2382 &nbsp;
2383 &nbsp;
2384 &nbsp;
2385 &nbsp;
2386 &nbsp;
2387 &nbsp;
2388 &nbsp;
2389 &nbsp;
2390 &nbsp;
2391 &nbsp;
2392 &nbsp;
2393 &nbsp;
2394 &nbsp;
2395 &nbsp;
2396 &nbsp;
2397 &nbsp;
2398 &nbsp;
2399 &nbsp;
2400 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">```k
</span><span class="noop">requires &#34;krypto.md&#34;
</span><span class="noop">
</span><span class="noop">requires &#34;avm/blockchain.md&#34;
</span><span class="noop">requires &#34;avm/args.md&#34;
</span><span class="noop">requires &#34;avm/avm-configuration.md&#34;
</span><span class="noop">requires &#34;avm/avm-limits.md&#34;
</span><span class="noop">requires &#34;avm/itxn.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-syntax.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-stack.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-execution.md&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">TEAL Interpreter
</span><span class="noop">================
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module TEAL-DRIVER
</span><span class="noop">  imports AVM-CONFIGURATION
</span><span class="noop">  imports AVM-LIMITS
</span><span class="noop">  imports ALGO-ITXN
</span><span class="noop">  imports GLOBALS
</span><span class="noop">  imports TEAL-INTERPRETER-STATE
</span><span class="noop">  imports TEAL-EXECUTION
</span><span class="noop">  imports TEAL-STACK
</span><span class="noop">  imports KRYPTO
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">This module describes the semantics of TEAL opcodes.
</span><span class="noop">
</span><span class="noop">See `teal-execution.md` for the initialization, execution flow and finalization semantics:
</span><span class="noop">* [Interpreter Initialization](./teal-execution.md#teal-interpreter-initialization)
</span><span class="noop">* [Execution](./teal-execution.md#teal-execution)
</span><span class="noop">* [Interpreter Finalization](./teal-execution.md#teal-interpreter-finalization)
</span><span class="noop">* [TEAL Panic Behaviors](./teal-execution.md#panic-behaviors)
</span><span class="noop">
</span><span class="noop">Opcode Semantics
</span><span class="noop">================
</span><span class="noop">
</span><span class="noop">### Special Operations
</span><span class="noop">
</span><span class="noop">*Internal NoOp*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; NoOpCode  =&gt; .K ... &lt;/k&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*The `err` Opcode*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; err =&gt; panic(ERR_OPCODE) ... &lt;/k&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Cryptographic Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; sha256 =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : XS =&gt; String2Bytes(Sha256raw(Bytes2String(B))) : XS &lt;/stack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; keccak256 =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : XS =&gt; String2Bytes(Keccak256raw(Bytes2String(B))) : XS &lt;/stack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; sha512_256 =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : XS =&gt; String2Bytes(Sha512_256raw(Bytes2String(B))) : XS &lt;/stack&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Arithmetic Operations
</span><span class="noop">
</span><span class="noop">*Addition*
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; + =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; (I1 +Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I1 +Int I2 &lt;=Int MAX_UINT64
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; + =&gt; panic(INT_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : _ &lt;/stack&gt;
</span><span class="noop">    requires I1 +Int I2 &gt;Int MAX_UINT64
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Subtraction*
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; - =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; (I1 -Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I1 &gt;=Int I2
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; - =&gt; panic(INT_UNDERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : _ &lt;/stack&gt;
</span><span class="noop">    requires I1 &lt;Int I2
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Multiplication*
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; * =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; (I1 *Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I1 *Int I2 &lt;=Int MAX_UINT64
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; * =&gt; panic(INT_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : _ &lt;/stack&gt;
</span><span class="noop">    requires I1 *Int I2 &gt;Int MAX_UINT64
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Division*
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; / =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; (I1 /Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I2 &gt;Int 0
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; / =&gt; panic(DIV_BY_ZERO) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : (_:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires I2 &lt;=Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Remainder*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; % =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; (I1 %Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I2 &gt;Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; % =&gt; panic(DIV_BY_ZERO) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : (_:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires I2 &lt;=Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Exponentiation*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; exp =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; (I1 ^Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I1 ^Int I2 &lt;=Int MAX_UINT64
</span><span class="noop">     andBool notBool (I1 ==Int 0 andBool I2 ==Int 0)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; exp =&gt; panic(INVALID_ARGUMENT) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : _ &lt;/stack&gt;
</span><span class="noop">    requires I1 ==Int 0 andBool I2 ==Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; exp =&gt; panic(INT_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : _ &lt;/stack&gt;
</span><span class="noop">    requires I1 ^Int I2 &gt;Int MAX_UINT64
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Wide 128-bit Division and Modulus*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; divmodw =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I4 : I3 : I2 : I1 : XS =&gt;
</span><span class="miss">               #fun(NUMERATOR
</span><span class="miss">            =&gt; #fun(DENOMINATOR
</span><span class="miss">            =&gt; #fun(QUOTIENT
</span><span class="miss">            =&gt; #fun(REMAINDER
</span><span class="noop">            =&gt;   lowerU64(REMAINDER) : upperU64(REMAINDER) :
</span><span class="noop">                 lowerU64(QUOTIENT)  : upperU64(QUOTIENT)  : XS
</span><span class="noop">               )(NUMERATOR %Int DENOMINATOR)
</span><span class="noop">               )(NUMERATOR /Int DENOMINATOR)
</span><span class="noop">               )(asUInt128(I3, I4))
</span><span class="noop">               )(asUInt128(I1, I2))
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">    requires notBool (I4 ==Int 0 andBool I3 ==Int 0)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; divmodw =&gt; panic(DIV_BY_ZERO) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I4 : I3 : _ : _ : _ &lt;/stack&gt;
</span><span class="noop">    requires I4 ==Int 0 andBool I3 ==Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; divw =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I3 : I2 : I1 : XS =&gt;
</span><span class="miss">               #fun(NUMERATOR
</span><span class="miss">            =&gt; #fun(DENOMINATOR
</span><span class="miss">            =&gt; #fun(QUOTIENT
</span><span class="noop">            =&gt; QUOTIENT : XS
</span><span class="noop">               )(NUMERATOR /Int DENOMINATOR)
</span><span class="noop">               )(I3)
</span><span class="noop">               )(asUInt128(I1, I2))
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">    requires I3 =/=Int 0
</span><span class="noop">     andBool (asUInt128(I1, I2) /Int I3) &lt;=Int MAX_UINT64
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; divw =&gt; panic(INT_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I3 : I2 : I1 : _ &lt;/stack&gt;
</span><span class="noop">    requires I3 =/=Int 0
</span><span class="noop">     andBool (asUInt128(I1, I2) /Int I3) &gt;Int MAX_UINT64
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; divw =&gt; panic(DIV_BY_ZERO) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; 0 : _ : _ : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; divw =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I3 : I2 : I1 : _ &lt;/stack&gt;
</span><span class="noop">    requires isBytes(I1) orBool isBytes(I2) orBool isBytes(I3)
</span><span class="noop">
</span><span class="noop">  // Auxilary funtion that interprets two `UInt64` as one Int, big-endian
</span><span class="noop">  syntax Int ::= asUInt128(TUInt64, TUInt64) [function, functional]
</span><span class="noop">  // --------------------------------------------------------------
</span><span class="miss">  rule asUInt128(I1, I2) =&gt; (I1 &lt;&lt;Int 64) +Int I2
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Wide 128-bit Addition*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; addw =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; lowerU64(I1 +Int I2) : upperU64(I1 +Int I2) : XS &lt;/stack&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Wide 128-bit Multiplication*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; mulw =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; lowerU64(I1 *Int I2) : upperU64(I1 *Int I2) : XS &lt;/stack&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Wide 128-bit Exponentiation*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; expw =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; lowerU64(I1 ^Int I2) : upperU64(I1 ^Int I2) : XS &lt;/stack&gt;
</span><span class="noop">    requires I1 ^Int I2 &lt;=Int MAX_UINT128
</span><span class="noop">     andBool notBool (I1 ==Int 0 andBool I2 ==Int 0)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; expw =&gt; panic(INVALID_ARGUMENT) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : _ &lt;/stack&gt;
</span><span class="noop">    requires I1 ==Int 0 andBool I2 ==Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; expw =&gt; panic(INT_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : _ &lt;/stack&gt;
</span><span class="noop">    requires I1 ^Int I2 &gt;Int MAX_UINT128
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Square root*
</span><span class="noop">
</span><span class="noop">The largest integer B such that B^2 &lt;= X
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; sqrt =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; X : XS =&gt; sqrtTUInt64(X) : XS &lt;/stack&gt;
</span><span class="noop">    requires X &gt;=Int 0 andBool X &lt;=Int MAX_UINT64
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; sqrt =&gt; panic(INVALID_ARGUMENT) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; X : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool( X &gt;=Int 0 andBool X &lt;=Int MAX_UINT64)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">The `sqrtTUInt64` function implements the integer square root algorithms described by the following excerpt
</span><span class="noop">from the [reference TEAL interpreter](https://github.com/algorand/go-algorand/blob/ca3e87734833123284d3a7d87fcc9eaaede8f32a/data/transactions/logic/eval.go#L1202):
</span><span class="noop">
</span><span class="noop">```go
</span><span class="noop">last := len(cx.stack) - 1
</span><span class="noop">sq := cx.stack[last].Uint
</span><span class="noop">var rem uint64 = 0
</span><span class="noop">var root uint64 = 0
</span><span class="noop">for i := 0; i &lt; 32; i++ {
</span><span class="noop">	root &lt;&lt;= 1
</span><span class="noop">	rem = (rem &lt;&lt; 2) | (sq &gt;&gt; (64 - 2))
</span><span class="noop">	sq &lt;&lt;= 2
</span><span class="noop">	if root &lt; rem {
</span><span class="noop">		rem -= root | 1
</span><span class="noop">		root += 2
</span><span class="noop">	}
</span><span class="noop">}
</span><span class="noop">cx.stack[last].Uint = root &gt;&gt; 1
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Note that we need to perform the left shift modulo `MAX_UINT64 + 1`, otherwise the `SQ` variable will exceed `MAX_UINT64` in the last iteration.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Int ::= sqrtTUInt64(TUInt64)                        [function]
</span><span class="noop">               | sqrtTUInt64(TUInt64, TUInt64, TUInt64, Int) [function]
</span><span class="noop">  // ------------------------------------------------------------------
</span><span class="miss">  rule sqrtTUInt64(SQ) =&gt; sqrtTUInt64(SQ, 0, 0, 0)
</span><span class="noop">    requires SQ &gt;=Int 0 andBool SQ &lt;=Int MAX_UINT64
</span><span class="noop">
</span><span class="miss">  rule sqrtTUInt64(SQ, REM, ROOT, I) =&gt;
</span><span class="miss">       #fun(ROOT&#39;
</span><span class="miss">    =&gt; #fun(REM&#39;
</span><span class="noop">    =&gt; #if   ROOT&#39; &lt;Int REM&#39;
</span><span class="noop">       #then sqrtTUInt64((SQ &lt;&lt;Int 2) %Int (MAX_UINT64 +Int 1)
</span><span class="noop">                        , REM&#39; -Int (ROOT&#39; |Int 1)
</span><span class="noop">                        , ROOT&#39; +Int 2
</span><span class="noop">                        , I +Int 1)
</span><span class="noop">       #else sqrtTUInt64((SQ &lt;&lt;Int 2) %Int (MAX_UINT64 +Int 1)
</span><span class="noop">                        , REM&#39;
</span><span class="noop">                        , ROOT&#39;
</span><span class="noop">                        , I +Int 1)
</span><span class="noop">       #fi
</span><span class="noop">       )((REM &lt;&lt;Int 2) |Int (SQ &gt;&gt;Int (64 -Int 2)))
</span><span class="noop">       )(ROOT &lt;&lt;Int 1)
</span><span class="noop">    requires I &gt;=Int 0 andBool I &lt;Int 32
</span><span class="miss">  rule sqrtTUInt64(_, _  , ROOT, I) =&gt; ROOT &gt;&gt;Int 1
</span><span class="noop">    requires I &gt;=Int 32
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Relational Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; &lt; =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; bool2Int (I1 &lt;Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; &gt; =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; bool2Int (I1 &gt;Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; &lt;= =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; bool2Int (I1 &lt;=Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; &gt;= =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; bool2Int (I1 &gt;=Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; == =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (I2:Int) : (I1:Int) : XS =&gt; bool2Int (I1 ==Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; == =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (B2:Bytes) : (B1:Bytes) : XS =&gt; bool2Int (B1 ==K B2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; != =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (I2:Int) : (I1:Int) : XS =&gt; bool2Int (I1 =/=K I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; != =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (B2:Bytes) : (B1:Bytes) : XS =&gt;
</span><span class="noop">               bool2Int (B1 =/=K B2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Logical Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; &amp;&amp; =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt;
</span><span class="noop">               bool2Int (I1 &gt;Int 0 andBool I2 &gt;Int 0) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; || =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt;
</span><span class="noop">               bool2Int (I1 &gt;Int 0 orBool I2 &gt;Int 0) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; ! =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : XS =&gt; bool2Int (I ==Int 0) : XS &lt;/stack&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Bitwise Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; | =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; (I1 |Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; &amp; =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; (I1 &amp;Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; ^ =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; (I1 xorInt I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; shl =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; ((I1 &lt;&lt;Int I2) %Int (MAX_UINT64 +Int 1)) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I2 &gt;=Int 0 andBool I2 &lt;Int 64
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; shl =&gt; panic(INVALID_ARGUMENT) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : _ : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool (I2 &gt;=Int 0 andBool I2 &lt;Int 64)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; shr =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : I1 : XS =&gt; (I1 &gt;&gt;Int I2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I2 &gt;=Int 0 andBool I2 &lt;Int 64
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; shr =&gt; panic(INVALID_ARGUMENT) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I2 : _ : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool (I2 &gt;=Int 0 andBool I2 &lt;Int 64)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; ~ =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : XS =&gt; (~Int I) : XS &lt;/stack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; ~ =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _:Bytes : _ &lt;/stack&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">`bitlen` computes the highest set bit in X, indexed from one. Can be used for both integers and byte-arrays.
</span><span class="noop">If X is a byte-array, it is interpreted as a big-endian unsigned integer. bitlen of 0 is 0, bitlen of 8 is 4.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; bitlen =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (I:Int) : XS =&gt; 0 : XS &lt;/stack&gt;
</span><span class="noop">    requires I ==Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; bitlen =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (I:Int) : XS =&gt; log2Int(I) +Int 1 : XS &lt;/stack&gt;
</span><span class="noop">    requires 0 &lt;Int I andBool I &lt;=Int MAX_UINT64
</span><span class="noop">
</span><span class="noop">//  rule &lt;k&gt; bitlen =&gt; panic(INVALID_ARGUMENT) ... &lt;/k&gt;
</span><span class="noop">//       &lt;stack&gt; (I:Int) : _ &lt;/stack&gt;
</span><span class="noop">//    requires notBool (0 &lt;=Int I andBool I &lt;=Int MAX_UINT64)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; bitlen =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (B:Bytes) : XS =&gt; 0 : XS &lt;/stack&gt;
</span><span class="noop">    requires lengthBytes(B) &lt;=Int MAX_BYTEARRAY_LEN
</span><span class="noop">     andBool Bytes2Int(B, BE, Unsigned) ==Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; bitlen =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (B:Bytes) : XS =&gt; log2Int(Bytes2Int(B, BE, Unsigned)) +Int 1 : XS &lt;/stack&gt;
</span><span class="noop">    requires lengthBytes(B) &lt;=Int MAX_BYTEARRAY_LEN
</span><span class="noop">     andBool Bytes2Int(B, BE, Unsigned) &gt;Int 0
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Byte Array Operations
</span><span class="noop">
</span><span class="noop">*Bytes length*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; len =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : XS =&gt; lengthBytes(B) : XS &lt;/stack&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Int-to-bytes conversion*
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; itob =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : XS =&gt; Int2Bytes(I, BE, Unsigned) : XS &lt;/stack&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Bytes-to-int conversion*
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; btoi =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : XS =&gt; Bytes2Int(B, BE, Unsigned) : XS &lt;/stack&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Bytes concatenation*
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; concat =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B2 : B1 : XS =&gt; (B1 +Bytes B2) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(B1 +Bytes B2) &lt;=Int MAX_BYTEARRAY_LEN
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; concat =&gt; panic(BYTES_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B2 : B1 : _ &lt;/stack&gt;
</span><span class="noop">    requires lengthBytes(B1 +Bytes B2) &gt;Int MAX_BYTEARRAY_LEN
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Bytes Substring*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; substring START END =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : XS =&gt; substrBytes(B, START, END) : XS &lt;/stack&gt;
</span><span class="noop">    requires 0 &lt;=Int START andBool START &lt;=Int END andBool END &lt;=Int lengthBytes(B)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; substring START END =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (B:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">    requires 0 &gt;Int START orBool START &gt;Int END orBool END &gt;Int lengthBytes(B)
</span><span class="noop">
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; substring3 =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : START : END : XS =&gt; substrBytes(B, START, END) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">    requires 0 &lt;=Int START andBool START &lt;=Int END andBool END &lt;=Int lengthBytes(B)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; substring3 =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (B:Bytes) : START : END : _ &lt;/stack&gt;
</span><span class="noop">    requires 0 &gt;Int START orBool START &gt;Int END orBool END &gt;Int lengthBytes(B)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Zero bytes*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; bzero =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; X : XS =&gt; padLeftBytes(.Bytes, X, 0) : XS &lt;/stack&gt;
</span><span class="noop">    requires X &lt;=Int MAX_BYTEARRAY_LEN
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; bzero =&gt; panic(INVALID_ARGUMENT) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; X : _ &lt;/stack&gt;
</span><span class="noop">    requires X &gt;Int MAX_BYTEARRAY_LEN
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Byte-array access and modification*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; getbyte =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; ARRAY : B : XS =&gt; ARRAY[B] : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires 0 &lt;=Int B andBool B &lt;Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; getbyte =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; ARRAY : B : _ &lt;/stack&gt;
</span><span class="noop">    requires 0 &gt;Int B orBool B &gt;=Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; setbyte =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; ARRAY : B : C : XS =&gt; ARRAY[B &lt;- C] : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">    requires 0 &lt;=Int B andBool B &lt;Int lengthBytes(ARRAY)
</span><span class="noop">             andBool 0 &lt;=Int C andBool C &lt;=Int MAX_UINT8
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; setbyte =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; ARRAY : B : _ &lt;/stack&gt;
</span><span class="noop">    requires 0 &gt;Int B orBool B &gt;=Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; setbyte =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : _ : C : _ &lt;/stack&gt;
</span><span class="noop">    requires 0 &gt;Int C orBool C &gt;Int MAX_UINT8
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Byte-array sub-array extraction*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; extract S L =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; ARRAY : XS =&gt; substrBytes(ARRAY, S, S +Int L) : XS &lt;/stack&gt;
</span><span class="noop">    requires 0 &lt;=Int S andBool S &lt;=Int 255
</span><span class="noop">     andBool 0 &lt;Int L andBool L &lt;=Int 255
</span><span class="noop">     andBool L &lt;=Int lengthBytes(ARRAY)
</span><span class="noop">     andBool S +Int L &lt;=Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="noop">  // If L is 0, then extract to the end of the byte-array.
</span><span class="miss">  rule &lt;k&gt; extract S L =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; ARRAY : XS =&gt; substrBytes(ARRAY, S, lengthBytes(ARRAY)) : XS &lt;/stack&gt;
</span><span class="noop">    requires 0 &lt;=Int S andBool S &lt;=Int 255
</span><span class="noop">     andBool 0 ==Int L
</span><span class="noop">     andBool S &lt;=Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; extract S L =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; ARRAY : _ &lt;/stack&gt;
</span><span class="noop">      requires S &gt;Int lengthBytes(ARRAY)
</span><span class="noop">        orBool S +Int L &gt;Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; extract S L =&gt; panic(INVALID_ARGUMENT) ... &lt;/k&gt;
</span><span class="noop">      requires 0 &gt;Int S orBool S &gt;Int MAX_UINT8
</span><span class="noop">       orBool  0 &gt;Int L orBool L &gt;Int MAX_UINT8
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; extract3 =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; C : B : ARRAY : XS =&gt; substrBytes(ARRAY, B, B +Int C) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">    requires B &lt;=Int lengthBytes(ARRAY)
</span><span class="noop">     andBool B +Int C &lt;=Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; extract3 =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; C : B : ARRAY : _ &lt;/stack&gt;
</span><span class="noop">      requires B &gt;Int lengthBytes(ARRAY)
</span><span class="noop">        orBool B +Int C &gt;Int lengthBytes(ARRAY)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Byte-array uint extraction*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; extract_uint16 =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : ARRAY : XS =&gt;
</span><span class="noop">               Bytes2Int(substrBytes(ARRAY, B, B +Int 2), BE, Unsigned) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires B &lt;=Int lengthBytes(ARRAY)
</span><span class="noop">     andBool B +Int 2 &lt;=Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; extract_uint16 =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : ARRAY : _ &lt;/stack&gt;
</span><span class="noop">      requires B &gt;Int lengthBytes(ARRAY)
</span><span class="noop">        orBool B +Int 2 &gt;Int lengthBytes(ARRAY)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; extract_uint32 =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : ARRAY : XS =&gt;
</span><span class="noop">               Bytes2Int(substrBytes(ARRAY, B, B +Int 4), BE, Unsigned) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires B &lt;=Int lengthBytes(ARRAY)
</span><span class="noop">     andBool B +Int 4 &lt;=Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; extract_uint32 =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : ARRAY : _ &lt;/stack&gt;
</span><span class="noop">      requires B &gt;Int lengthBytes(ARRAY)
</span><span class="noop">        orBool B +Int 4 &gt;Int lengthBytes(ARRAY)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; extract_uint64 =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : ARRAY : XS =&gt;
</span><span class="noop">               Bytes2Int(substrBytes(ARRAY, B, B +Int 8), BE, Unsigned) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires B &lt;=Int lengthBytes(ARRAY)
</span><span class="noop">     andBool B +Int 8 &lt;=Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; extract_uint64 =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : ARRAY : _ &lt;/stack&gt;
</span><span class="noop">      requires B &gt;Int lengthBytes(ARRAY)
</span><span class="noop">        orBool B +Int 8 &gt;Int lengthBytes(ARRAY)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Byte-arrays as big-endian unsigned integers
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">The length of the arguments is limited to `MAX_BYTE_MATH_SIZE`, but there is no restriction on the length of the result.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; OP:MathByteOpCode =&gt; panic(MATH_BYTES_ARG_TOO_LONG) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : _ &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires (lengthBytes(A) &gt;Int MAX_BYTE_MATH_SIZE
</span><span class="noop">      orBool lengthBytes(B) &gt;Int MAX_BYTE_MATH_SIZE)
</span><span class="noop">     andBool notBool(isUnaryLogicalMathByteOpCode(OP))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; _OP:UnaryLogicalMathByteOpCode =&gt; panic(MATH_BYTES_ARG_TOO_LONG) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; A:Bytes : _ &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &gt;Int MAX_BYTE_MATH_SIZE
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">##### Byte-array arithmetic operations
</span><span class="noop">
</span><span class="noop">*Byte-array addition*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; b+ =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : XS =&gt;
</span><span class="noop">               Int2Bytes(Bytes2Int(A, BE, Unsigned) +Int Bytes2Int(B, BE, Unsigned), BE, Unsigned) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Byte-array subtraction*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; b- =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : XS =&gt;
</span><span class="noop">               Int2Bytes(Bytes2Int(A, BE, Unsigned) -Int Bytes2Int(B, BE, Unsigned), BE, Unsigned) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool Bytes2Int(A, BE, Unsigned) -Int Bytes2Int(B, BE, Unsigned) &gt;=Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; b- =&gt; panic(INT_UNDERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : _ &lt;/stack&gt;
</span><span class="noop">    requires Bytes2Int(A, BE, Unsigned) -Int Bytes2Int(B, BE, Unsigned) &lt;Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Byte-array division*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; b/ =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : XS =&gt;
</span><span class="noop">               Int2Bytes(Bytes2Int(A, BE, Unsigned) /Int Bytes2Int(B, BE, Unsigned), BE, Unsigned) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &gt;Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; b/ =&gt; panic(DIV_BY_ZERO) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : _:Bytes : _  &lt;/stack&gt;
</span><span class="noop">    requires Bytes2Int(B, BE, Unsigned) ==Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Byte-array remainder*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; b% =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : XS =&gt;
</span><span class="noop">               Int2Bytes(Bytes2Int(A, BE, Unsigned) %Int Bytes2Int(B, BE, Unsigned), BE, Unsigned) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &gt;Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; b% =&gt; panic(DIV_BY_ZERO) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : _:Bytes : _  &lt;/stack&gt;
</span><span class="noop">    requires Bytes2Int(B, BE, Unsigned) ==Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Byte-array multiplication*
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; b* =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : XS =&gt;
</span><span class="noop">               Int2Bytes(Bytes2Int(A, BE, Unsigned) *Int Bytes2Int(B, BE, Unsigned), BE, Unsigned) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">##### Byte-array relational operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; b&lt; =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : XS =&gt;
</span><span class="noop">               bool2Int (Bytes2Int(A, BE, Unsigned) &lt;Int Bytes2Int(B, BE, Unsigned)) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; b&gt; =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : XS =&gt;
</span><span class="noop">               bool2Int (Bytes2Int(A, BE, Unsigned) &gt;Int Bytes2Int(B, BE, Unsigned)) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; b&lt;= =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : XS =&gt;
</span><span class="noop">               bool2Int (Bytes2Int(A, BE, Unsigned) &lt;=Int Bytes2Int(B, BE, Unsigned)) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; b&gt;= =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : XS =&gt;
</span><span class="noop">               bool2Int (Bytes2Int(A, BE, Unsigned) &gt;=Int Bytes2Int(B, BE, Unsigned)) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; b== =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : XS =&gt;
</span><span class="noop">               bool2Int (Bytes2Int(A, BE, Unsigned) ==Int Bytes2Int(B, BE, Unsigned)) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; b!= =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B:Bytes : A:Bytes : XS =&gt;
</span><span class="noop">               bool2Int (Bytes2Int(A, BE, Unsigned) =/=Int Bytes2Int(B, BE, Unsigned)) : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires lengthBytes(A) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">     andBool lengthBytes(B) &lt;=Int MAX_BYTE_MATH_SIZE
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">##### Byte-array bit-wise boolean operations
</span><span class="noop">
</span><span class="noop">In our model, we diverge form the [reference TEAL interpreter](https://github.com/algorand/go-algorand/blob/master/data/transactions/logic/eval.go) by computing the bit-wise logical operations on byte-arrays via interpreting the arrays as big-endian unsigned unbounded integers.
</span><span class="noop">
</span><span class="noop">We implement the operations as follows:
</span><span class="noop">* interpret the byte-arrays as unsigned big-endian unbounded integers;
</span><span class="noop">* performing the bit-wise operation on the integers;
</span><span class="noop">* convert the result into a byte-array;
</span><span class="noop">* left-pad the result with zeroes to the length of the longest argument, if necessary.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; OP:BinaryLogicalMathByteOpCode =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : A : XS =&gt; BytesBitwiseOp(A, B, OP) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="noop">  syntax Bytes ::= BytesBitwiseOp(Bytes, Bytes, BinaryLogicalMathByteOpCode) [function]
</span><span class="noop">
</span><span class="miss">  rule BytesBitwiseOp(A, B, b|) =&gt;
</span><span class="noop">    padLeftBytes(Int2Bytes(Bytes2Int(A, BE, Unsigned) |Int Bytes2Int(B, BE, Unsigned), BE, Unsigned)
</span><span class="noop">                , maxInt(lengthBytes(A), lengthBytes(B)), 0)
</span><span class="noop">
</span><span class="miss">  rule BytesBitwiseOp(A, B, b&amp;) =&gt;
</span><span class="noop">    padLeftBytes(Int2Bytes(Bytes2Int(A, BE, Unsigned) &amp;Int Bytes2Int(B, BE, Unsigned), BE, Unsigned)
</span><span class="noop">                , maxInt(lengthBytes(A), lengthBytes(B)), 0)
</span><span class="noop">
</span><span class="miss">  rule BytesBitwiseOp(A, B, b^) =&gt;
</span><span class="noop">    padLeftBytes(Int2Bytes(Bytes2Int(A, BE, Unsigned) xorInt Bytes2Int(B, BE, Unsigned), BE, Unsigned)
</span><span class="noop">                , maxInt(lengthBytes(A), lengthBytes(B)), 0)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">We implement the bit-wise complement as the exclusive or of the argument with a byte-array with all bytes set to `0xff`:
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; b~ =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; A : XS =&gt; BytesBitwiseOp(A, padLeftBytes(.Bytes, lengthBytes(A), 255), b^) : XS &lt;/stack&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*Byte-array access and modification*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; getbyte =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : ARRAY : XS =&gt; ARRAY[B] : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires 0 &lt;=Int B andBool B &lt;Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; getbyte =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : ARRAY : _ &lt;/stack&gt;
</span><span class="noop">    requires 0 &gt;Int B orBool B &gt;=Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; setbyte =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; C : B : ARRAY : XS =&gt; ARRAY[B &lt;- C] : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">    requires 0 &lt;=Int B andBool B &lt;Int lengthBytes(ARRAY)
</span><span class="noop">             andBool 0 &lt;=Int C andBool C &lt;=Int MAX_UINT8
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; setbyte =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : ARRAY : _ &lt;/stack&gt;
</span><span class="noop">    requires 0 &gt;Int B orBool B &gt;=Int lengthBytes(ARRAY)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; setbyte =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; C : _ : _ : _ &lt;/stack&gt;
</span><span class="noop">    requires 0 &gt;Int C orBool C &gt;Int MAX_UINT8
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Bit-precise access and modification operations (byte-array and uint64)
</span><span class="noop">
</span><span class="noop">#### `setbit`
</span><span class="noop">
</span><span class="noop">We recite the [specification](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/?from_query=getbit#setbit) of bit order from Algorand Developer Portal.
</span><span class="noop">
</span><span class="noop">&gt; When A is a byte array, index 0 is the leftmost bit of the leftmost byte. Setting bits 0 through 11 to 1 in a 4-byte-array of 0s yields the byte array 0xfff00000. Setting bit 3 to 1 on the 1-byte-array 0x00 yields the byte array 0x10.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss"> rule &lt;k&gt; setbit =&gt; .K ... &lt;/k&gt;
</span><span class="noop">      &lt;stack&gt; C : B : ARRAY:Bytes : XS =&gt; setBitInBytes(ARRAY, B, C) : XS &lt;/stack&gt;
</span><span class="noop">      &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">   requires 0 &lt;=Int B andBool B &lt;Int lengthBytes(ARRAY) *Int 8
</span><span class="noop">    andBool 0 &lt;=Int C andBool C &lt;Int 2
</span><span class="noop">
</span><span class="miss"> rule &lt;k&gt; setbit =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">      &lt;stack&gt; C : _ : _:Bytes : _ &lt;/stack&gt;
</span><span class="noop">   requires notBool (0 &lt;=Int C andBool C &lt;Int 2)
</span><span class="noop">
</span><span class="miss"> rule &lt;k&gt; setbit =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">      &lt;stack&gt; _ : B : ARRAY:Bytes : _ &lt;/stack&gt;
</span><span class="noop">   requires notBool (0 &lt;=Int B andBool B &lt;Int lengthBytes(ARRAY) *Int 8)
</span><span class="noop">
</span><span class="noop">  syntax Bytes ::= setBitInBytes(Bytes, Int, Int) [function]
</span><span class="noop">  //--------------------------------------------------------
</span><span class="miss">  rule setBitInBytes(ARRAY, B, V) =&gt;
</span><span class="noop">         ARRAY[B divInt 8 &lt;- setBitUInt8( ARRAY[B divInt 8]
</span><span class="noop">                                        , 7 -Int B modInt 8
</span><span class="noop">                                        , V)]
</span><span class="noop">
</span><span class="noop">  // Setting and unsetting signle bits in integers via bitwise and/or.
</span><span class="noop">  // If the `requires` clauses are not satisfied, the semantics will
</span><span class="noop">  // get stuck. This should not happen though, since the upstream code
</span><span class="noop">  // panics on invalid arguments.
</span><span class="noop">  syntax Int ::= setBitUInt8 (Int, Int, Int) [function]
</span><span class="noop">               | setBitUInt64(Int, Int, Int) [function]
</span><span class="noop">  //---------------------------------------------------
</span><span class="noop">  // to unset a bit, shift 1 to the desired position and conjunct
</span><span class="miss">  rule setBitUInt8(X, B, 0) =&gt; X &amp;Int (~Int (1 &lt;&lt;Int B))
</span><span class="noop">   requires 0 &lt;=Int X andBool X &lt;=Int MAX_UINT8
</span><span class="noop">    andBool 0 &lt;=Int B andBool B &lt;Int 8
</span><span class="noop">
</span><span class="noop">  // to set a bit, shift 1 to the desired position and disjunct
</span><span class="miss">  rule setBitUInt8(X, B, 1) =&gt; X |Int (1 &lt;&lt;Int B)
</span><span class="noop">   requires 0 &lt;=Int X andBool X &lt;=Int MAX_UINT8
</span><span class="noop">    andBool 0 &lt;=Int B andBool B &lt;Int 8
</span><span class="noop">
</span><span class="noop">  // to unset a bit, shift 1 to the desired position and conjunct
</span><span class="miss">  rule setBitUInt64(X, B, 0) =&gt; X &amp;Int (~Int (1 &lt;&lt;Int B))
</span><span class="noop">   requires 0 &lt;=Int X andBool X &lt;=Int MAX_UINT64
</span><span class="noop">    andBool 0 &lt;=Int B andBool B &lt;Int 64
</span><span class="noop">
</span><span class="noop">  // to set a bit, shift 1 to the desired position and disjunct
</span><span class="miss">  rule setBitUInt64(X, B, 1) =&gt; X |Int (1 &lt;&lt;Int B)
</span><span class="noop">   requires 0 &lt;=Int X andBool X &lt;=Int MAX_UINT64
</span><span class="noop">    andBool 0 &lt;=Int B andBool B &lt;Int 64
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">&gt; When A is a `uint64`, index 0 is the least significant bit. Setting bit 3 to 1 on the integer 0 yields 8, or 2^3.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; setbit =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; C : B : I:Int : XS =&gt; setBitUInt64(I, B, C) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;=Int MAX_UINT64
</span><span class="noop">     andBool 0 &lt;=Int B andBool B &lt;Int 64
</span><span class="noop">     andBool 0 &lt;=Int C andBool C &lt;Int 2
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; setbit =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; C : _ : _:Int : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool (0 &lt;=Int C andBool C &lt;Int 2)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; setbit =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : B : _:Int : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool (0 &lt;=Int B andBool B &lt;Int 64)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### `getbit`
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss"> rule &lt;k&gt; getbit =&gt; .K ... &lt;/k&gt;
</span><span class="noop">      &lt;stack&gt; B : ARRAY:Bytes : XS =&gt; getBitFromBytes(ARRAY, B) : XS &lt;/stack&gt;
</span><span class="noop">      &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires 0 &lt;=Int B andBool B &lt;Int lengthBytes(ARRAY) *Int 8
</span><span class="noop">
</span><span class="miss"> rule &lt;k&gt; getbit =&gt; panic(INDEX_OUT_OF_BOUNDS) &lt;/k&gt;
</span><span class="noop">      &lt;stack&gt; B : ARRAY:Bytes : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool (0 &lt;=Int B andBool B &lt;Int lengthBytes(ARRAY) *Int 8)
</span><span class="noop">
</span><span class="noop">  syntax Int ::= getBitFromBytes(Bytes, Int) [function]
</span><span class="noop">  //---------------------------------------------------
</span><span class="noop">  // TODO: alternatively, we could use a bitmask here like in `setbit`.
</span><span class="noop">  // Let&#39;s see which way causes more problems down the road.
</span><span class="miss">  rule getBitFromBytes(ARRAY, B) =&gt;
</span><span class="noop">      bitRangeInt( ARRAY[B divInt 8]
</span><span class="noop">                 , 7 -Int B modInt 8
</span><span class="noop">                 , 1)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; getbit =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : I:Int : XS =&gt; bitRangeInt(I, B, 1) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;=Int MAX_UINT64 andBool
</span><span class="noop">             0 &lt;=Int B andBool B &lt;Int 64
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; getbit =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; B : _:Int : _  &lt;/stack&gt;
</span><span class="noop">    requires notBool (0 &lt;=Int B andBool B &lt;Int 64)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Constant Loading Operations
</span><span class="noop">
</span><span class="noop">The specs currently define abstractly the semantics of TEAL&#39;s pseudo-ops,
</span><span class="noop">without considering the construction of constant blocks `intcblock` and
</span><span class="noop">`bytecblock` and the injection of `intc` and `bytec` opcodes. The following
</span><span class="noop">rules are thus not used and are kept for reference only.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; intcblock N VL =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;intcblock&gt; _ =&gt; genIntcBlockMap(N, 0, VL) &lt;/intcblock&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; intc I =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;intcblock&gt; INTS  &lt;/intcblock&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; ({INTS[I]}:&gt;TValue) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">     andBool (I:Int in_keys(INTS))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; intc_0 =&gt; intc 0 ... &lt;/k&gt;
</span><span class="miss">  rule &lt;k&gt; intc_1 =&gt; intc 1 ... &lt;/k&gt;
</span><span class="miss">  rule &lt;k&gt; intc_2 =&gt; intc 2 ... &lt;/k&gt;
</span><span class="miss">  rule &lt;k&gt; intc_3 =&gt; intc 3 ... &lt;/k&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; bytecblock N VPL =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;bytecblock&gt; _ =&gt; genBytecBlockMap(N, 0, VPL) &lt;/bytecblock&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; bytec I =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;bytecblock&gt; I |-&gt; V ... &lt;/bytecblock&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; V : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; bytec_0 =&gt; bytec 0 ... &lt;/k&gt;
</span><span class="miss">  rule &lt;k&gt; bytec_1 =&gt; bytec 1 ... &lt;/k&gt;
</span><span class="miss">  rule &lt;k&gt; bytec_2 =&gt; bytec 2 ... &lt;/k&gt;
</span><span class="miss">  rule &lt;k&gt; bytec_3 =&gt; bytec 3 ... &lt;/k&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">The `pushbytes` and `pushint` opcodes push an immediate constant onto stack.
</span><span class="noop">The constants are not added into `bytecblock`/`intcblock` during assembly.
</span><span class="noop">In our spec, `pushbytes` and `pushint` are equivalent to `byte` and `int`.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; pushint I =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; normalizeI(I) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; pushbytes B =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; normalize(B) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Constant Loading Pseudo-Ops
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; addr B =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; normalize(B) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; int I =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; normalizeI(I) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; byte B =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; normalize(B) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; _:PseudoOpCode =&gt; panic(STACK_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Constant Loading Auxiliary Functions
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Map ::= genIntcBlockMap(Int, Int, TValueNeList) [function]
</span><span class="noop">  //---------------------------------------------------------------
</span><span class="miss">  rule genIntcBlockMap(N, I, V VL) =&gt;
</span><span class="noop">         I |-&gt; V
</span><span class="noop">         genIntcBlockMap(N -Int 1, I +Int 1, VL)
</span><span class="noop">    requires N &gt;Int 1
</span><span class="noop">
</span><span class="miss">  rule genIntcBlockMap(1, I, V) =&gt; I |-&gt; V
</span><span class="noop">
</span><span class="noop">  syntax Map ::= genBytecBlockMap(Int, Int, TValuePairNeList) [function]
</span><span class="noop">  //--------------------------------------------------------------------
</span><span class="noop">  // Note: byte array size is ignored
</span><span class="miss">  rule genBytecBlockMap(N, I, (_, V) VPL) =&gt;
</span><span class="noop">         I |-&gt; V
</span><span class="noop">         genBytecBlockMap(N -Int 1, I +Int 1, VPL)
</span><span class="noop">    requires N &gt;Int 1
</span><span class="noop">
</span><span class="miss">  rule genBytecBlockMap(1, I, (_, V)) =&gt; I |-&gt; V
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Flow Control
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; bnz L =&gt; jump(L) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I &gt;Int 0
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; bnz _ =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I &lt;=Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; bz L =&gt; jump(L) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I &lt;=Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; bz _ =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires I &gt;Int 0
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; b L =&gt; jump(L) ... &lt;/k&gt;
</span><span class="noop">
</span><span class="noop">  // TODO: `return` used to consume the rest of the `&lt;k&gt;` cell. Now we have to preceed,
</span><span class="noop">  //       but we will need to make sure that TEAL execution stops here, so
</span><span class="noop">  //       we erase only the items of sort `TealExecutionOp`.
</span><span class="hit">   rule &lt;k&gt; return ~&gt; #incrementPC() ~&gt; #fetchOpcode() =&gt; #finalizeExecution() ... &lt;/k&gt;
</span><span class="noop">        &lt;stack&gt; (I:Int) : _XS =&gt; I : .TStack &lt;/stack&gt;
</span><span class="noop">        &lt;stacksize&gt; _ =&gt; 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; _: =&gt; .K ... &lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; assert =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (X:Int) : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires X &gt;Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; assert =&gt; panic(ASSERTION_VIOLATION) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (X:Int) : _ &lt;/stack&gt;
</span><span class="noop">    requires X ==Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; assert =&gt; panic(IMPOSSIBLE_NEGATIVE_NUMBER) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (X:Int) : _ &lt;/stack&gt;
</span><span class="noop">    requires X &lt;Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Jump internal rules
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax KItem ::= jump(Label)
</span><span class="noop">  //--------------------------
</span><span class="hit">  rule &lt;k&gt; jump(L) =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;pc&gt; _ =&gt; getLabelAddress(L) &lt;/pc&gt;
</span><span class="noop">       &lt;jumped&gt; _ =&gt; true &lt;/jumped&gt;
</span><span class="noop">       &lt;labels&gt; LL &lt;/labels&gt;
</span><span class="noop">    requires L in_labels LL
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; jump(L) =&gt; panic(ILLEGAL_JUMP) ... &lt;/k&gt;
</span><span class="noop">       &lt;labels&gt; LL &lt;/labels&gt;
</span><span class="noop">    requires notBool (L in_labels LL)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Subroutine call internal rules
</span><span class="noop">
</span><span class="noop">A subroutine call in TEAL performs an unconditional jump to a target label and
</span><span class="noop">records the next program counter value on the call stack.
</span><span class="noop">
</span><span class="noop">Subroutines share the regular `&lt;stack&gt;` and `&lt;scratch&gt;` with the main TEAL program. Either could be used to pass arguments or return results.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; callsub TARGET =&gt; callSubroutine(TARGET) ... &lt;/k&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; retsub =&gt; returnSubroutine() ... &lt;/k&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= callSubroutine(Label)
</span><span class="noop">  //------------------------------------
</span><span class="noop">  // TODO: what happens if the pc value after call is invalid? What to do? Terminate or panic?
</span><span class="noop">  // For now we do nothing, and thus trigger termination via `#fetchInstruction()`.
</span><span class="miss">  rule &lt;k&gt; callSubroutine(TARGET) =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;pc&gt; PC =&gt; getLabelAddress(TARGET) &lt;/pc&gt;
</span><span class="noop">       &lt;jumped&gt; _ =&gt; true &lt;/jumped&gt;
</span><span class="noop">       &lt;labels&gt; LL &lt;/labels&gt;
</span><span class="noop">       &lt;callStack&gt; XS =&gt; ListItem(PC +Int 1) XS &lt;/callStack&gt;
</span><span class="noop">    requires  (TARGET in_labels LL)
</span><span class="noop">      andBool (size(XS) &lt;Int MAX_CALLSTACK_DEPTH)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; callSubroutine(_TARGET) =&gt; panic(CALLSTACK_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;callStack&gt; XS &lt;/callStack&gt;
</span><span class="noop">    requires size(XS) &gt;=Int MAX_CALLSTACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; callSubroutine(TARGET) =&gt; panic(ILLEGAL_JUMP) ... &lt;/k&gt;
</span><span class="noop">       &lt;labels&gt; LL &lt;/labels&gt;
</span><span class="noop">    requires notBool(TARGET in_labels LL)
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= returnSubroutine()
</span><span class="noop">  //---------------------------------
</span><span class="miss">  rule &lt;k&gt; returnSubroutine() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;pc&gt; _ =&gt; RETURN_PC &lt;/pc&gt;
</span><span class="noop">       &lt;jumped&gt; _ =&gt; true &lt;/jumped&gt;
</span><span class="noop">       &lt;callStack&gt; ListItem(RETURN_PC) XS =&gt; XS &lt;/callStack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; returnSubroutine() =&gt; panic(CALLSTACK_UNDERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;pc&gt; _ &lt;/pc&gt;
</span><span class="noop">       &lt;callStack&gt; .List &lt;/callStack&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Stack Manipulation
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; pop =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; dup =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; X : XS =&gt; X : X : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; dup =&gt; panic(STACK_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; dup2 =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; V2 : V1 : XS =&gt; V2 : V1 : V2 : V1 : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 2 &lt;/stacksize&gt;
</span><span class="noop">    requires S +Int 1 &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; dup2 =&gt; panic(STACK_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S +Int 1 &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; dig N =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; STACK =&gt; STACK[N]:STACK &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH andBool
</span><span class="noop">             0 &lt;=Int N andBool N &lt;Int S
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; dig _ =&gt; panic(STACK_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; dig N =&gt; panic(STACK_UNDERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires notBool (0 &lt;=Int N andBool N &lt;Int S)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; cover N =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; X : STACK =&gt; #take(N, STACK) (X : #drop(N, STACK)) &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires 0 &lt;=Int N andBool N &lt;Int S
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; cover N =&gt; panic(STACK_UNDERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires notBool (0 &lt;=Int N andBool N &lt;Int S)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; uncover N =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; STACK =&gt; STACK [ N ] : (#take(N, STACK) #drop(N +Int 1, STACK)) &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires 0 &lt;=Int N andBool N &lt;Int S
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; uncover N =&gt; panic(STACK_UNDERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires notBool (0 &lt;=Int N andBool N &lt;Int S)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; swap =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; X : Y : XS =&gt; Y : X : XS &lt;/stack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; swap =&gt; panic(STACK_UNDERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _:.TStack &lt;/stack&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; select =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; A : B : _ : XS =&gt;
</span><span class="noop">               B : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">    requires int2Bool(A)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; select =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; A : _ : C : XS =&gt;
</span><span class="noop">               C : XS
</span><span class="noop">       &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">    requires notBool (int2Bool(A))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Blockchain State Accessors
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; txn I =&gt; gtxn getTxnGroupIndex(getCurrentTxn()) I ... &lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; txn I J =&gt; txna I J ... &lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; gtxn G I =&gt; loadFromGroup(G, I) ... &lt;/k&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; gtxns I =&gt; loadFromGroup(G, I) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; G : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; txna I J =&gt; gtxna getTxnGroupIndex(getCurrentTxn()) I J ... &lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; txnas I =&gt; gtxnas getTxnGroupIndex(getCurrentTxn()) I ... &lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; gtxna G I J =&gt; loadFromGroup(G, I, J) ... &lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; gtxnas G I =&gt; loadFromGroup(G, I, J) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; J : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; gtxnsa I J =&gt; loadFromGroup(G, I, J) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; G : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; gtxnsas I =&gt; loadFromGroup(G, I, J) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; J : G : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; global I =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; getGlobalField(I) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; _:BlockchainOpCode =&gt; panic(STACK_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= loadFromGroup(Int, TxnField)
</span><span class="noop">  //-------------------------------------------
</span><span class="hit">  rule &lt;k&gt; loadFromGroup(GROUP_IDX, FIELD) =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; {getGroupFieldByIdx(GROUP_ID, GROUP_IDX, FIELD)}:&gt;TValue : XS &lt;/stack&gt;
</span><span class="noop">       &lt;currentTx&gt; CURRENT_TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; CURRENT_TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">         &lt;groupIdx&gt; CURRENT_GROUP_IDX &lt;/groupIdx&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires isTValue(getGroupFieldByIdx(GROUP_ID, GROUP_IDX, FIELD))
</span><span class="noop">    andBool    S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">    andBool    (notBool(isTxnDynamicField(FIELD))
</span><span class="noop">    orElseBool GROUP_IDX &lt;Int (CURRENT_GROUP_IDX))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; loadFromGroup(GROUP_IDX, _:TxnDynamicField) =&gt; panic(FUTURE_TXN) ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; CURRENT_TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; CURRENT_TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupIdx&gt; CURRENT_GROUP_IDX &lt;/groupIdx&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires GROUP_IDX &gt;=Int CURRENT_GROUP_IDX
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; loadFromGroup(_, _) =&gt; panic(STACK_OVERFLOW) ...&lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; loadFromGroup(GROUP_IDX, FIELD) =&gt; panic(TXN_ACCESS_FAILED) ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; CURRENT_TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; CURRENT_TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires notBool(isTValue(getGroupFieldByIdx(GROUP_ID, GROUP_IDX, FIELD)))
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= loadFromGroup(Int, TxnaField, Int)
</span><span class="noop">  //-------------------------------------------------
</span><span class="hit">  rule &lt;k&gt; loadFromGroup(GROUP_IDX, FIELD, IDX) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; {getGroupFieldByIdx(GROUP_ID, GROUP_IDX, FIELD, IDX)}:&gt;TValue : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;currentTx&gt; CURRENT_TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; CURRENT_TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">         &lt;groupIdx&gt; CURRENT_GROUP_IDX &lt;/groupIdx&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires   isTValue(getGroupFieldByIdx(GROUP_ID, GROUP_IDX, FIELD, IDX))
</span><span class="noop">    andBool    S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">    andBool    (notBool(isTxnaDynamicField(FIELD))
</span><span class="noop">    orElseBool GROUP_IDX &lt;Int CURRENT_GROUP_IDX)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; loadFromGroup(GROUP_IDX, _:TxnaDynamicField, _) =&gt; panic(FUTURE_TXN) ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; CURRENT_TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; CURRENT_TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupIdx&gt; CURRENT_GROUP_IDX &lt;/groupIdx&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires GROUP_IDX &gt;=Int CURRENT_GROUP_IDX
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; loadFromGroup(_, _, _) =&gt; panic(STACK_OVERFLOW) ...&lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; loadFromGroup(GROUP_IDX, FIELD, IDX) =&gt; panic(TXN_ACCESS_FAILED) ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; CURRENT_TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; CURRENT_TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires   notBool(isTValue(getGroupFieldByIdx(GROUP_ID, GROUP_IDX, FIELD, IDX)))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; load I =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; ({M[I]}:&gt;TValue) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;scratch&gt; M &lt;/scratch&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;Int MAX_SCRATCH_SIZE
</span><span class="noop">     andBool I in_keys(M)
</span><span class="noop">     andBool S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; load I =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; 0 : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;scratch&gt; M =&gt; M[I &lt;- 0] &lt;/scratch&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;Int MAX_SCRATCH_SIZE
</span><span class="noop">     andBool notBool (I in_keys(M))
</span><span class="noop">     andBool S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; store I =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; V : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;scratch&gt; M =&gt; M[I &lt;- V] &lt;/scratch&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;Int MAX_SCRATCH_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; load I =&gt; panic(INVALID_SCRATCH_LOC) ... &lt;/k&gt;
</span><span class="noop">    requires I &lt;Int 0 orBool I &gt;=Int MAX_SCRATCH_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; load _ =&gt; panic(STACK_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; store I =&gt; panic(INVALID_SCRATCH_LOC) ... &lt;/k&gt;
</span><span class="noop">    requires I &lt;Int 0 orBool I &gt;=Int MAX_SCRATCH_SIZE
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; loads =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : XS =&gt; ({M[I]}:&gt;TValue) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;scratch&gt; M &lt;/scratch&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;Int MAX_SCRATCH_SIZE
</span><span class="noop">     andBool I in_keys(M)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; loads =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : XS =&gt; 0 : XS &lt;/stack&gt;
</span><span class="noop">       &lt;scratch&gt; M &lt;/scratch&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;Int MAX_SCRATCH_SIZE
</span><span class="noop">     andBool notBool(I in_keys(M))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; loads =&gt; panic(INVALID_SCRATCH_LOC) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : _ &lt;/stack&gt;
</span><span class="noop">    requires I &lt;Int 0 orBool I &gt;=Int MAX_SCRATCH_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; stores =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; V : I : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">       &lt;scratch&gt; M =&gt; M[I &lt;- V] &lt;/scratch&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;Int MAX_SCRATCH_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; stores =&gt; panic(INVALID_SCRATCH_LOC) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : I : _ &lt;/stack&gt;
</span><span class="noop">    requires I &lt;Int 0 orBool I &gt;=Int MAX_SCRATCH_SIZE
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Stateless TEAL Operations
</span><span class="noop">-------------------------
</span><span class="noop">
</span><span class="noop">### Logic Signature Argument Accessors
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">//  rule &lt;k&gt; arg I =&gt; .K ... &lt;/k&gt;
</span><span class="noop">//       &lt;stack&gt; XS =&gt; ({getArgument(I)}:&gt;TValue) : XS &lt;/stack&gt;
</span><span class="noop">//       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">//    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">//     andBool isTValue(getArgument(I))
</span><span class="noop">//
</span><span class="noop">//  rule &lt;k&gt; args =&gt; .K ... &lt;/k&gt;
</span><span class="noop">//       &lt;stack&gt; I : XS =&gt; ({getArgument(I)}:&gt;TValue) : XS &lt;/stack&gt;
</span><span class="noop">//    requires isTValue(getArgument(I))
</span><span class="noop">//
</span><span class="noop">//  rule &lt;k&gt; arg I =&gt; panic(INDEX_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">//       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">//    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">//     andBool notBool (isTValue(getArgument(I)))
</span><span class="noop">//
</span><span class="noop">//  rule &lt;k&gt; arg _ =&gt; panic(STACK_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">//       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">//    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">//
</span><span class="noop">//  rule &lt;k&gt; arg_0 =&gt; arg 0 ... &lt;/k&gt;
</span><span class="noop">//  rule &lt;k&gt; arg_1 =&gt; arg 1 ... &lt;/k&gt;
</span><span class="noop">//  rule &lt;k&gt; arg_2 =&gt; arg 2 ... &lt;/k&gt;
</span><span class="noop">//  rule &lt;k&gt; arg_3 =&gt; arg 3 ... &lt;/k&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Stateful TEAL Operations
</span><span class="noop">------------------------
</span><span class="noop">
</span><span class="noop">### Application State Accessors
</span><span class="noop">
</span><span class="noop">*balance*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; balance =&gt; #balance getAccountParamsField(AcctBalance, {accountReference(A)}:&gt;TValue) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires isTValue(accountReference(A))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; balance =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool isTValue(accountReference(A))
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#balance&#34; MaybeTValue
</span><span class="noop">  
</span><span class="hit">  rule &lt;k&gt; #balance BAL:TUInt64 =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : XS =&gt; BAL : XS &lt;/stack&gt;
</span><span class="noop">      
</span><span class="miss">  rule &lt;k&gt; #balance _ =&gt; panic(TXN_ACCESS_FAILED) &lt;/k&gt;  [owise]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*min_balance*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; min_balance =&gt; #min_balance getAccountParamsField(AcctMinBalance, {accountReference(A)}:&gt;TValue) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires isTValue(accountReference(A))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; min_balance =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool isTValue(accountReference(A))
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#min_balance&#34; MaybeTValue
</span><span class="noop">  
</span><span class="hit">  rule &lt;k&gt; #min_balance MIN_BAL:TUInt64 =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : XS =&gt; MIN_BAL : XS &lt;/stack&gt;
</span><span class="noop">      
</span><span class="miss">  rule &lt;k&gt; #min_balance _ =&gt; panic(TXN_ACCESS_FAILED) &lt;/k&gt;  [owise]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*log*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; log =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (MSG:TBytes : XS) =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;currentTx&gt; TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;logData&gt; LOG =&gt; append(MSG, LOG) &lt;/logData&gt;
</span><span class="noop">         &lt;logSize&gt; SIZE =&gt; SIZE +Int lengthBytes({MSG}:&gt;Bytes) &lt;/logSize&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires size(LOG) &lt;Int PARAM_MAX_LOG_CALLS
</span><span class="noop">
</span><span class="miss">   rule &lt;k&gt; log =&gt; panic(ILL_TYPED_STACK) ...&lt;/k&gt;
</span><span class="noop">        &lt;stack&gt; _:TUInt64 : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="hit">   rule &lt;k&gt; log =&gt; panic(LOG_CALLS_EXCEEDED) ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;logData&gt; LOG &lt;/logData&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires size(LOG) &gt;=Int PARAM_MAX_LOG_CALLS
</span><span class="noop">
</span><span class="hit">   rule &lt;k&gt; log =&gt; panic(LOG_SIZE_EXCEEDED) ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;logSize&gt; SIZE &lt;/logSize&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires SIZE &gt;=Int PARAM_MAX_LOG_SIZE
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*app_opted_in*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; app_opted_in =&gt;
</span><span class="noop">           #app_opted_in hasOptedInApp({appReference(APP)}:&gt;TValue, {accountReference(A)}:&gt;TValue) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (APP:Int) : (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires isTValue(appReference(APP)) andBool isTValue(accountReference(A))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; app_opted_in  =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; APP:Int : A:TValue : _:TStack &lt;/stack&gt;
</span><span class="noop">    requires notBool (isTValue(appReference(APP)) andBool isTValue(accountReference(A)))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; app_opted_in =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _:TBytes : _:TValue : _:TStack &lt;/stack&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#app_opted_in&#34; Bool
</span><span class="noop">  //-----------------------------------
</span><span class="hit">  rule &lt;k&gt; #app_opted_in B =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : _ : XS =&gt; (#if B #then 1 #else 0 #fi) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*app_local_get*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; app_local_get =&gt;
</span><span class="noop">           #app_local_get getAppLocal({accountReference(A)}:&gt;TValue
</span><span class="noop">                                     , getGlobalField(CurrentApplicationID), KEY) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (KEY:Bytes) : (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires isTValue(accountReference(A))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; app_local_get =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool isTValue(accountReference(A))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_local_get =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _:TUInt64 : _ : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#app_local_get&#34; MaybeTValue
</span><span class="noop">  //--------------------------------------
</span><span class="hit">  rule &lt;k&gt; #app_local_get V:TValue =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : _ : XS =&gt; V : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires (notBool isInt(V)) orElseBool {V}:&gt;Int &gt;=Int 0
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#app_local_get&#34; MaybeTValue
</span><span class="noop">  //--------------------------------------
</span><span class="hit">  rule &lt;k&gt; #app_local_get V:TValue =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : _ : XS =&gt; 0 : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires isInt(V) andThenBool {V}:&gt;Int &lt;Int 0
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #app_local_get NoTValue =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*app_local_get_ex*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; app_local_get_ex =&gt;
</span><span class="noop">           #app_local_get_ex getAppLocal({accountReference(A)}:&gt;TValue, {appReference(APP)}:&gt;TValue, KEY) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (KEY:Bytes) : (APP:TUInt64) : (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires isTValue(accountReference(A)) andBool isTValue(appReference(APP))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; app_local_get_ex =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : (APP:TUInt64) : (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool (isTValue(accountReference(A)) andBool isTValue(appReference(APP)))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_local_get_ex =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (KEY:TValue) : (APP:TValue) : (_:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires isInt(KEY) orBool isBytes(APP)
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#app_local_get_ex&#34; MaybeTValue
</span><span class="noop">  //-----------------------------------------
</span><span class="hit">  rule &lt;k&gt; #app_local_get_ex V =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : _ : _ : XS =&gt; 1 : V : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires (notBool isInt(V)) orElseBool {V}:&gt;Int &gt;=Int 0
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #app_local_get_ex V =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : _ : _ : XS =&gt; 0 : 0 : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires isInt(V) andThenBool {V}:&gt;Int &lt;Int 0
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #app_local_get_ex NoTValue =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*app_local_put*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Int ::= getLocalByteLimit(Int) [function]
</span><span class="hit">  rule [[ getLocalByteLimit(APP) =&gt; X ]]
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;localNumBytes&gt; X &lt;/localNumBytes&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">
</span><span class="noop">  syntax Int ::= getLocalIntLimit(Int) [function]
</span><span class="hit">  rule [[ getLocalIntLimit(APP) =&gt; X ]]
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;localNumInts&gt; X &lt;/localNumInts&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; app_local_put =&gt; #app_local_put {accountReference(A)}:&gt;TValue
</span><span class="noop">                                           getGlobalField(CurrentApplicationID) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:TValue) : (_:Bytes) : (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires isTValue(accountReference(A))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_local_put =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:TValue) : (_:Bytes) : (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool isTValue(accountReference(A))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_local_put =&gt; panic(ILL_TYPED_STACK) ...  &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _:TValue : _:TUInt64 : _:TValue : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#app_local_put&#34; TValue TValue
</span><span class="noop">  //---------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #app_local_put ADDR APP =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:Int) : (KEY:Bytes) : _ : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 3 &lt;/stacksize&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           &lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt; APP &lt;/optInAppID&gt;
</span><span class="noop">             &lt;localInts&gt; MI =&gt; MI[KEY &lt;- NEWVAL] &lt;/localInts&gt;
</span><span class="noop">             &lt;localBytes&gt; MB =&gt; MB[KEY &lt;- undef]  &lt;/localBytes&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInApp&gt; ...
</span><span class="noop">         &lt;/appsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires size(MI[KEY &lt;- NEWVAL]) &lt;=Int getLocalIntLimit(APP)
</span><span class="noop">     andBool lengthBytes(KEY) &lt;=Int PARAM_MAX_KEY_SIZE
</span><span class="noop">     andBool lengthBytes(KEY) +Int sizeInBytes(NEWVAL) &lt;=Int PARAM_MAX_SUM_KEY_VALUE_SIZE
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #app_local_put ADDR APP =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:Bytes) : (KEY:Bytes) : _ : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 3 &lt;/stacksize&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           &lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt; APP &lt;/optInAppID&gt;
</span><span class="noop">             &lt;localInts&gt; MI =&gt; MI[KEY &lt;- undef] &lt;/localInts&gt;
</span><span class="noop">             &lt;localBytes&gt; MB =&gt; MB[KEY &lt;- NEWVAL] &lt;/localBytes&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInApp&gt; ...
</span><span class="noop">         &lt;/appsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires size(MB[KEY &lt;- NEWVAL]) &lt;=Int getLocalByteLimit(APP)
</span><span class="noop">     andBool lengthBytes(KEY) &lt;=Int PARAM_MAX_KEY_SIZE
</span><span class="noop">     andBool lengthBytes(KEY) +Int sizeInBytes(NEWVAL) &lt;=Int PARAM_MAX_SUM_KEY_VALUE_SIZE
</span><span class="noop">     andBool lengthBytes(NEWVAL) &lt;=Int PARAM_MAX_BYTE_VALUE_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #app_local_put _ _ =&gt; panic(KEY_TOO_LARGE) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : (KEY:Bytes) : _ : _ &lt;/stack&gt;
</span><span class="noop">    requires lengthBytes(KEY) &gt;Int PARAM_MAX_KEY_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #app_local_put _ _ =&gt; panic(KEY_VALUE_TOO_LARGE) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:TValue) : (KEY:Bytes) : _ : _ &lt;/stack&gt;
</span><span class="noop">    requires lengthBytes(KEY) +Int sizeInBytes(NEWVAL) &gt;Int PARAM_MAX_SUM_KEY_VALUE_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #app_local_put _ _ =&gt; panic(BYTE_VALUE_TOO_LARGE) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:Bytes) : _ : _ : _ &lt;/stack&gt;
</span><span class="noop">    requires lengthBytes(NEWVAL) &gt;Int PARAM_MAX_BYTE_VALUE_SIZE
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #app_local_put ADDR APP =&gt; panic(LOCAL_INTS_EXCEEDED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:Int) : (KEY:Bytes) : _ : _ &lt;/stack&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           &lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt; APP &lt;/optInAppID&gt;
</span><span class="noop">             &lt;localInts&gt; M &lt;/localInts&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInApp&gt; ...
</span><span class="noop">         &lt;/appsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires size(M[KEY &lt;- NEWVAL]) &gt;Int getLocalIntLimit(APP)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #app_local_put ADDR APP =&gt; panic(LOCAL_BYTES_EXCEEDED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:Bytes) : (KEY:Bytes) : _ : _ &lt;/stack&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           &lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt; APP &lt;/optInAppID&gt;
</span><span class="noop">             &lt;localBytes&gt; M &lt;/localBytes&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInApp&gt; ...
</span><span class="noop">         &lt;/appsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires size(M[KEY &lt;- NEWVAL]) &gt;Int getLocalByteLimit(APP)
</span><span class="noop">
</span><span class="noop">  // if the account exists but is not opted in, panic
</span><span class="hit">  rule &lt;k&gt; #app_local_put ADDR APP =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : _ : _ : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 3 &lt;/stacksize&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt; OA &lt;/appsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires notBool (APP in_optedInApps(&lt;appsOptedIn&gt; OA &lt;/appsOptedIn&gt;))
</span><span class="noop">
</span><span class="noop">  // if the account doesn&#39;t exist, panic
</span><span class="miss">  rule &lt;k&gt; #app_local_put ADDR _ =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : _ : _ : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 3 &lt;/stacksize&gt;
</span><span class="noop">       &lt;accountsMap&gt; AMAP  &lt;/accountsMap&gt;
</span><span class="noop">    requires notBool (ADDR in_accounts(&lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*app_local_del*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; app_local_del =&gt; #app_local_del {accountReference(A)}:&gt;TValue
</span><span class="noop">                                           getGlobalField(CurrentApplicationID) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires isTValue(accountReference(A))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_local_del =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes ) : (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool isTValue(accountReference(A))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_local_del =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _:TUInt64 : _ : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#app_local_del&#34; TValue TValue
</span><span class="noop">  //---------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #app_local_del ADDR APP =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (KEY:Bytes) : _ : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt;
</span><span class="noop">           &lt;optInApp&gt;
</span><span class="noop">             &lt;optInAppID&gt; APP &lt;/optInAppID&gt;
</span><span class="noop">             &lt;localInts&gt; MI =&gt; MI[KEY &lt;- undef] &lt;/localInts&gt; 
</span><span class="noop">             &lt;localBytes&gt; MB =&gt; MB[KEY &lt;- undef] &lt;/localBytes&gt; 
</span><span class="noop">             ...
</span><span class="noop">           &lt;/optInApp&gt; ...
</span><span class="noop">         &lt;/appsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">
</span><span class="noop">  // if the account exists but is not opted in, panic.
</span><span class="miss">  rule &lt;k&gt; #app_local_del ADDR APP =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;account&gt;
</span><span class="noop">         &lt;address&gt; ADDR &lt;/address&gt;
</span><span class="noop">         &lt;appsOptedIn&gt; OA &lt;/appsOptedIn&gt; ...
</span><span class="noop">       &lt;/account&gt;
</span><span class="noop">    requires notBool (APP in_optedInApps(&lt;appsOptedIn&gt; OA &lt;/appsOptedIn&gt;))
</span><span class="noop">
</span><span class="noop">  // if the account doesn&#39;t exist, panic.
</span><span class="miss">  rule &lt;k&gt; #app_local_del ADDR _ =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;accountsMap&gt; AMAP  &lt;/accountsMap&gt;
</span><span class="noop">    requires notBool (ADDR in_accounts(&lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*app_global_get*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; app_global_get =&gt;
</span><span class="noop">           #app_global_get getAppGlobal(getGlobalField(CurrentApplicationID), KEY) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (KEY:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#app_global_get&#34; TValue
</span><span class="noop">  //---------------------------------------
</span><span class="hit">  rule &lt;k&gt; #app_global_get V =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : XS =&gt; V : XS &lt;/stack&gt;
</span><span class="noop">    requires (notBool isInt(V)) orElseBool {V}:&gt;Int &gt;=Int 0
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #app_global_get V =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : XS =&gt; 0 : XS &lt;/stack&gt;
</span><span class="noop">    requires isInt(V) andThenBool {V}:&gt;Int &lt;Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*app_global_get_ex*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; app_global_get_ex =&gt;
</span><span class="noop">           #app_global_get_ex getAppGlobal({appReference(APP)}:&gt;TValue, KEY) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (KEY:Bytes) : (APP:TUInt64) : _ &lt;/stack&gt;
</span><span class="noop">    requires isTValue(appReference(APP))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; app_global_get_ex =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : (APP:TUInt64) : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool isTValue(appReference(APP))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_global_get_ex =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (KEY:TValue) : (I:TValue):_ &lt;/stack&gt;
</span><span class="noop">    requires isInt(KEY) orBool isBytes(I)
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#app_global_get_ex&#34; TValue
</span><span class="noop">  //------------------------------------------
</span><span class="hit">  rule &lt;k&gt; #app_global_get_ex V  =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : (_:TUInt64) : XS =&gt; 1 : V : XS &lt;/stack&gt;
</span><span class="noop">    requires (notBool isInt(V)) orElseBool {V}:&gt;Int &gt;=Int 0
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #app_global_get_ex V =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : (_:TUInt64) : XS =&gt; 0 : 0 : XS &lt;/stack&gt;
</span><span class="noop">    requires isInt(V) andThenBool {V}:&gt;Int &lt;Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*app_global_put*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; app_global_put =&gt; #app_global_put getGlobalField(CurrentApplicationID) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:TValue) : (_:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#app_global_put&#34; TValue
</span><span class="noop">  //---------------------------------------
</span><span class="hit">  rule &lt;k&gt; #app_global_put APP =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:Int) : (KEY:Bytes) : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;globalState&gt;
</span><span class="noop">           &lt;globalInts&gt; MI =&gt; MI[KEY &lt;- NEWVAL] &lt;/globalInts&gt;
</span><span class="noop">           &lt;globalBytes&gt; MB =&gt; MB[KEY &lt;- undef] &lt;/globalBytes&gt;
</span><span class="noop">           &lt;globalNumInts&gt;    GLOBAL_INTS &lt;/globalNumInts&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/globalState&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">    requires size(MI[KEY &lt;- NEWVAL]) &lt;=Int GLOBAL_INTS
</span><span class="noop">     andBool lengthBytes(KEY) &lt;=Int PARAM_MAX_KEY_SIZE
</span><span class="noop">     andBool lengthBytes(KEY) +Int sizeInBytes(NEWVAL) &lt;=Int PARAM_MAX_SUM_KEY_VALUE_SIZE
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #app_global_put APP =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:Bytes) : (KEY:Bytes) : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;globalState&gt;
</span><span class="noop">           &lt;globalInts&gt; MI =&gt; MI[KEY &lt;- undef] &lt;/globalInts&gt;
</span><span class="noop">           &lt;globalBytes&gt; MB =&gt; MB[KEY &lt;- NEWVAL] &lt;/globalBytes&gt;
</span><span class="noop">           &lt;globalNumBytes&gt;   GLOBAL_BYTES &lt;/globalNumBytes&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/globalState&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">    requires size(MB[KEY &lt;- NEWVAL]) &lt;=Int GLOBAL_BYTES
</span><span class="noop">     andBool lengthBytes(KEY) &lt;=Int PARAM_MAX_KEY_SIZE
</span><span class="noop">     andBool lengthBytes(KEY) +Int sizeInBytes(NEWVAL) &lt;=Int PARAM_MAX_SUM_KEY_VALUE_SIZE
</span><span class="noop">     andBool lengthBytes(NEWVAL) &lt;=Int PARAM_MAX_BYTE_VALUE_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #app_global_put _ =&gt; panic(KEY_TOO_LARGE) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ : (KEY:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">    requires lengthBytes(KEY) &gt;Int PARAM_MAX_KEY_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #app_global_put _ =&gt; panic(KEY_VALUE_TOO_LARGE) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:TValue) : (KEY:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">    requires lengthBytes(KEY) +Int sizeInBytes(NEWVAL) &gt;Int PARAM_MAX_SUM_KEY_VALUE_SIZE
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #app_global_put _ =&gt; panic(BYTE_VALUE_TOO_LARGE) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:Bytes) : _ : _ &lt;/stack&gt;
</span><span class="noop">    requires lengthBytes(NEWVAL) &gt;Int PARAM_MAX_BYTE_VALUE_SIZE
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #app_global_put APP =&gt; panic(GLOBAL_INTS_EXCEEDED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:Int) : (KEY:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;globalState&gt;
</span><span class="noop">           &lt;globalInts&gt; M &lt;/globalInts&gt;
</span><span class="noop">           &lt;globalNumInts&gt;    GLOBAL_INTS &lt;/globalNumInts&gt;
</span><span class="noop">           &lt;globalNumBytes&gt;   _ &lt;/globalNumBytes&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/globalState&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">    requires size(M[KEY &lt;- NEWVAL]) &gt;Int GLOBAL_INTS
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #app_global_put APP =&gt; panic(GLOBAL_BYTES_EXCEEDED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (NEWVAL:Bytes) : (KEY:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">       &lt;app&gt;
</span><span class="noop">         &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">         &lt;globalState&gt;
</span><span class="noop">           &lt;globalBytes&gt; M &lt;/globalBytes&gt;
</span><span class="noop">           &lt;globalNumInts&gt;    _ &lt;/globalNumInts&gt;
</span><span class="noop">           &lt;globalNumBytes&gt;   GLOBAL_BYTES &lt;/globalNumBytes&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/globalState&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/app&gt;
</span><span class="noop">    requires size(M[KEY &lt;- NEWVAL]) &gt;Int GLOBAL_BYTES
</span><span class="noop">
</span><span class="noop">  // if the app doesn&#39;t exist, do nothing
</span><span class="miss">  rule &lt;k&gt; #app_global_put APP =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:TValue) : (_:Bytes) : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">       &lt;accountsMap&gt; AMAP  &lt;/accountsMap&gt;
</span><span class="noop">    requires notBool (APP in_apps(&lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*app_global_del*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; app_global_del =&gt; #app_global_del getGlobalField(CurrentApplicationID) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#app_global_del&#34; TValue
</span><span class="noop">  //---------------------------------------
</span><span class="miss">  rule &lt;k&gt; #app_global_del APP =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (KEY:Bytes) : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;appsCreated&gt;
</span><span class="noop">         &lt;app&gt;
</span><span class="noop">           &lt;appID&gt; APP &lt;/appID&gt;
</span><span class="noop">           &lt;globalState&gt;
</span><span class="noop">             &lt;globalInts&gt; MI =&gt; MI[KEY &lt;- undef] &lt;/globalInts&gt;
</span><span class="noop">             &lt;globalBytes&gt; MB =&gt; MB[KEY &lt;- undef] &lt;/globalBytes&gt;
</span><span class="noop">             ...
</span><span class="noop">           &lt;/globalState&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/app&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/appsCreated&gt;
</span><span class="noop">
</span><span class="noop">  // if the app doesn&#39;t exist, do nothing
</span><span class="miss">  rule &lt;k&gt; #app_global_del APP =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;accountsMap&gt; AMAP  &lt;/accountsMap&gt;
</span><span class="noop">    requires notBool (APP in_apps(&lt;accountsMap&gt; AMAP &lt;/accountsMap&gt;))
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*asset_holding_get*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; asset_holding_get FIELD =&gt;
</span><span class="noop">           #asset_holding_get getOptInAssetField(FIELD,
</span><span class="noop">                                {accountReference(A)}:&gt;TValue, 
</span><span class="noop">                                {asaReference(ASSET)}:&gt;TValue) 
</span><span class="noop">           ... 
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (ASSET:TUInt64) : (A:TValue): _ &lt;/stack&gt;
</span><span class="noop">    requires isTValue(accountReference(A)) andBool isTValue(asaReference(ASSET))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; asset_holding_get _ =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (ASSET:TUInt64) : (A:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool (isTValue(accountReference(A)) andBool isTValue(asaReference(ASSET)))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; asset_holding_get _ =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _:TBytes : _ : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#asset_holding_get&#34; TValue
</span><span class="noop">  // -----------------------------------------
</span><span class="hit">  rule &lt;k&gt; #asset_holding_get RET =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Int) : _ : XS =&gt; 1 : RET : XS &lt;/stack&gt;
</span><span class="noop">    requires {RET}:&gt;Int &gt;=Int 0
</span><span class="noop">
</span><span class="noop">  // Return 0 if not opted in ASSET or the account is not found
</span><span class="hit">  rule &lt;k&gt; #asset_holding_get RET =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Int) : _ : XS =&gt; 0 : 0 : XS &lt;/stack&gt;
</span><span class="noop">    requires {RET}:&gt;Int &lt;Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*asset_params_get*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; asset_params_get FIELD =&gt;
</span><span class="noop">           #asset_params_get getAssetParamsField(FIELD, {asaReference(A)}:&gt;TValue)
</span><span class="noop">       ...
</span><span class="noop">       &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (A:TUInt64) : _ &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">     andBool isTValue(asaReference(A))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; asset_params_get _ =&gt; panic(TXN_ACCESS_FAILED) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (A:TUInt64) : _ &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">     andBool (notBool isTValue(asaReference(A)))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; asset_params_get _ =&gt; panic(STACK_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; asset_params_get _ =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= &#34;#asset_params_get&#34; TValue
</span><span class="noop">  // ----------------------------------------
</span><span class="hit">  rule &lt;k&gt; #asset_params_get RET =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Int) : XS =&gt; 1 : RET : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">     andBool (notBool (isInt(RET)) orElseBool {RET}:&gt;Int &gt;=Int 0 )
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #asset_params_get RET =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Int) : XS =&gt; 0 : 0 : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">     andBool (isInt(RET) andThenBool {RET}:&gt;Int &lt;Int 0)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*app_params_get*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; app_params_get FIELD =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; APP:Int : XS =&gt; 1 : {getAppParamsField(FIELD, APP)}:&gt;TValue : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires isTValue(getAppParamsField(FIELD, APP))
</span><span class="noop">     andBool S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; app_params_get FIELD =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; APP:Int : XS =&gt; 0 : 0 : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires notBool(isTValue(getAppParamsField(FIELD, APP)))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_params_get _ =&gt; panic(STACK_OVERFLOW) ...&lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_params_get _ =&gt; panic(STACK_UNDERFLOW) ...&lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int 1
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_params_get _ =&gt; panic(ILL_TYPED_STACK) ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _:Bytes : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*acct_params_get*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; acct_params_get FIELD =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; ACCT : XS =&gt; 1 : {getAccountParamsField(FIELD, {accountReference(ACCT)}:&gt;TValue)}:&gt;TValue : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires (isTValue(accountReference(ACCT))
</span><span class="noop"> andThenBool isTValue(getAccountParamsField(FIELD, {accountReference(ACCT)}:&gt;TValue))
</span><span class="noop"> andThenBool isInt(getAccountParamsField(AcctBalance, ACCT))
</span><span class="noop"> andThenBool {getAccountParamsField(AcctBalance, ACCT)}:&gt;Int &gt;Int 0)
</span><span class="noop">     andBool S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; acct_params_get FIELD =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; ACCT : XS =&gt; 0 : {getAccountParamsField(FIELD, {accountReference(ACCT)}:&gt;TValue)}:&gt;TValue : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires (isTValue(accountReference(ACCT))
</span><span class="noop"> andThenBool isTValue(getAccountParamsField(FIELD, {accountReference(ACCT)}:&gt;TValue))
</span><span class="noop"> andThenBool isInt(getAccountParamsField(AcctBalance, ACCT))
</span><span class="noop"> andThenBool {getAccountParamsField(AcctBalance, ACCT)}:&gt;Int &lt;=Int 0)
</span><span class="noop">     andBool S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; acct_params_get _ =&gt; panic(TXN_ACCESS_FAILED) ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; ACCT : _ &lt;/stack&gt;
</span><span class="noop">    requires notBool(isTValue(accountReference(ACCT)))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; acct_params_get _ =&gt; panic(STACK_OVERFLOW) ...&lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; acct_params_get _ =&gt; panic(STACK_UNDERFLOW) ...&lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int 1
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Access to past transactions in the group
</span><span class="noop">
</span><span class="noop">*gaid*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; gaid T:Int =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; {getGroupFieldByIdx( getTxnGroupID(getCurrentTxn()), T, ApplicationID)}:&gt;TValue : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">    requires S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">     andBool T &lt;Int {getTxnField(getCurrentTxn(), GroupIndex)}:&gt;Int
</span><span class="noop">     andBool ({getGroupFieldByIdx(getTxnGroupID(getCurrentTxn()), T, TypeEnum)}:&gt;Int) ==Int (@ appl)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; gaid T =&gt; panic(FUTURE_TXN) ... &lt;/k&gt;
</span><span class="noop">     requires T &gt;=Int {getTxnField(getCurrentTxn(), GroupIndex)}:&gt;Int
</span><span class="noop">     orBool ({getGroupFieldByIdx(getTxnGroupID(getCurrentTxn()), T, TypeEnum)}:&gt;Int) =/=Int (@ appl)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*gaids*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; gaids =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; T:Int : XS =&gt; {getGroupFieldByIdx( getTxnGroupID(getCurrentTxn()), T, ApplicationID)}:&gt;TValue : XS &lt;/stack&gt;
</span><span class="noop">    requires T &lt;Int {getTxnField(getCurrentTxn(), GroupIndex)}:&gt;Int
</span><span class="noop">     andBool ({getGroupFieldByIdx(getTxnGroupID(getCurrentTxn()), T, TypeEnum)}:&gt;Int) ==Int (@ appl)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; gaids =&gt; panic(FUTURE_TXN) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; T:Int : _ &lt;/stack&gt;
</span><span class="noop">     requires T &gt;=Int {getTxnField(getCurrentTxn(), GroupIndex)}:&gt;Int
</span><span class="noop">     orBool ({getGroupFieldByIdx(getTxnGroupID(getCurrentTxn()), T, TypeEnum)}:&gt;Int) =/=Int (@ appl)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">*gload, gloads, &amp; gloadss*
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; gload TXN_IDX I =&gt; loadGroupScratch(TXN_IDX, I) ...&lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; gloads I =&gt; loadGroupScratch(TXN_IDX, I) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (TXN_IDX:Int : XS) =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; gloadss =&gt; loadGroupScratch(TXN_IDX, I) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (I:Int : TXN_IDX:Int : XS) =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 2 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= loadGroupScratch(Int, Int)
</span><span class="noop">  //-----------------------------------------
</span><span class="hit">  rule &lt;k&gt; loadGroupScratch(GROUP_IDX, I) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; ({M[I]}:&gt;TValue) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;currentTx&gt; TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">         &lt;groupIdx&gt; GROUP_IDX &lt;/groupIdx&gt;
</span><span class="noop">         &lt;txScratch&gt; M &lt;/txScratch&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;Int MAX_SCRATCH_SIZE
</span><span class="noop">     andBool I in_keys(M)
</span><span class="noop">     andBool S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">     andBool GROUP_IDX &lt;Int ({getTxnField(getCurrentTxn(), GroupIndex)}:&gt;Int)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; loadGroupScratch(GROUP_IDX, I) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; ({M[I]}:&gt;TValue) : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;currentTx&gt; TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupIdx&gt; GROUP_IDX &lt;/groupIdx&gt;
</span><span class="noop">         &lt;txScratch&gt; M &lt;/txScratch&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;Int MAX_SCRATCH_SIZE
</span><span class="noop">     andBool I in_keys(M)
</span><span class="noop">     andBool S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">     andBool GROUP_IDX &lt;Int ({getTxnField(getCurrentTxn(), GroupIndex)}:&gt;Int)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; loadGroupScratch(GROUP_IDX, I) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; 0 : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;currentTx&gt; TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;groupID&gt; GROUP_ID &lt;/groupID&gt;
</span><span class="noop">         &lt;groupIdx&gt; GROUP_IDX &lt;/groupIdx&gt;
</span><span class="noop">         &lt;txScratch&gt; M &lt;/txScratch&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;Int MAX_SCRATCH_SIZE
</span><span class="noop">     andBool notBool (I in_keys(M))
</span><span class="noop">     andBool S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">     andBool GROUP_IDX &lt;Int ({getTxnField(getCurrentTxn(), GroupIndex)}:&gt;Int)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; loadGroupScratch(GROUP_IDX, I) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; XS =&gt; 0 : XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S +Int 1 &lt;/stacksize&gt;
</span><span class="noop">       &lt;currentTx&gt; TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;groupIdx&gt; GROUP_IDX &lt;/groupIdx&gt;
</span><span class="noop">         &lt;txScratch&gt; M &lt;/txScratch&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">    requires 0 &lt;=Int I andBool I &lt;Int MAX_SCRATCH_SIZE
</span><span class="noop">     andBool notBool (I in_keys(M))
</span><span class="noop">     andBool S &lt;Int MAX_STACK_DEPTH
</span><span class="noop">     andBool GROUP_IDX &lt;Int ({getTxnField(getCurrentTxn(), GroupIndex)}:&gt;Int)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; loadGroupScratch(_, I) =&gt; panic(INVALID_SCRATCH_LOC) ... &lt;/k&gt;
</span><span class="noop">    requires I &lt;Int 0 orBool I &gt;=Int MAX_SCRATCH_SIZE
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; loadGroupScratch(GROUP_IDX, _) =&gt; panic(FUTURE_TXN) ... &lt;/k&gt;
</span><span class="noop">    requires GROUP_IDX &gt;=Int {getTxnField(getCurrentTxn(), GroupIndex)}:&gt;Int
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; loadGroupScratch(GROUP_IDX, _) =&gt; panic(TXN_OUT_OF_BOUNDS) ... &lt;/k&gt;
</span><span class="noop">    requires GROUP_IDX &lt;Int 0 orBool GROUP_IDX &gt;=Int {getGlobalField(GroupSize)}:&gt;Int
</span><span class="noop">  
</span><span class="miss">  rule &lt;k&gt; loadGroupScratch(_, _) =&gt; panic(STACK_OVERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stacksize&gt; S &lt;/stacksize&gt;
</span><span class="noop">    requires S &gt;=Int MAX_STACK_DEPTH
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Inner transaction opcodes
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; itxn_begin =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         .List =&gt; 
</span><span class="noop">         ListItem(&lt;transaction&gt;
</span><span class="noop">           &lt;txID&gt; &#34;&#34; &lt;/txID&gt;
</span><span class="noop">           &lt;txHeader&gt;
</span><span class="noop">             // TODO Fee is calculated dynamically
</span><span class="noop">             &lt;fee&gt;         0                                         &lt;/fee&gt;
</span><span class="noop">             &lt;sender&gt;      getGlobalField(CurrentApplicationAddress) &lt;/sender&gt;
</span><span class="noop">             &lt;firstValid&gt;  getTxnField(getCurrentTxn(), FirstValid)  &lt;/firstValid&gt;
</span><span class="noop">             &lt;lastValid&gt;   getTxnField(getCurrentTxn(), LastValid)  &lt;/lastValid&gt;
</span><span class="noop">             &lt;genesisHash&gt; .Bytes                                    &lt;/genesisHash&gt;
</span><span class="noop">             &lt;txType&gt;       &#34;unknown&#34;                                &lt;/txType&gt;
</span><span class="noop">             &lt;typeEnum&gt;     0                                        &lt;/typeEnum&gt;
</span><span class="noop">             &lt;groupID&gt;      Int2String(GROUP_ID +Int 1)              &lt;/groupID&gt;
</span><span class="noop">             &lt;groupIdx&gt;     0                                        &lt;/groupIdx&gt;
</span><span class="noop">             &lt;genesisID&gt;    .Bytes                                   &lt;/genesisID&gt;
</span><span class="noop">             &lt;lease&gt;        .Bytes                                   &lt;/lease&gt;
</span><span class="noop">             &lt;note&gt;         .Bytes                                   &lt;/note&gt;
</span><span class="noop">             &lt;rekeyTo&gt;      getGlobalField(ZeroAddress)              &lt;/rekeyTo&gt;
</span><span class="noop">           &lt;/txHeader&gt;
</span><span class="noop">           &lt;txnTypeSpecificFields&gt;
</span><span class="noop">             .Bag
</span><span class="noop">           &lt;/txnTypeSpecificFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;)
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">       &lt;nextGroupID&gt; GROUP_ID =&gt; GROUP_ID +Int 1 &lt;/nextGroupID&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; itxn_submit =&gt; #incrementPC() ~&gt; #checkItxns(T) ~&gt; #executeItxnGroup()...&lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt; T &lt;/innerTransactions&gt;
</span><span class="noop">       &lt;lastTxnGroupID&gt; _ =&gt; Int2String(GROUP_ID) &lt;/lastTxnGroupID&gt;
</span><span class="noop">       &lt;nextGroupID&gt; GROUP_ID &lt;/nextGroupID&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; itxn_field FIELD =&gt; #setItxnField(FIELD, VAL) ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; VAL : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; itxn_next =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;innerTransactions&gt;
</span><span class="noop">         REST:List
</span><span class="noop">         (.List =&gt;
</span><span class="noop">         ListItem(&lt;transaction&gt;
</span><span class="noop">           &lt;txID&gt; &#34;&#34; &lt;/txID&gt;
</span><span class="noop">           &lt;txHeader&gt;
</span><span class="noop">             // TODO Fee is calculated dynamically
</span><span class="noop">             &lt;fee&gt;         0                                         &lt;/fee&gt;
</span><span class="noop">             &lt;sender&gt;      getGlobalField(CurrentApplicationAddress) &lt;/sender&gt;
</span><span class="noop">             &lt;firstValid&gt;  getTxnField(getCurrentTxn(), FirstValid)  &lt;/firstValid&gt;
</span><span class="noop">             &lt;lastValid&gt;   getTxnField(getCurrentTxn(), LastValid)   &lt;/lastValid&gt;
</span><span class="noop">             &lt;genesisHash&gt; .Bytes                                    &lt;/genesisHash&gt;
</span><span class="noop">             &lt;txType&gt;       &#34;unknown&#34;                                &lt;/txType&gt;
</span><span class="noop">             &lt;typeEnum&gt;     0                                        &lt;/typeEnum&gt;
</span><span class="noop">             &lt;groupID&gt;      Int2String(GROUP_ID)                     &lt;/groupID&gt;
</span><span class="noop">             &lt;groupIdx&gt;     size(REST)                               &lt;/groupIdx&gt;
</span><span class="noop">             &lt;genesisID&gt;    .Bytes                                   &lt;/genesisID&gt;
</span><span class="noop">             &lt;lease&gt;        .Bytes                                   &lt;/lease&gt;
</span><span class="noop">             &lt;note&gt;         .Bytes                                   &lt;/note&gt;
</span><span class="noop">             &lt;rekeyTo&gt;      getGlobalField(ZeroAddress)              &lt;/rekeyTo&gt;
</span><span class="noop">           &lt;/txHeader&gt;
</span><span class="noop">           &lt;txnTypeSpecificFields&gt;
</span><span class="noop">             .Bag
</span><span class="noop">           &lt;/txnTypeSpecificFields&gt;
</span><span class="noop">           ...
</span><span class="noop">         &lt;/transaction&gt;))
</span><span class="noop">       &lt;/innerTransactions&gt;
</span><span class="noop">       &lt;nextGroupID&gt; GROUP_ID &lt;/nextGroupID&gt;
</span><span class="noop">    requires size(REST) &gt;=Int 1
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; itxn FIELD =&gt; gitxn getLastItxnGroupIdx() FIELD ...&lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; itxna FIELD IDX =&gt; gitxna getLastItxnGroupIdx() FIELD IDX ...&lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; gitxn GROUP_IDX FIELD =&gt; #loadFromGroupInner(GROUP_IDX, FIELD) ...&lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; gitxna GROUP_IDX FIELD IDX =&gt; #loadFromGroupInner(GROUP_IDX, FIELD, IDX) ...&lt;/k&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; itxnas FIELD =&gt; gitxna getLastItxnGroupIdx() FIELD IDX ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; IDX : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; gitxnas GROUP_IDX FIELD =&gt; gitxna GROUP_IDX FIELD IDX ...&lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; IDX : XS =&gt; XS &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; S =&gt; S -Int 1 &lt;/stacksize&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Panic Behaviors due to Ill-typed Stack Arguments
</span><span class="noop">------------------------------------------------
</span><span class="noop">
</span><span class="noop">### Crypto Opcodes
</span><span class="noop">
</span><span class="noop">### Arithmetic/relational/logical/Bitwise Opcodes
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; Op:OpCode =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (V2:TValue) : (V1:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires (isBinaryArithOpCode(Op)         orBool
</span><span class="noop">              isInequalityOpCode(Op)    orBool
</span><span class="noop">              isBinaryLogicalOpCode(Op) orBool
</span><span class="noop">              isBinaryBitOpCode(Op))
</span><span class="noop">     andBool (isBytes(V2) orBool isBytes(V1))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; Op:OpCode =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">    requires isUnaryLogicalOpCode(Op)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; _:EqualityOpCode =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (V2:TValue) : (V1:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires (isBytes(V1) andBool isInt(V2))
</span><span class="noop">      orBool (isBytes(V2) andBool isInt(V1))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Byte Opcodes
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; OP:OpCode =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; A : B : _ &lt;/stack&gt;
</span><span class="noop">    requires (isInt(A) orBool isInt(B))
</span><span class="noop">     andBool (isArithmMathByteOpCode(OP)
</span><span class="noop">     orBool   isRelationalMathByteOpCode(OP)
</span><span class="noop">     orBool   isBinaryLogicalMathByteOpCode(OP))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; OP:OpCode =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _:Int : _ &lt;/stack&gt;
</span><span class="noop">    requires isUnaryLogicalMathByteOpCode(OP)
</span><span class="noop">  
</span><span class="miss">  rule &lt;k&gt; len =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Int) : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; itob =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; btoi =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Int) : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; concat =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (V2:TValue) : (V1:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires isInt(V2) orBool isInt(V1)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; substring _ _ =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Int) : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; substring3 =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (V:TValue) : (START:TValue) : (END:TValue) : _ &lt;/stack&gt;
</span><span class="noop">    requires isInt(V) orBool isBytes(START) orBool isBytes(END)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Flow Control Opcodes
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; Op:OpCode =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : _ &lt;/stack&gt;
</span><span class="noop">    requires isCondBranchOpCode(Op) orBool isReturnOpCode(Op)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Application State Opcodes
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; app_global_get =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Int) : _ &lt;/stack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_global_put =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:TValue) : (_:Int):_ &lt;/stack&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; app_global_del =&gt; panic(ILL_TYPED_STACK) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Int) : _ &lt;/stack&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Signature Verification Opcode
</span><span class="noop">
</span><span class="noop">Panic Behaviors due to Insufficient Stack Arguments
</span><span class="noop">---------------------------------------------------
</span><span class="noop">
</span><span class="noop">TODO: incorporate Bytes math opcodes
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  // Opcodes requiring at least three stack elements
</span><span class="miss">  rule &lt;k&gt; Op:OpCode =&gt; panic(STACK_UNDERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:TValue) : (_:TValue) : .TStack &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; 2 &lt;/stacksize&gt;
</span><span class="noop">    requires isTernaryStateOpCode(Op)
</span><span class="noop">      orBool isTernaryByteOpCode(Op)
</span><span class="noop">      orBool isSigVerOpCode(Op)
</span><span class="noop">      orBool isTernaryStackOpCode(Op)
</span><span class="noop">
</span><span class="noop">  // Opcodes requiring at least two stack elements
</span><span class="miss">  rule &lt;k&gt; Op:OpCode =&gt; panic(STACK_UNDERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:TValue) : .TStack &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; 1 &lt;/stacksize&gt;
</span><span class="noop">    requires isBinaryArithOpCode(Op)
</span><span class="noop">      orBool isBinaryBitOpCode(Op)
</span><span class="noop">      orBool isRelationalOpCode(Op)
</span><span class="noop">      orBool isBinaryLogicalOpCode(Op)
</span><span class="noop">      orBool isBinaryByteOpCode(Op)
</span><span class="noop">      orBool isTernaryByteOpCode(Op)
</span><span class="noop">      orBool isBinaryStackOpCode(Op)
</span><span class="noop">      orBool isSigVerOpCode(Op)
</span><span class="noop">      orBool isBinaryStateOpCode(Op)
</span><span class="noop">      orBool isTernaryStateOpCode(Op)
</span><span class="noop">
</span><span class="noop">  // Opcodes requiring at least one stack element
</span><span class="miss">  rule &lt;k&gt; Op:OpCode =&gt; panic(STACK_UNDERFLOW) ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; .TStack &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; 0 &lt;/stacksize&gt;
</span><span class="noop">    requires isCryptoOpCode(Op)
</span><span class="noop">      orBool isArithOpCode(Op)
</span><span class="noop">      orBool isBitOpCode(Op)
</span><span class="noop">      orBool isRelationalOpCode(Op)
</span><span class="noop">      orBool isLogicalOpCode(Op)
</span><span class="noop">      orBool isByteOpCode(Op)
</span><span class="noop">      orBool isStoreOpCode(Op)
</span><span class="noop">      orBool isCondBranchOpCode(Op)
</span><span class="noop">      orBool isReturnOpCode(Op)
</span><span class="noop">      orBool (isStackOpCode(Op) andBool notBool (isNullaryStackOpCode(Op)))
</span><span class="noop">      orBool isStateOpCode(Op)
</span><span class="noop">      orBool isSigVerOpCode(Op)
</span><span class="noop">
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/teal/teal-execution.md">avm/teal/teal-execution.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">```k
</span><span class="noop">requires &#34;avm/teal/teal-syntax.md&#34;
</span><span class="noop">requires &#34;avm/avm-configuration.md&#34;
</span><span class="noop">requires &#34;avm/avm-limits.md&#34;
</span><span class="noop">
</span><span class="noop">module TEAL-EXECUTION
</span><span class="noop">  imports AVM-CONFIGURATION
</span><span class="noop">  imports AVM-LIMITS
</span><span class="noop">  imports TEAL-OPCODES
</span><span class="noop">  imports TEAL-SYNTAX
</span><span class="noop">  imports TEAL-STACK
</span><span class="noop">  imports TEAL-INTERPRETER-STATE
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">TEAL Interpreter Initialization
</span><span class="noop">-------------------------------
</span><span class="noop">
</span><span class="noop">Before starting the execution of a TEAL progam, the `&lt;teal&gt;` cell needs to be (re-)initialised, since
</span><span class="noop">there may be some remaining artefacts of the previous transaction&#39;s TEAL.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #initContext() =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTxnExecution&gt;
</span><span class="noop">         &lt;teal&gt;
</span><span class="noop">         _ =&gt; (
</span><span class="noop">           &lt;pc&gt; 0 &lt;/pc&gt;
</span><span class="noop">           &lt;program&gt; .Map &lt;/program&gt;
</span><span class="noop">           &lt;mode&gt; undefined &lt;/mode&gt;
</span><span class="noop">           &lt;version&gt; 1 &lt;/version&gt;
</span><span class="noop">           &lt;stack&gt; .TStack &lt;/stack&gt;
</span><span class="noop">           &lt;stacksize&gt; 0 &lt;/stacksize&gt;
</span><span class="noop">           &lt;jumped&gt; false &lt;/jumped&gt;
</span><span class="noop">           &lt;labels&gt; .Map &lt;/labels&gt;
</span><span class="noop">           &lt;callStack&gt; .List &lt;/callStack&gt;
</span><span class="noop">           &lt;scratch&gt; .Map &lt;/scratch&gt;
</span><span class="noop">           &lt;intcblock&gt; .Map &lt;/intcblock&gt;
</span><span class="noop">           &lt;bytecblock&gt; .Map &lt;/bytecblock&gt;
</span><span class="noop">         )
</span><span class="noop">         &lt;/teal&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/currentTxnExecution&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #restoreContext() =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TX_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TX_ID &lt;/txID&gt;
</span><span class="noop">         &lt;txnExecutionContext&gt; &lt;currentTxnExecution&gt; C &lt;/currentTxnExecution&gt; &lt;/txnExecutionContext&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;currentTxnExecution&gt; _ =&gt; C &lt;/currentTxnExecution&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #initApp(APP_ID) =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;currentApplicationID&gt; _ =&gt; APP_ID &lt;/currentApplicationID&gt;
</span><span class="noop">       &lt;currentApplicationAddress&gt; _ =&gt; getAppAddress(APP_ID)       &lt;/currentApplicationAddress&gt;
</span><span class="noop">       &lt;activeApps&gt; (.Set =&gt; SetItem(APP_ID)) REST &lt;/activeApps&gt;
</span><span class="noop">       &lt;lastTxnGroupID&gt; _ =&gt; &#34;&#34; &lt;/lastTxnGroupID&gt;
</span><span class="noop">       &lt;mode&gt; _ =&gt; stateful &lt;/mode&gt;
</span><span class="noop">    requires notBool(APP_ID in REST)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="miss">  rule &lt;k&gt; #initSmartSig() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;mode&gt; _ =&gt; stateless &lt;/mode&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Program initialization
</span><span class="noop">
</span><span class="noop">The parsed TEAL pragmas and program are initially supplied on the `&lt;k&gt;` cell as
</span><span class="noop">`TealPragmas` and `TealInputPgm`, wrapped into an `OpaqueTeal` constructor.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax KItem ::= OpaqueTeal(TealInputPgm)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">The `OpaqueTeal` wraps the program source to prevent undesired triggering of program loading
</span><span class="noop">when naked opcodes are placed onto the `&lt;k&gt;` cell.
</span><span class="noop">
</span><span class="noop">Pragmas are applied directly, and then the `#LoadPgm` performs program pre-processing:
</span><span class="noop">
</span><span class="noop">* the program is transformed into a `Map` from program addresses to opcodes and stored
</span><span class="noop">  into the `&lt;program&gt;` cell;
</span><span class="noop">* every opcode is checked to be valid for the current execution mode and
</span><span class="noop">  `panic(INVALID_OP_FOR_MODE)` is triggered accordingly;
</span><span class="noop">* the labels are collected and stored into the `&lt;labels&gt;` cell as keys, with their program
</span><span class="noop">  addresses as values;
</span><span class="noop">* if a label is encountered twice, the `panic(DUPLICATE_LABEL)` computation is triggered.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; OpaqueTeal(Rs:TealPragmas P:TealPgm) =&gt; Rs ~&gt; #LoadPgm(P, 0) ... &lt;/k&gt;
</span><span class="miss">  rule &lt;k&gt; OpaqueTeal(P:TealPgm)                =&gt; #LoadPgm(P, 0) ... &lt;/k&gt;
</span><span class="miss">  rule &lt;k&gt; R:TealPragma Rs:TealPragmas          =&gt; R ~&gt; Rs ... &lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #pragma version V =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;version&gt; _ =&gt; V &lt;/version&gt;
</span><span class="noop">
</span><span class="noop">  // Load the teal program into the `&lt;progam&gt;` cell (program memory)
</span><span class="noop">  syntax KItem ::= #LoadPgm(TealPgm, Int)
</span><span class="noop">  // ----------------------------------
</span><span class="hit">  rule &lt;k&gt; #LoadPgm( Op Pgm, PC ) =&gt; #LoadPgm( Pgm, PC +Int 1 ) ... &lt;/k&gt;
</span><span class="noop">       &lt;mode&gt; Mode &lt;/mode&gt;
</span><span class="noop">       &lt;program&gt; PGM =&gt; PGM[PC &lt;- Op] &lt;/program&gt;
</span><span class="noop">    requires #ValidOpForMode( Mode, Op )
</span><span class="noop">     andBool (notBool isLabelCode(Op))
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #LoadPgm( (L:) Pgm, PC ) =&gt; #LoadPgm( Pgm, PC +Int 1 ) ... &lt;/k&gt;
</span><span class="noop">       &lt;program&gt; PGM =&gt; PGM[PC &lt;- (L:)] &lt;/program&gt;
</span><span class="noop">       &lt;labels&gt; LL =&gt; LL[L &lt;- PC] &lt;/labels&gt;
</span><span class="noop">    requires notBool (L in_labels LL)
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #LoadPgm( (L:) _, _ ) =&gt; panic(DUPLICATE_LABEL) ... &lt;/k&gt;
</span><span class="noop">       &lt;labels&gt; LL &lt;/labels&gt;
</span><span class="noop">    requires L in_labels LL
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #LoadPgm( Op _, _) =&gt; panic(INVALID_OP_FOR_MODE) ... &lt;/k&gt;
</span><span class="noop">       &lt;mode&gt; Mode &lt;/mode&gt;
</span><span class="noop">    requires notBool #ValidOpForMode( Mode, Op )
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #LoadPgm( Op, PC) =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;mode&gt; Mode &lt;/mode&gt;
</span><span class="noop">       &lt;program&gt; PGM =&gt; PGM[PC &lt;- Op] &lt;/program&gt;
</span><span class="noop">    requires #ValidOpForMode( Mode, Op )
</span><span class="noop">     andBool (notBool isLabelCode(Op))
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #LoadPgm( (L:) , PC ) =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;program&gt; PGM =&gt; PGM[PC &lt;- (L:)] &lt;/program&gt;
</span><span class="noop">       &lt;labels&gt; LL =&gt; LL[L &lt;- PC] &lt;/labels&gt;
</span><span class="noop">    requires notBool (L in_labels LL)
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #LoadPgm( (L:) , _ ) =&gt; panic(DUPLICATE_LABEL) ... &lt;/k&gt;
</span><span class="noop">       &lt;labels&gt; LL &lt;/labels&gt;
</span><span class="noop">    requires L in_labels LL
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #LoadPgm( Op, _) =&gt; panic(INVALID_OP_FOR_MODE) ... &lt;/k&gt;
</span><span class="noop">       &lt;mode&gt; Mode &lt;/mode&gt;
</span><span class="noop">    requires notBool #ValidOpForMode( Mode, Op )
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= #ValidOpForMode( TealMode, TealOpCodeOrLabel ) [function]
</span><span class="noop">  // ----------------------------------------------------------------------
</span><span class="hit">  rule #ValidOpForMode( _M:TealMode, _O:PseudoOpCode ) =&gt; true
</span><span class="hit">  rule #ValidOpForMode( _M:TealMode, _O:OpCode       ) =&gt; true
</span><span class="hit">  rule #ValidOpForMode( _M:TealMode, _L:LabelCode    ) =&gt; true
</span><span class="miss">  rule #ValidOpForMode( stateless,   _O:SigOpCode    ) =&gt; true
</span><span class="hit">  rule #ValidOpForMode( stateful,    _O:AppOpCode    ) =&gt; true
</span><span class="miss">  rule #ValidOpForMode( stateful,    _O:SigOpCode    ) =&gt; false
</span><span class="miss">  rule #ValidOpForMode( stateless,   _O:AppOpCode    ) =&gt; false
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">TEAL Execution
</span><span class="noop">--------------
</span><span class="noop">
</span><span class="noop">### Starting execution
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #startExecution() =&gt; #fetchOpcode() ... &lt;/k&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Opcode fetching
</span><span class="noop">
</span><span class="noop">The `#fetchOpcode()` operation will lookup the next opcode from program memory and
</span><span class="noop">put it into the `&lt;k&gt;` cell for execution.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #fetchOpcode() =&gt; PGM[PC] ~&gt; #incrementPC() ~&gt; #fetchOpcode() ... &lt;/k&gt;
</span><span class="noop">       &lt;pc&gt; PC &lt;/pc&gt;
</span><span class="noop">       &lt;program&gt; PGM &lt;/program&gt;
</span><span class="noop">   requires isValidProgamAddress(PC)
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= isValidProgamAddress(Int) [function]
</span><span class="noop">  // -------------------------------------------------
</span><span class="hit">  rule [[ isValidProgamAddress(ADDR) =&gt; true ]]
</span><span class="noop">       &lt;program&gt; PGM &lt;/program&gt;
</span><span class="noop">    requires 0 &lt;=Int ADDR andBool ADDR &lt;Int size(PGM)
</span><span class="hit">  rule isValidProgamAddress(_) =&gt; false [owise]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">If there the PC goes one step beyond the program address space, it means that the execution is finished:
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #fetchOpcode() =&gt; #finalizeExecution() ... &lt;/k&gt;
</span><span class="noop">       &lt;pc&gt; PC &lt;/pc&gt;
</span><span class="noop">       &lt;program&gt; PGM &lt;/program&gt;
</span><span class="noop">   requires PC ==Int size(PGM)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Program counter
</span><span class="noop">
</span><span class="noop">Program counter is incremented after every opcode execution, unless its a branch.
</span><span class="noop">The semantics of branches updates the PC on its own.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="hit">  rule &lt;k&gt; #incrementPC() =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;pc&gt; PC =&gt; PC +Int #if JUMPED #then 0 #else 1 #fi &lt;/pc&gt;
</span><span class="noop">       &lt;jumped&gt; JUMPED =&gt; false &lt;/jumped&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">TEAL Interpreter Finalization
</span><span class="noop">-----------------------------
</span><span class="noop">
</span><span class="noop">After evaluating the TEAL code of an application call or a logic signature we need to finalize
</span><span class="noop">the `&lt;teal&gt;` cell, depending on the evaluation result: whether the transaction has been accepted or
</span><span class="noop">rejected.
</span><span class="noop">
</span><span class="noop">Possible return codes:
</span><span class="noop">
</span><span class="noop">- 4 - program got stuck (No valid program is expected to terminate returning this code)
</span><span class="noop">- 3 - program panicked
</span><span class="noop">- 2 - program terminated with bad stack (non-singleton or singleton byte-array stack)
</span><span class="noop">- 1 - program terminated with failure (zero-valued singleton stack)
</span><span class="noop">- 0 - program terminated with success (positive-valued singleton stack)
</span><span class="noop">
</span><span class="noop">Note: For stateless teal, failure means rejecting the transaction. For stateful
</span><span class="noop">teal, failure means undoing changes made to the state (for more details, see
</span><span class="noop">[this article](https://developer.algorand.org/docs/features/asc1/).)
</span><span class="noop">```k
</span><span class="noop">  syntax KItem ::= #calcReturn()
</span><span class="noop">  syntax KItem ::= #deactivateApp()
</span><span class="noop">  syntax KItem ::= #stopIfError()
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #finalizeExecution() =&gt; #deactivateApp() ~&gt; #calcReturn() ~&gt; #stopIfError() ... &lt;/k&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #deactivateApp() =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;currentApplicationID&gt; APP_ID &lt;/currentApplicationID&gt;
</span><span class="noop">       &lt;activeApps&gt; (SetItem(APP_ID) =&gt; .Set) ...&lt;/activeApps&gt;
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #calcReturn() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : .TStack &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; SIZE &lt;/stacksize&gt;
</span><span class="noop">       &lt;returncode&gt; 4 =&gt; 0 &lt;/returncode&gt;
</span><span class="noop">       &lt;returnstatus&gt; _ =&gt; &#34;Success - positive-valued singleton stack&#34; &lt;/returnstatus&gt;
</span><span class="noop">    requires I &gt;Int 0 andBool SIZE ==Int 1
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #calcReturn() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; I : .TStack &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; _ &lt;/stacksize&gt;
</span><span class="noop">       &lt;returncode&gt; 4 =&gt; 1 &lt;/returncode&gt;
</span><span class="noop">       &lt;returnstatus&gt; _ =&gt; &#34;Failure - zero-valued singleton stack&#34; &lt;/returnstatus&gt;
</span><span class="noop">    requires 0 &gt;=Int I
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #calcReturn() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; _ &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; SIZE &lt;/stacksize&gt;
</span><span class="noop">       &lt;returncode&gt; 4 =&gt; 2 &lt;/returncode&gt;
</span><span class="noop">       &lt;returnstatus&gt; _ =&gt; &#34;Failure - stack size greater than 1&#34; &lt;/returnstatus&gt;
</span><span class="noop">    requires SIZE &gt;Int 1
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #calcReturn() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; .TStack &lt;/stack&gt;
</span><span class="noop">       &lt;returncode&gt; 4 =&gt; 2 &lt;/returncode&gt;
</span><span class="noop">       &lt;returnstatus&gt; _ =&gt; &#34;Failure - empty stack&#34; &lt;/returnstatus&gt;
</span><span class="noop">
</span><span class="miss">  rule &lt;k&gt; #calcReturn() =&gt; .K ... &lt;/k&gt;
</span><span class="noop">       &lt;stack&gt; (_:Bytes) : .TStack &lt;/stack&gt;
</span><span class="noop">       &lt;stacksize&gt; _ &lt;/stacksize&gt;
</span><span class="noop">       &lt;returncode&gt; 4 =&gt; 2 &lt;/returncode&gt;
</span><span class="noop">       &lt;returnstatus&gt; _ =&gt; &#34;Failure - singleton stack with byte array type&#34; &lt;/returnstatus&gt;
</span><span class="noop">
</span><span class="noop">  // Consume the rest of the K cell if the execution terminated with an error
</span><span class="hit">  rule &lt;k&gt; #stopIfError() ~&gt; (_:KItem =&gt; .K) ... &lt;/k&gt;
</span><span class="noop">       &lt;returncode&gt; RETURN_CODE &lt;/returncode&gt;
</span><span class="noop">    requires RETURN_CODE =/=Int 0
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #stopIfError() =&gt; .K &lt;/k&gt;
</span><span class="noop">       &lt;returncode&gt; RETURN_CODE &lt;/returncode&gt;
</span><span class="noop">    requires RETURN_CODE =/=Int 0
</span><span class="noop">
</span><span class="hit">  rule &lt;k&gt; #stopIfError() =&gt; . ... &lt;/k&gt;
</span><span class="noop">       &lt;returncode&gt; RETURN_CODE &lt;/returncode&gt;
</span><span class="noop">    requires RETURN_CODE ==Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax KItem ::= #saveScratch()
</span><span class="noop">  //-----------------------------
</span><span class="hit">  rule &lt;k&gt; #saveScratch() =&gt; . ...&lt;/k&gt;
</span><span class="noop">       &lt;currentTx&gt; TXN_ID &lt;/currentTx&gt;
</span><span class="noop">       &lt;transaction&gt;
</span><span class="noop">         &lt;txID&gt; TXN_ID &lt;/txID&gt;
</span><span class="noop">         &lt;txScratch&gt; _ =&gt; SCRATCH &lt;/txScratch&gt;
</span><span class="noop">         ...
</span><span class="noop">       &lt;/transaction&gt;
</span><span class="noop">       &lt;scratch&gt; SCRATCH &lt;/scratch&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Panic Behaviors
</span><span class="noop">---------------
</span><span class="noop">
</span><span class="noop">A TEAL program may panic for one of the following reasons:
</span><span class="noop">
</span><span class="noop">1.  Opcode used not valid for current mode of execution
</span><span class="noop">
</span><span class="noop">2.  The `err` opcode is encountered
</span><span class="noop">
</span><span class="noop">3.  Integer overflow
</span><span class="noop">
</span><span class="noop">4.  Integer underflow
</span><span class="noop">
</span><span class="noop">5.  Division by zero
</span><span class="noop">
</span><span class="noop">6.  `concat`: The resulting byte array is too large (&gt; 4k bytes)
</span><span class="noop">
</span><span class="noop">7.  `txn`/`txna`: Accessing a transaction field failed
</span><span class="noop">    - The transaction does not exist
</span><span class="noop">    - The transaction type is invalid
</span><span class="noop">    - The requested field is invalid for the transaction type
</span><span class="noop">    - Indexing an array field out of bounds
</span><span class="noop">    - Access to a field of transaction beyond `GroupIndex` is requested via `gaid(s)` or `gload(s)` opcode
</span><span class="noop">
</span><span class="noop">8.  An opcode attempts to write to or read from an invalid scratch space
</span><span class="noop">    location
</span><span class="noop">
</span><span class="noop">9.  An opcode attempts to use an invalid index for a byte array (`substring*`,
</span><span class="noop">    `arg`)
</span><span class="noop">
</span><span class="noop">10. branching beyond the end of the program or brcnhing backwards (`b*`)
</span><span class="noop">
</span><span class="noop">11. An input in the stack is not of the expected type
</span><span class="noop">
</span><span class="noop">12. An input in the stack is not in the expected range, for example not `0` or `1` for `setbit`
</span><span class="noop">
</span><span class="noop">13. An opcode attempts to push to a full stack
</span><span class="noop">
</span><span class="noop">14. An opcode attempts to pop from an empty stack
</span><span class="noop">
</span><span class="noop">15. An assertion is violated, i.e. the asserted expression evaluates to zero
</span><span class="noop">
</span><span class="noop">16. A negative number is supplied on stack. That panic behavior is impossible in concrete
</span><span class="noop">    execution, but is helpful in some symbolic execution scenarios.
</span><span class="noop">
</span><span class="noop">17. A subroutine call attempt with a full call stack, or a subroutine return with an empty one.
</span><span class="noop">
</span><span class="noop">18. Math attempted on a byte-array larger than `MAX_BYTE_MATH_SIZE`.
</span><span class="noop">
</span><span class="noop">Other reasons for panic behavior, which do not apply to this specification
</span><span class="noop">of TEAL, include:
</span><span class="noop">
</span><span class="noop">19. `global`: Wrong global field (rejected by our TEAL parser; syntax
</span><span class="noop">    definition disallows invalid fields)
</span><span class="noop">
</span><span class="noop">20. `txn/txna`: wrong type argument (rejected by our TEAL parser; syntax
</span><span class="noop">    definition disallows invalid fields)
</span><span class="noop">
</span><span class="noop">21. Loading constants from beyond the bytecblock or the intcblock of the
</span><span class="noop">    program (This is specific to post-assembly TEAL and does not apply to our
</span><span class="noop">    abstract semantics)
</span><span class="noop">
</span><span class="noop">22. Invalid opcode (rejected by our TEAL parser; syntax definition disallows
</span><span class="noop">    invalid opcodes)
</span><span class="noop">
</span><span class="noop">Panic conditions (1 -- 18 above) are captured by the `panic` computation,
</span><span class="noop">which carries a message describing the reason for panicking and sets the
</span><span class="noop">return code to 3 (see return codes below).
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  // Panic types
</span><span class="noop">  syntax String ::= &#34;INVALID_OP_FOR_MODE&#34;        [macro]
</span><span class="noop">  syntax String ::= &#34;ERR_OPCODE&#34;                 [macro]
</span><span class="noop">  syntax String ::= &#34;INT_OVERFLOW&#34;               [macro]
</span><span class="noop">  syntax String ::= &#34;INT_UNDERFLOW&#34;              [macro]
</span><span class="noop">  syntax String ::= &#34;DIV_BY_ZERO&#34;                [macro]
</span><span class="noop">  syntax String ::= &#34;BYTES_OVERFLOW&#34;             [macro]
</span><span class="noop">  syntax String ::= &#34;TXN_ACCESS_FAILED&#34;          [macro]
</span><span class="noop">  syntax String ::= &#34;TXN_INVALID&#34;                [macro]
</span><span class="noop">  syntax String ::= &#34;INVALID_SCRATCH_LOC&#34;        [macro]
</span><span class="noop">  syntax String ::= &#34;TXN_OUT_OF_BOUNDS&#34;          [macro]
</span><span class="noop">  syntax String ::= &#34;FUTURE_TXN&#34;                 [macro]
</span><span class="noop">  syntax String ::= &#34;INDEX_OUT_OF_BOUNDS&#34;        [macro]
</span><span class="noop">  syntax String ::= &#34;ILLEGAL_JUMP&#34;               [macro]
</span><span class="noop">  syntax String ::= &#34;ILL_TYPED_STACK&#34;            [macro]
</span><span class="noop">  syntax String ::= &#34;LOG_CALLS_EXCEEDED&#34;         [macro]
</span><span class="noop">  syntax String ::= &#34;LOG_SIZE_EXCEEDED&#34;          [macro]
</span><span class="noop">  syntax String ::= &#34;GLOBAL_BYTES_EXCEEDED&#34;      [macro]
</span><span class="noop">  syntax String ::= &#34;GLOBAL_INTS_EXCEEDED&#34;       [macro]
</span><span class="noop">  syntax String ::= &#34;LOCAL_BYTES_EXCEEDED&#34;       [macro]
</span><span class="noop">  syntax String ::= &#34;LOCAL_INTS_EXCEEDED&#34;        [macro]
</span><span class="noop">  syntax String ::= &#34;STACK_OVERFLOW&#34;             [macro]
</span><span class="noop">  syntax String ::= &#34;STACK_UNDERFLOW&#34;            [macro]
</span><span class="noop">  syntax String ::= &#34;ASSERTION_VIOLATION&#34;        [macro]
</span><span class="noop">  syntax String ::= &#34;IMPOSSIBLE_NEGATIVE_NUMBER&#34; [macro]
</span><span class="noop">  syntax String ::= &#34;DUPLICATE_LABEL&#34;            [macro]
</span><span class="noop">  syntax String ::= &#34;CALLSTACK_UNDERFLOW&#34;        [macro]
</span><span class="noop">  syntax String ::= &#34;CALLSTACK_OVERFLOW&#34;         [macro]
</span><span class="noop">  syntax String ::= &#34;INVALID_ARGUMENT&#34;           [macro]
</span><span class="noop">  syntax String ::= &#34;ITXN_REENTRY&#34;               [macro]
</span><span class="noop">  syntax String ::= &#34;MATH_BYTES_ARG_TOO_LONG&#34;    [macro]
</span><span class="noop">  syntax String ::= &#34;INSUFFICIENT_FUNDS&#34;         [macro]
</span><span class="noop">  syntax String ::= &#34;KEY_TOO_LARGE&#34;              [macro]
</span><span class="noop">  syntax String ::= &#34;BYTE_VALUE_TOO_LARGE&#34;       [macro]
</span><span class="noop">  syntax String ::= &#34;KEY_VALUE_TOO_LARGE&#34;        [macro]
</span><span class="noop">  //----------------------------------------------------
</span><span class="hit">  rule INVALID_OP_FOR_MODE =&gt; &#34;invalid opcode for current execution mode&#34;
</span><span class="hit">  rule ERR_OPCODE          =&gt; &#34;err opcode encountered&#34;
</span><span class="hit">  rule INT_OVERFLOW        =&gt; &#34;integer overflow&#34;
</span><span class="hit">  rule INT_UNDERFLOW       =&gt; &#34;integer underflow&#34;
</span><span class="hit">  rule DIV_BY_ZERO         =&gt; &#34;division by zero&#34;
</span><span class="hit">  rule BYTES_OVERFLOW      =&gt; &#34;resulting byte array too large&#34;
</span><span class="hit">  rule TXN_ACCESS_FAILED   =&gt; &#34;transaction field access failed&#34;
</span><span class="hit">  rule TXN_INVALID         =&gt; &#34;a transaction is malformed&#34;
</span><span class="hit">  rule INVALID_SCRATCH_LOC =&gt; &#34;invalid scratch space location&#34;
</span><span class="hit">  rule TXN_OUT_OF_BOUNDS   =&gt; &#34;transaction index out of bounds&#34;
</span><span class="hit">  rule FUTURE_TXN          =&gt; &#34;tried to access transaction that hasn&#39;t executed yet&#34;
</span><span class="hit">  rule INDEX_OUT_OF_BOUNDS =&gt; &#34;array index out of bounds&#34;
</span><span class="hit">  rule ILLEGAL_JUMP        =&gt; &#34;illegal branch to a non-existing label&#34;
</span><span class="hit">  rule ILL_TYPED_STACK     =&gt; &#34;wrong argument type(s) for opcode&#34;
</span><span class="hit">  rule LOG_CALLS_EXCEEDED  =&gt; &#34;too many log calls in transaction&#34;
</span><span class="hit">  rule LOG_SIZE_EXCEEDED   =&gt; &#34;total size of log calls in transaction is too large&#34;
</span><span class="hit">  rule GLOBAL_BYTES_EXCEEDED =&gt; &#34;tried to store too many byte values in global storage&#34;
</span><span class="hit">  rule GLOBAL_INTS_EXCEEDED =&gt; &#34;tried to store too many int values in global storage&#34;
</span><span class="hit">  rule LOCAL_BYTES_EXCEEDED =&gt; &#34;tried to store too many byte values in local storage&#34;
</span><span class="hit">  rule LOCAL_INTS_EXCEEDED =&gt; &#34;tried to store too many int values in local storage&#34;
</span><span class="hit">  rule INVALID_ARGUMENT    =&gt; &#34;wrong argument range(s) for opcode&#34;
</span><span class="hit">  rule STACK_OVERFLOW      =&gt; &#34;stack overflow&#34;
</span><span class="hit">  rule STACK_UNDERFLOW     =&gt; &#34;stack underflow&#34;
</span><span class="hit">  rule ASSERTION_VIOLATION =&gt; &#34;assertion violation&#34;
</span><span class="hit">  rule DUPLICATE_LABEL     =&gt; &#34;duplicate label&#34;
</span><span class="hit">  rule IMPOSSIBLE_NEGATIVE_NUMBER =&gt; &#34;impossible happened: negative number on stack&#34;
</span><span class="hit">  rule CALLSTACK_UNDERFLOW =&gt; &#34;call stack underflow: illegal retsub&#34;
</span><span class="hit">  rule CALLSTACK_OVERFLOW  =&gt; &#34;call stack overflow: recursion is too deep&#34;
</span><span class="hit">  rule ITXN_REENTRY        =&gt; &#34;application called from itself&#34;
</span><span class="hit">  rule MATH_BYTES_ARG_TOO_LONG =&gt; &#34;math attempted on large byte-array&#34;
</span><span class="hit">  rule INSUFFICIENT_FUNDS  =&gt; &#34;negative balance reached&#34;
</span><span class="hit">  rule KEY_TOO_LARGE       =&gt; &#34;key is too long&#34;
</span><span class="hit">  rule BYTE_VALUE_TOO_LARGE =&gt; &#34;tried to store too large of a byte value&#34;
</span><span class="hit">  rule KEY_VALUE_TOO_LARGE =&gt; &#34;sum of key length and value length is too high&#34;
</span><span class="noop">  rule ASSERTION_VIOLATION =&gt; &#34;assertion violation&#34;
</span><span class="noop">  //--------------------------------------------------------------------------------
</span><span class="noop">
</span><span class="miss">  rule panicCode(INVALID_OP_FOR_MODE)        =&gt; 1
</span><span class="miss">  rule panicCode(ERR_OPCODE)                 =&gt; 2
</span><span class="hit">  rule panicCode(INT_OVERFLOW)               =&gt; 3
</span><span class="miss">  rule panicCode(INT_UNDERFLOW)              =&gt; 4
</span><span class="hit">  rule panicCode(DIV_BY_ZERO)                =&gt; 5
</span><span class="hit">  rule panicCode(BYTES_OVERFLOW)             =&gt; 6
</span><span class="hit">  rule panicCode(TXN_ACCESS_FAILED)          =&gt; 7
</span><span class="hit">  rule panicCode(TXN_INVALID)                =&gt; 8
</span><span class="hit">  rule panicCode(INVALID_SCRATCH_LOC)        =&gt; 9
</span><span class="miss">  rule panicCode(TXN_OUT_OF_BOUNDS)          =&gt; 10
</span><span class="hit">  rule panicCode(FUTURE_TXN)                 =&gt; 11
</span><span class="miss">  rule panicCode(INDEX_OUT_OF_BOUNDS)        =&gt; 12
</span><span class="miss">  rule panicCode(ILLEGAL_JUMP)               =&gt; 13
</span><span class="hit">  rule panicCode(ILL_TYPED_STACK)            =&gt; 14
</span><span class="hit">  rule panicCode(LOG_CALLS_EXCEEDED)         =&gt; 15
</span><span class="hit">  rule panicCode(LOG_SIZE_EXCEEDED)          =&gt; 16
</span><span class="hit">  rule panicCode(GLOBAL_BYTES_EXCEEDED)      =&gt; 17
</span><span class="hit">  rule panicCode(GLOBAL_INTS_EXCEEDED)       =&gt; 18
</span><span class="hit">  rule panicCode(LOCAL_BYTES_EXCEEDED)       =&gt; 19
</span><span class="hit">  rule panicCode(LOCAL_INTS_EXCEEDED)        =&gt; 20
</span><span class="miss">  rule panicCode(INVALID_ARGUMENT)           =&gt; 21
</span><span class="miss">  rule panicCode(STACK_OVERFLOW)             =&gt; 22
</span><span class="miss">  rule panicCode(STACK_UNDERFLOW)            =&gt; 23
</span><span class="miss">  rule panicCode(ASSERTION_VIOLATION)        =&gt; 24
</span><span class="hit">  rule panicCode(DUPLICATE_LABEL)            =&gt; 25
</span><span class="miss">  rule panicCode(IMPOSSIBLE_NEGATIVE_NUMBER) =&gt; 26
</span><span class="miss">  rule panicCode(CALLSTACK_UNDERFLOW)        =&gt; 27
</span><span class="miss">  rule panicCode(CALLSTACK_OVERFLOW)         =&gt; 28
</span><span class="hit">  rule panicCode(ITXN_REENTRY)               =&gt; 29
</span><span class="miss">  rule panicCode(MATH_BYTES_ARG_TOO_LONG)    =&gt; 30
</span><span class="hit">  rule panicCode(INSUFFICIENT_FUNDS)         =&gt; 31
</span><span class="miss">  rule panicCode(KEY_TOO_LARGE)              =&gt; 32
</span><span class="miss">  rule panicCode(BYTE_VALUE_TOO_LARGE)       =&gt; 33
</span><span class="miss">  rule panicCode(KEY_VALUE_TOO_LARGE)        =&gt; 34
</span><span class="miss">  rule panicCode(ASSERTION_VIOLATION)        =&gt; 35
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">  syntax KItem ::= panic(String)
</span><span class="noop">  // ---------------------------
</span><span class="hit">  rule &lt;k&gt; panic(S) ~&gt; _ =&gt; .K &lt;/k&gt;
</span><span class="noop">       &lt;returncode&gt; _ =&gt; 3 &lt;/returncode&gt;
</span><span class="noop">       &lt;returnstatus&gt; _ =&gt; &#34;Failure - panic: &#34; +String S &lt;/returnstatus&gt;
</span><span class="noop">       &lt;paniccode&gt; _ =&gt; panicCode(S) &lt;/paniccode&gt;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/teal/teal-stack.md">avm/teal/teal-stack.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">TEAL Stack
</span><span class="noop">==========
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module TEAL-STACK
</span><span class="noop">  imports INT
</span><span class="noop">  imports BOOL
</span><span class="noop">  imports TEAL-TYPES-SYNTAX
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">This module models the TEAL stack as a cons-list.
</span><span class="noop">The elements of the stack are values of sort `TValue`, i.e. either `TUInt64` or `TBytes`.
</span><span class="noop">
</span><span class="noop">- `.TStack` serves as the empty stack, and
</span><span class="noop">- `_:_` serves as the &#34;cons&#34; operator.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TStack ::= &#34;.TStack&#34; [klabel(.TStack), symbol, smtlib(_dotTStack)]
</span><span class="noop">                  | TValue &#34;:&#34; TStack [klabel(_:_TStack), smtlib(_TStack_)]
</span><span class="noop">  // --------------------------------------------------------------------
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">- `#take(N , WS)` keeps the first $N$ elements of a `TStack`.
</span><span class="noop">  If there are not enough elements, the resulting stack will be shorter than $N$.
</span><span class="noop">- `#drop(N , WS)` removes the first $N$ elements of a `TStack`.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TStack ::= #take ( Int , TStack ) [klabel(takeTStack), function, functional]
</span><span class="noop">  // --------------------------------------------------------------------------------------------
</span><span class="hit">  rule [#take.zero]:      #take(N, _Stack)          =&gt; .TStack
</span><span class="noop">    requires N &lt;=Int 0
</span><span class="miss">  rule [#take.base]:      #take(N, .TStack)         =&gt; .TStack
</span><span class="noop">    requires N &gt;Int 0
</span><span class="hit">  rule [#take.recursive]: #take(N, (X : XS):TStack) =&gt; X : #take(N -Int 1, XS)
</span><span class="noop">    requires N &gt;Int 0
</span><span class="noop">
</span><span class="noop">  syntax TStack ::= #drop ( Int , TStack ) [klabel(dropTStack), function, functional]
</span><span class="noop">  // --------------------------------------------------------------------------------------------
</span><span class="hit">  rule #drop(N, XS:TStack)       =&gt; XS
</span><span class="noop">    requires N &lt;=Int 0
</span><span class="miss">  rule #drop(N, .TStack)         =&gt; .TStack
</span><span class="noop">    requires N &gt;Int 0
</span><span class="hit">  rule #drop(N, (_ : XS):TStack) =&gt; #drop(N -Int 1, XS)
</span><span class="noop">      requires N &gt;Int 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">## Element Access
</span><span class="noop">
</span><span class="noop">- `S [ N ]` accesses element $N$ of $S$.
</span><span class="noop">```k
</span><span class="noop">  syntax TValue ::= TStack &#34;[&#34; Int &#34;]&#34; [function]
</span><span class="noop">  // -----------------------------------------------------------
</span><span class="hit">  rule (X : _):TStack [ N ] =&gt; X                  requires N ==Int 0
</span><span class="hit">  rule XS             [ N ] =&gt; #drop(N, XS) [ 0 ] requires N  &gt;Int 0
</span><span class="noop">                                                   andBool N  &lt;Int #sizeTStack(XS)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Int ::= #sizeTStack ( TStack )       [function, functional, smtlib(sizeTStack)]
</span><span class="noop">               | #sizeTStack ( TStack , Int ) [function, functional, klabel(sizeTStackAux),
</span><span class="noop">                                               smtlib(sizeTStackAux)]
</span><span class="noop">  // --------------------------------------------------------------------------------------------
</span><span class="hit">  rule #sizeTStack ( XS ) =&gt; #sizeTStack(XS, 0)
</span><span class="hit">  rule #sizeTStack ( .TStack, SIZE ) =&gt; SIZE
</span><span class="hit">  rule #sizeTStack ( _ : XS, SIZE )     =&gt; #sizeTStack(XS, SIZE +Int 1)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">## Stack reverse
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TStack ::= #reverse(TStack)         [function, functional]
</span><span class="noop">                  | #reverse(TStack, TStack) [function, functional]
</span><span class="noop">  // --------------------------------------------------------------
</span><span class="hit">  rule #reverse(XS)          =&gt; #reverse(XS, .TStack)
</span><span class="hit">  rule #reverse(.TStack, YS) =&gt; YS
</span><span class="hit">  rule #reverse(X : XS , YS) =&gt; #reverse(XS, X : YS)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">## Stack concatenation
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TStack ::= TStack TStack                    [function, functional]
</span><span class="noop">                 | #concatTStackImpl(TStack, TStack) [function, functional]
</span><span class="noop">  // ------------------------------------------------------------------------------
</span><span class="hit">  rule XS YS =&gt; #concatTStackImpl(#reverse(XS), YS)
</span><span class="noop">
</span><span class="hit">  rule #concatTStackImpl(.TStack, YS) =&gt; YS
</span><span class="hit">  rule #concatTStackImpl(X : XS , YS) =&gt; #concatTStackImpl(XS, X : YS)
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/teal/teal-syntax.md">avm/teal/teal-syntax.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">TEAL Grammar
</span><span class="noop">============
</span><span class="noop">
</span><span class="noop">Derived from the [TEAL specification](https://developer.algorand.org/docs/reference/teal/specification/).
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">requires &#34;avm/teal/teal-constants.md&#34;
</span><span class="noop">requires &#34;avm/teal/teal-fields.md&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">TEAL Opcode Grammar
</span><span class="noop">-------------------
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module TEAL-OPCODES
</span><span class="noop">  import TEAL-CONSTANTS
</span><span class="noop">  import TEAL-FIELDS
</span><span class="noop">
</span><span class="noop">  syntax PseudoOpCode                              // Pseudo opcodes abstracting other TEAL opcodes
</span><span class="noop">  syntax OpCode       ::= &#34;NoOpCode&#34;               // Opcodes shared by stateless and stateful TEAL
</span><span class="noop">                        | ErrOpCode
</span><span class="noop">                        | CryptoOpCode
</span><span class="noop">                        | ArithOpCode
</span><span class="noop">                        | BitOpCode
</span><span class="noop">                        | RelationalOpCode
</span><span class="noop">                        | LogicalOpCode
</span><span class="noop">                        | ByteOpCode
</span><span class="noop">                        | BlockchainOpCode
</span><span class="noop">                        | ScratchOpCode
</span><span class="noop">                        | BranchingOpCode
</span><span class="noop">                        | StackOpCode
</span><span class="noop">  syntax SigOpCode    ::= SigVerOpCode | ArgOpCode           // Opcodes used only by stateless TEAL
</span><span class="noop">  syntax AppOpCode    ::= StateOpCode
</span><span class="noop">                        | TxnGroupStateOpCode
</span><span class="noop">                        | InnerTxOpCode                      // Opcodes used only by stateful TEAL
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Generic TEAL Opcodes
</span><span class="noop">
</span><span class="noop">#### Error Handling Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax ErrOpCode ::= &#34;err&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Cryptographic Hash Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax CryptoOpCode ::= &#34;sha256&#34;
</span><span class="noop">                        | &#34;keccak256&#34;
</span><span class="noop">                        | &#34;sha512_256&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Arithmetic Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax ArithOpCode ::= UnaryArithOpCode
</span><span class="noop">                       | BinaryArithOpCode
</span><span class="noop">
</span><span class="noop">  syntax UnaryArithOpCode ::= &#34;sqrt&#34;
</span><span class="noop">
</span><span class="noop">  syntax BinaryArithOpCode ::= &#34;+&#34;
</span><span class="noop">                             | &#34;-&#34;
</span><span class="noop">                             | &#34;/&#34;
</span><span class="noop">                             | &#34;*&#34;
</span><span class="noop">                             | &#34;%&#34;
</span><span class="noop">                             | &#34;exp&#34;
</span><span class="noop">                             | &#34;addw&#34;
</span><span class="noop">                             | &#34;divmodw&#34;
</span><span class="noop">                             | &#34;divw&#34;
</span><span class="noop">                             | &#34;mulw&#34;
</span><span class="noop">                             | &#34;expw&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Bitwise Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax BitOpCode ::= NullaryBitOpCode
</span><span class="noop">                     | BinaryBitOpCode
</span><span class="noop">                     | UnaryBitOpCode
</span><span class="noop">
</span><span class="noop">  syntax BinaryBitOpCode  ::= &#34;|&#34;
</span><span class="noop">                            | &#34;&amp;&#34;
</span><span class="noop">                            | &#34;^&#34;
</span><span class="noop">                            | &#34;shl&#34;
</span><span class="noop">                            | &#34;shr&#34;
</span><span class="noop">  syntax UnaryBitOpCode   ::= &#34;~&#34;
</span><span class="noop">                            | &#34;bitlen&#34;
</span><span class="noop">  syntax NullaryBitOpCode ::= &#34;getbit&#34;
</span><span class="noop">                            | &#34;setbit&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Relational Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax RelationalOpCode ::= InequalityOpCode
</span><span class="noop">                            | EqualityOpCode
</span><span class="noop">
</span><span class="noop">  syntax InequalityOpCode ::= &#34;&lt;&#34;
</span><span class="noop">                            | &#34;&gt;&#34;
</span><span class="noop">                            | &#34;&lt;=&#34;
</span><span class="noop">                            | &#34;&gt;=&#34;
</span><span class="noop">  syntax EqualityOpCode   ::= &#34;==&#34;
</span><span class="noop">                            | &#34;!=&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Logical Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax LogicalOpCode ::= BinaryLogicalOpCode
</span><span class="noop">                         | UnaryLogicalOpCode
</span><span class="noop">
</span><span class="noop">  syntax BinaryLogicalOpCode ::= &#34;&amp;&amp;&#34;
</span><span class="noop">                               | &#34;||&#34;
</span><span class="noop">
</span><span class="noop">  syntax UnaryLogicalOpCode  ::= &#34;!&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Byte Array Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax ByteOpCode ::= UnaryByteOpCode
</span><span class="noop">                      | BinaryByteOpCode
</span><span class="noop">                      | TernaryByteOpCode
</span><span class="noop">                      | MathByteOpCode
</span><span class="noop">
</span><span class="noop">  syntax UnaryByteOpCode   ::= &#34;len&#34;
</span><span class="noop">                             | &#34;itob&#34;
</span><span class="noop">                             | &#34;btoi&#34;
</span><span class="noop">                             | &#34;substring&#34; Int Int // start position, end position
</span><span class="noop">                             | &#34;getbyte&#34;
</span><span class="noop">                             | &#34;setbyte&#34;
</span><span class="noop">                             | &#34;bzero&#34;
</span><span class="noop">                             | &#34;extract&#34; TUInt8 TUInt8 // start position, length
</span><span class="noop">
</span><span class="noop">  syntax BinaryByteOpCode  ::= &#34;concat&#34;
</span><span class="noop">                             | &#34;extract_uint16&#34;
</span><span class="noop">                             | &#34;extract_uint32&#34;
</span><span class="noop">                             | &#34;extract_uint64&#34;
</span><span class="noop">
</span><span class="noop">  syntax TernaryByteOpCode ::= &#34;substring3&#34;
</span><span class="noop">                             | &#34;extract3&#34;
</span><span class="noop">
</span><span class="noop">  syntax MathByteOpCode ::= ArithmMathByteOpCode
</span><span class="noop">                          | RelationalMathByteOpCode
</span><span class="noop">                          | LogicalMathByteOpCode
</span><span class="noop">
</span><span class="noop">  syntax ArithmMathByteOpCode ::= &#34;b+&#34;
</span><span class="noop">                                | &#34;b-&#34;
</span><span class="noop">                                | &#34;b/&#34;
</span><span class="noop">                                | &#34;b%&#34;
</span><span class="noop">                                | &#34;b*&#34;
</span><span class="noop">
</span><span class="noop">  syntax RelationalMathByteOpCode ::= InequalityMathByteOpCode
</span><span class="noop">                                    | EqualityMathByteOpCode
</span><span class="noop">
</span><span class="noop">  syntax InequalityMathByteOpCode ::= &#34;b&lt;&#34;
</span><span class="noop">                                    | &#34;b&gt;&#34;
</span><span class="noop">                                    | &#34;b&lt;=&#34;
</span><span class="noop">                                    | &#34;b&gt;=&#34;
</span><span class="noop">
</span><span class="noop">  syntax EqualityMathByteOpCode ::= &#34;b==&#34;
</span><span class="noop">                                  | &#34;b!=&#34;
</span><span class="noop">
</span><span class="noop">  syntax LogicalMathByteOpCode ::= BinaryLogicalMathByteOpCode
</span><span class="noop">                                 | UnaryLogicalMathByteOpCode
</span><span class="noop">
</span><span class="noop">  syntax BinaryLogicalMathByteOpCode ::= &#34;b|&#34;
</span><span class="noop">                                       | &#34;b&amp;&#34;
</span><span class="noop">                                       | &#34;b^&#34;
</span><span class="noop">
</span><span class="noop">  syntax UnaryLogicalMathByteOpCode ::= &#34;b~&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Constant Loading Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax OpCode ::= &#34;intcblock&#34; TUInt64 TValueNeList
</span><span class="noop">                  | &#34;intc&#34; Int // Int Constant Index
</span><span class="noop">                  | &#34;intc_0&#34;
</span><span class="noop">                  | &#34;intc_1&#34;
</span><span class="noop">                  | &#34;intc_2&#34;
</span><span class="noop">                  | &#34;intc_3&#34;
</span><span class="noop">                  | &#34;bytecblock&#34; TUInt64 TValuePairNeList
</span><span class="noop">                  | &#34;bytec&#34; Int // Byte Constant Index
</span><span class="noop">                  | &#34;bytec_0&#34;
</span><span class="noop">                  | &#34;bytec_1&#34;
</span><span class="noop">                  | &#34;bytec_2&#34;
</span><span class="noop">                  | &#34;bytec_3&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">##### Constant Loading Pseudo-Ops
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax PseudoOpCode ::= &#34;int&#34; PseudoTUInt64
</span><span class="noop">                        | &#34;byte&#34; TBytesLiteral
</span><span class="noop">                        | &#34;addr&#34; TAddressLiteral
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Blockchain State Accessors
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax BlockchainOpCode ::= &#34;txn&#34; TxnField            // transaction field index
</span><span class="noop">                            | &#34;txn&#34; TxnaField Int       // transaction field index, list index
</span><span class="noop">                                                        // =&gt; Note: An extended version of txn not given in the reference docs but used in examples
</span><span class="noop">                            | &#34;gtxn&#34; Int TxnField       // transaction group index, transaction field index
</span><span class="noop">                            | &#34;gtxns&#34; TxnField          // transaction field index
</span><span class="noop">                            | &#34;txna&#34; TxnaField Int      // transaction field index, transaction field array index
</span><span class="noop">                            | &#34;txnas&#34; TxnaField         // transaction field index
</span><span class="noop">                            | &#34;gtxna&#34; Int TxnaField Int // transaction group index, transaction field index, transaction field array index
</span><span class="noop">                            | &#34;gtxnas&#34; Int TxnaField    // transaction group index, transaction field index
</span><span class="noop">                            | &#34;gtxnsa&#34; TxnaField Int    // transaction field index, transaction field array index
</span><span class="noop">                            | &#34;gtxnsas&#34; TxnaField       // transaction field index
</span><span class="noop">                            | &#34;global&#34; GlobalField      // global field index
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Scratch Space Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax ScratchOpCode ::= LoadOpCode
</span><span class="noop">                         | StoreOpCode
</span><span class="noop">  syntax LoadOpCode    ::= &#34;load&#34;  Int // position in scratch space to load from
</span><span class="noop">                         | &#34;loads&#34;     // Same as previous, but the position is on stack
</span><span class="noop">  syntax StoreOpCode   ::= &#34;store&#34; Int // position in scratch space to store to
</span><span class="noop">                         | &#34;stores&#34;    // Same as previous, but the position is on stack
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Flow Control Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Label [token]
</span><span class="noop">
</span><span class="noop">  syntax BranchingOpCode ::= CondBranchOpCode
</span><span class="noop">                           | JumpOpCode
</span><span class="noop">                           | ReturnOpCode
</span><span class="noop">                           | AssertOpCode
</span><span class="noop">                           | SubroutineOpCode
</span><span class="noop">
</span><span class="noop">  syntax CondBranchOpCode ::= &#34;bnz&#34; Label          // forward branch offset, big endian
</span><span class="noop">                            | &#34;bz&#34;  Label          // forward branch offset, big endian
</span><span class="noop">  syntax JumpOpCode       ::= &#34;b&#34;   Label          // forward branch offset, big endian
</span><span class="noop">  syntax ReturnOpCode     ::= &#34;return&#34;
</span><span class="noop">  syntax AssertOpCode     ::= &#34;assert&#34;
</span><span class="noop">  syntax SubroutineOpCode ::= &#34;callsub&#34; Label
</span><span class="noop">                            | &#34;retsub&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Stack Manipulation Operations
</span><span class="noop">```k
</span><span class="noop">  syntax StackOpCode      ::= NullaryStackOpCode
</span><span class="noop">                            | UnaryStackOpCode
</span><span class="noop">                            | BinaryStackOpCode
</span><span class="noop">                            | TernaryStackOpCode
</span><span class="noop">                            | NAryStackOpCode
</span><span class="noop">
</span><span class="noop">  syntax NullaryStackOpCode ::= &#34;pushint&#34; PseudoTUInt64
</span><span class="noop">                              | &#34;pushbytes&#34; TBytesLiteral
</span><span class="noop">
</span><span class="noop">  syntax UnaryStackOpCode  ::= &#34;pop&#34;
</span><span class="noop">                             | &#34;dup&#34;
</span><span class="noop">
</span><span class="noop">  syntax BinaryStackOpCode ::= &#34;dup2&#34;
</span><span class="noop">                             | &#34;swap&#34;
</span><span class="noop">
</span><span class="noop">  syntax TernaryStackOpCode ::= &#34;select&#34;
</span><span class="noop">
</span><span class="noop">  syntax NAryStackOpCode    ::= &#34;dig&#34; Int
</span><span class="noop">                              | &#34;cover&#34; Int
</span><span class="noop">                              | &#34;uncover&#34; Int
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Stateless TEAL Operations
</span><span class="noop">
</span><span class="noop">#### Signature Verification Operations
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax SigVerOpCode ::= &#34;ed25519verify&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Logic Signature Argument Accessors
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax ArgOpCode ::= &#34;arg&#34; Int // Int arg index
</span><span class="noop">                     | &#34;args&#34;    // arg index on stack
</span><span class="noop">                     | &#34;arg_0&#34;
</span><span class="noop">                     | &#34;arg_1&#34;
</span><span class="noop">                     | &#34;arg_2&#34;
</span><span class="noop">                     | &#34;arg_3&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Stateful TEAL Operations
</span><span class="noop">
</span><span class="noop">#### Application State Accessors
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax StateOpCode ::= UnaryStateOpCode
</span><span class="noop">                       | BinaryStateOpCode
</span><span class="noop">                       | TernaryStateOpCode
</span><span class="noop">
</span><span class="noop">  syntax UnaryStateOpCode   ::= &#34;balance&#34;
</span><span class="noop">                              | &#34;app_global_del&#34;
</span><span class="noop">                              | &#34;app_global_get&#34;
</span><span class="noop">                              | &#34;asset_params_get&#34; AssetParamsField
</span><span class="noop">                              | &#34;acct_params_get&#34; AccountParamsField
</span><span class="noop">                              | &#34;app_params_get&#34; AppParamsField
</span><span class="noop">                              | &#34;min_balance&#34;
</span><span class="noop">                              | &#34;log&#34;
</span><span class="noop">  syntax BinaryStateOpCode  ::= &#34;app_opted_in&#34;
</span><span class="noop">                              | &#34;app_local_get&#34;
</span><span class="noop">                              | &#34;app_global_get_ex&#34;
</span><span class="noop">                              | &#34;app_global_put&#34;
</span><span class="noop">                              | &#34;app_local_del&#34;
</span><span class="noop">                              | &#34;asset_holding_get&#34; AssetHoldingField
</span><span class="noop">  syntax TernaryStateOpCode ::= &#34;app_local_get_ex&#34;
</span><span class="noop">                              | &#34;app_local_put&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Access to past transactions in the group
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TxnGroupStateOpCode ::= NullaryTxnGroupStateOpCode
</span><span class="noop">                               | UnaryTxnGroupStateOpCode
</span><span class="noop">                               | BinaryTxnGroupStateOpCode
</span><span class="noop">
</span><span class="noop">  syntax NullaryTxnGroupStateOpCode ::= &#34;gaid&#34; Int // transaction index
</span><span class="noop">                                      | &#34;gload&#34; Int Int // transaction index, scratch position
</span><span class="noop">
</span><span class="noop">  syntax UnaryTxnGroupStateOpCode ::= &#34;gaids&#34;
</span><span class="noop">                                    | &#34;gloads&#34; Int // scratch position
</span><span class="noop">
</span><span class="noop">  syntax BinaryTxnGroupStateOpCode ::= &#34;gloadss&#34;
</span><span class="noop">
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">#### Inner transaction control
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax InnerTxOpCode ::= &#34;itxn_begin&#34;
</span><span class="noop">                         | &#34;itxn_submit&#34;
</span><span class="noop">                         | &#34;itxn_field&#34; TxnFieldTop
</span><span class="noop">                         | &#34;itxn_next&#34;
</span><span class="noop">                         | &#34;itxn&#34; TxnField
</span><span class="noop">                         | &#34;itxna&#34; TxnaField Int
</span><span class="noop">                         | &#34;itxnas&#34; TxnaField
</span><span class="noop">                         | &#34;gitxnas&#34; Int TxnaField
</span><span class="noop">                         | &#34;gitxn&#34; Int TxnField
</span><span class="noop">                         | &#34;gitxna&#34; Int TxnaField Int
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">endmodule
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">TEAL Program Definition
</span><span class="noop">-----------------------
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module TEAL-SYNTAX
</span><span class="noop">  import TEAL-OPCODES
</span><span class="noop">  import INT
</span><span class="noop">
</span><span class="noop">  syntax LabelCode ::= Label &#34;:&#34;
</span><span class="noop">
</span><span class="noop">  syntax TealOpCode ::= PseudoOpCode | OpCode | SigOpCode | AppOpCode
</span><span class="noop">  syntax TealOpCodeOrLabel ::= TealOpCode | LabelCode
</span><span class="noop">
</span><span class="noop">  syntax TealPragmas ::= TealPragma TealPragmas | TealPragma
</span><span class="noop">  syntax TealPragma ::= &#34;#pragma&#34; PragmaDirective
</span><span class="noop">  syntax PragmaDirective ::= VersionPragma
</span><span class="noop">
</span><span class="noop">  syntax TealMode ::= &#34;stateless&#34; | &#34;stateful&#34; | &#34;undefined&#34;
</span><span class="noop">
</span><span class="noop">  syntax VersionPragma ::= &#34;version&#34; Int
</span><span class="noop">
</span><span class="noop">  syntax TealPgm ::= TealOpCodeOrLabel
</span><span class="noop">                   | TealOpCodeOrLabel TealPgm
</span><span class="noop">  syntax TealInputPgm ::= TealPragmas TealPgm | TealPgm
</span><span class="noop">
</span><span class="noop">  syntax TealPrograms ::= TealInputPgm &#34;;&#34; TealPrograms | &#34;.TealPrograms&#34; [klabel(.TealPrograms), symbol]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">We provide a function to extract a teal program by index from the syntactic list of input programs.
</span><span class="noop">If the requested index is out of bounds, a trivial error program is returned.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TealInputPgm ::= getTealByIndex(TealPrograms, Int) [function]
</span><span class="noop">  //------------------------------------------------------------------
</span><span class="hit">  rule getTealByIndex(PGM;_, 0) =&gt; PGM
</span><span class="hit">  rule getTealByIndex(_;REST, IDX) =&gt; getTealByIndex(REST, IDX -Int 1)
</span><span class="noop">    requires IDX &gt;Int 0
</span><span class="miss">  rule getTealByIndex(.TealPrograms, _) =&gt; #pragma version 3 err
</span><span class="noop">endmodule
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### TEAL Program Parser
</span><span class="noop">
</span><span class="noop">This module defines the grammar used to parse TEAL programs.
</span><span class="noop">Note that this module is _not_ imported by any module defining semantic rules.
</span><span class="noop">
</span><span class="noop">It includes regular expressions that define all _token_ sorts.
</span><span class="noop">A token sort is special sort that has no constructors in K; instead, token
</span><span class="noop">sorts have a single built-in constructor which is essentially a wrapped
</span><span class="noop">string literal.
</span><span class="noop">
</span><span class="noop">Token sorts are needed to keep our syntactic definitions unambiguous.
</span><span class="noop">Otherwise, highly generic syntactic categories in TEAL, such as TEAL labels,
</span><span class="noop">would confuse the K tokenizer when parsing our core semantic rules.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module TEAL-PARSER-SYNTAX
</span><span class="noop">  imports TEAL-SYNTAX
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">We define the syntax of TEAL&#39;s comments (using K&#39;s built-in sort `#Layout`), along with TEAL&#39;s labels and hexadecimal byte literals.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax #Layout  ::= r&#34;\\/\\/[^\\n\\r]*&#34; // comments
</span><span class="noop">                    | r&#34;([\\ \\n\\r\\t])&#34; // whitespace
</span><span class="noop">
</span><span class="noop">  syntax lexical Digit     = r&#34;[0-9]&#34;
</span><span class="noop">  syntax lexical HexDigit  = r&#34;[0-9a-fA-F]&#34;
</span><span class="noop">  syntax lexical Alpha     = r&#34;[a-zA-Z]&#34;
</span><span class="noop">  syntax lexical Alnum     = r&#34;{Alpha}|{Digit}&#34;
</span><span class="noop">  syntax lexical AlnumUbar = r&#34;{Alnum}|_&#34;
</span><span class="noop">  syntax lexical Special   = r&#34;[-!?+&lt;&gt;=/*]&#34;
</span><span class="noop">
</span><span class="noop">  syntax Label           ::= r&#34;({AlnumUbar}|{Special})+&#34; [token]
</span><span class="noop">  syntax HexToken        ::= r&#34;0x{HexDigit}+&#34;            [prec(2),token]
</span><span class="noop">  syntax TAddressLiteral ::= r&#34;[0-9A-Z]{58}&#34;             [prec(1),token]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">NOTE: the following definitions are _disabled_.
</span><span class="noop">
</span><span class="noop">```disabled
</span><span class="noop">  syntax B64Encoded ::= r&#34;[a-zA-Z0-9\\+\\/=]+&#34; [token]
</span><span class="noop">  syntax B32Encoded ::= r&#34;[A-Z2-7=]+&#34;          [token]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">endmodule
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### TEAL Unparser
</span><span class="noop">
</span><span class="noop">This module takes a `TealPgm` value and prints out a string that corresponds to
</span><span class="noop">it.
</span><span class="noop">
</span><span class="noop">The opcodes that have no immediate arguments do not require specific rules, since
</span><span class="noop">they are handled by the `[owise]` rule of the `unparseTEALOp` function. The opcodes
</span><span class="noop">which are not just tokens, i.e. have at least one immediate argument, need
</span><span class="noop">an `unparseTEALOp` rule.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module TEAL-UNPARSER
</span><span class="noop">  imports TEAL-SYNTAX
</span><span class="noop">  imports TEAL-TYPES
</span><span class="noop">  imports STRING
</span><span class="noop">
</span><span class="noop">  syntax String ::= unparseTEAL(TealPgm) [function]
</span><span class="noop">  // ----------------------------------------------
</span><span class="noop">  rule unparseTEAL(O:TealOpCodeOrLabel TP:TealPgm)
</span><span class="noop">    =&gt; unparseTEAL(O) +String &#34;\n&#34; +String unparseTEAL(TP)
</span><span class="noop">
</span><span class="noop">  rule unparseTEAL(err)                           =&gt; &#34;err&#34;
</span><span class="noop">  rule unparseTEAL(sha256)                        =&gt; &#34;sha256&#34;
</span><span class="noop">  rule unparseTEAL(keccak256)                     =&gt; &#34;keccak256&#34;
</span><span class="noop">  rule unparseTEAL(sha512_256)                    =&gt; &#34;sha512_256&#34;
</span><span class="noop">  rule unparseTEAL(+)                             =&gt; &#34;+&#34;
</span><span class="noop">  rule unparseTEAL(-)                             =&gt; &#34;-&#34;
</span><span class="noop">  rule unparseTEAL(/)                             =&gt; &#34;/&#34;
</span><span class="noop">  rule unparseTEAL(*)                             =&gt; &#34;*&#34;
</span><span class="noop">  rule unparseTEAL(%)                             =&gt; &#34;%&#34;
</span><span class="noop">  rule unparseTEAL(exp)                           =&gt; &#34;exp&#34;
</span><span class="noop">  rule unparseTEAL(addw)                          =&gt; &#34;addw&#34;
</span><span class="noop">  rule unparseTEAL(divmodw)                       =&gt; &#34;divmodw&#34;
</span><span class="noop">  rule unparseTEAL(divw)                          =&gt; &#34;divw&#34;
</span><span class="noop">  rule unparseTEAL(mulw)                          =&gt; &#34;mulw&#34;
</span><span class="noop">  rule unparseTEAL(expw)                          =&gt; &#34;expw&#34;
</span><span class="noop">  rule unparseTEAL(|)                             =&gt; &#34;|&#34;
</span><span class="noop">  rule unparseTEAL(&amp;)                             =&gt; &#34;&amp;&#34;
</span><span class="noop">  rule unparseTEAL(^)                             =&gt; &#34;^&#34;
</span><span class="noop">  rule unparseTEAL(~)                             =&gt; &#34;~&#34;
</span><span class="noop">  rule unparseTEAL(getbit)                        =&gt; &#34;getbit&#34;
</span><span class="noop">  rule unparseTEAL(setbit)                        =&gt; &#34;setbit&#34;
</span><span class="noop">  rule unparseTEAL(&lt;)                             =&gt; &#34;&lt;&#34;
</span><span class="noop">  rule unparseTEAL(&gt;)                             =&gt; &#34;&gt;&#34;
</span><span class="noop">  rule unparseTEAL(&lt;=)                            =&gt; &#34;&lt;=&#34;
</span><span class="noop">  rule unparseTEAL(&gt;=)                            =&gt; &#34;&gt;=&#34;
</span><span class="noop">  rule unparseTEAL(==)                            =&gt; &#34;==&#34;
</span><span class="noop">  rule unparseTEAL(!=)                            =&gt; &#34;!=&#34;
</span><span class="noop">  rule unparseTEAL(&amp;&amp;)                            =&gt; &#34;&amp;&amp;&#34;
</span><span class="noop">  rule unparseTEAL(||)                            =&gt; &#34;||&#34;
</span><span class="noop">  rule unparseTEAL(!)                             =&gt; &#34;!&#34;
</span><span class="noop">  rule unparseTEAL(len)                           =&gt; &#34;len&#34;
</span><span class="noop">  rule unparseTEAL(itob)                          =&gt; &#34;itob&#34;
</span><span class="noop">  rule unparseTEAL(btoi)                          =&gt; &#34;btoi&#34;
</span><span class="noop">  rule unparseTEAL(substring Start End)           =&gt; &#34;substring&#34; +&amp;+ Int2String(Start:Int) +&amp;+ Int2String(End:Int)
</span><span class="noop">  rule unparseTEAL(getbyte)                       =&gt; &#34;getbyte&#34;
</span><span class="noop">  rule unparseTEAL(setbyte)                       =&gt; &#34;setbyte&#34;
</span><span class="noop">  rule unparseTEAL(concat)                        =&gt; &#34;concat&#34;
</span><span class="noop">  rule unparseTEAL(extract Start Length)          =&gt; &#34;extract&#34; +&amp;+ Int2String(Start:Int) +&amp;+ Int2String(Length:Int)
</span><span class="noop">  rule unparseTEAL(b+)                            =&gt; &#34;b+&#34;
</span><span class="noop">  rule unparseTEAL(b-)                            =&gt; &#34;b-&#34;
</span><span class="noop">  rule unparseTEAL(b/)                            =&gt; &#34;b/&#34;
</span><span class="noop">  rule unparseTEAL(b*)                            =&gt; &#34;b*&#34;
</span><span class="noop">  rule unparseTEAL(b&lt;)                            =&gt; &#34;b&lt;&#34;
</span><span class="noop">  rule unparseTEAL(b&gt;)                            =&gt; &#34;b&gt;&#34;
</span><span class="noop">  rule unparseTEAL(b&lt;=)                           =&gt; &#34;b&lt;=&#34;
</span><span class="noop">  rule unparseTEAL(b&gt;=)                           =&gt; &#34;b&gt;=&#34;
</span><span class="noop">  rule unparseTEAL(b==)                           =&gt; &#34;b==&#34;
</span><span class="noop">  rule unparseTEAL(b!=)                           =&gt; &#34;b!=&#34;
</span><span class="noop">  rule unparseTEAL(b%)                            =&gt; &#34;b%&#34;
</span><span class="noop">  rule unparseTEAL(b|)                            =&gt; &#34;b|&#34;
</span><span class="noop">  rule unparseTEAL(b&amp;)                            =&gt; &#34;b&amp;&#34;
</span><span class="noop">  rule unparseTEAL(b^)                            =&gt; &#34;b^&#34;
</span><span class="noop">  rule unparseTEAL(b~)                            =&gt; &#34;b~&#34;
</span><span class="noop">  rule unparseTEAL(substring3)                    =&gt; &#34;substring3&#34;
</span><span class="noop">  rule unparseTEAL(extract3)                      =&gt; &#34;extract3&#34;
</span><span class="noop">  rule unparseTEAL(extract_uint16)                =&gt; &#34;extract_uint16&#34;
</span><span class="noop">  rule unparseTEAL(extract_uint32)                =&gt; &#34;extract_uint32&#34;
</span><span class="noop">  rule unparseTEAL(extract_uint64)                =&gt; &#34;extract_uint64&#34;
</span><span class="noop">  rule unparseTEAL(intcblock Size IntConsts)      =&gt; &#34;intcblock&#34; +&amp;+ Int2String(Size:Int) +&amp;+ TValueList2String(IntConsts:TValueNeList)
</span><span class="noop">  rule unparseTEAL(intc Idx)                      =&gt; &#34;intc&#34; +&amp;+ Int2String(Idx:Int)
</span><span class="noop">  rule unparseTEAL(intc_0)                        =&gt; &#34;intc_0&#34;
</span><span class="noop">  rule unparseTEAL(intc_1)                        =&gt; &#34;intc_1&#34;
</span><span class="noop">  rule unparseTEAL(intc_2)                        =&gt; &#34;intc_2&#34;
</span><span class="noop">  rule unparseTEAL(intc_3)                        =&gt; &#34;intc_3&#34;
</span><span class="noop">  rule unparseTEAL(pushint I:Int)                 =&gt; &#34;pushint&#34; +&amp;+ Int2String(I)
</span><span class="noop">  rule unparseTEAL(bytecblock Size ByteConsts)    =&gt; &#34;bytecblock&#34; +&amp;+ Int2String(Size:Int) +&amp;+ TValuePairList2String(ByteConsts:TValuePairNeList)
</span><span class="noop">  rule unparseTEAL(bytec Idx)                     =&gt; &#34;bytec&#34; +&amp;+ Int2String(Idx:Int)
</span><span class="noop">  rule unparseTEAL(bytec_0)                       =&gt; &#34;bytec_0&#34;
</span><span class="noop">  rule unparseTEAL(bytec_1)                       =&gt; &#34;bytec_1&#34;
</span><span class="noop">  rule unparseTEAL(bytec_2)                       =&gt; &#34;bytec_2&#34;
</span><span class="noop">  rule unparseTEAL(bytec_3)                       =&gt; &#34;bytec_3&#34;
</span><span class="noop">  rule unparseTEAL(pushbytes ByteConst)           =&gt; &#34;pushbytes&#34; +&amp;+ TValue2String(ByteConst:TBytesLiteral)
</span><span class="noop">  rule unparseTEAL(int I:Int)                     =&gt; &#34;int&#34; +&amp;+ Int2String(I)
</span><span class="noop">  rule unparseTEAL(int I:TUInt64Token)            =&gt; &#34;int&#34; +&amp;+ IntToken2String(I)
</span><span class="noop">  rule unparseTEAL(byte ByteConst)                =&gt; &#34;byte&#34; +&amp;+ TValue2String(ByteConst:TBytesLiteral)
</span><span class="noop">  rule unparseTEAL(addr AddrConst)                =&gt; &#34;addr&#34; +&amp;+ TValue2String(AddrConst:TAddressLiteral)
</span><span class="noop">  rule unparseTEAL(txn FieldName)                 =&gt; &#34;txn&#34; +&amp;+ TealField2String(FieldName:TxnField)
</span><span class="noop">  rule unparseTEAL(txn FieldName ArrIdx)          =&gt; &#34;txn&#34; +&amp;+ TealField2String(FieldName:TxnaField) +&amp;+ Int2String(ArrIdx:Int)
</span><span class="noop">  rule unparseTEAL(gtxn TxnIdx TxnField)          =&gt; &#34;gtxn&#34; +&amp;+ Int2String(TxnIdx:Int) +&amp;+ TealField2String(TxnField:TxnField)
</span><span class="noop">  rule unparseTEAL(gtxns TxnField)                =&gt; &#34;gtxns&#34; +&amp;+ TealField2String(TxnField:TxnField)
</span><span class="noop">  rule unparseTEAL(txna FieldName ArrIdx)         =&gt; &#34;txna&#34; +&amp;+ TealField2String(FieldName:TxnaField) +&amp;+ Int2String(ArrIdx:Int)
</span><span class="noop">  rule unparseTEAL(txnas FieldName)               =&gt; &#34;txnas&#34; +&amp;+ TealField2String(FieldName:TxnaField)
</span><span class="noop">  rule unparseTEAL(gtxna TxnIdx FieldName ArrIdx) =&gt; &#34;gtxna&#34; +&amp;+ Int2String(TxnIdx:Int) +&amp;+ TealField2String(FieldName:TxnaField) +&amp;+ Int2String(ArrIdx:Int)
</span><span class="noop">  rule unparseTEAL(gtxnas TxnIdx FieldName)       =&gt; &#34;gtxnas&#34; +&amp;+ Int2String(TxnIdx:Int) +&amp;+ TealField2String(FieldName:TxnaField)
</span><span class="noop">  rule unparseTEAL(gtxnsa FieldName ArrIdx)       =&gt; &#34;gtxnsa&#34; +&amp;+ TealField2String(FieldName:TxnaField) +&amp;+ Int2String(ArrIdx:Int)
</span><span class="noop">  rule unparseTEAL(gtxnsas FieldName)             =&gt; &#34;gtxnsas&#34; +&amp;+ TealField2String(FieldName:TxnaField)
</span><span class="noop">  rule unparseTEAL(global FieldName)              =&gt; &#34;global&#34; +&amp;+ TealField2String(FieldName:GlobalField)
</span><span class="noop">  rule unparseTEAL(load SlotIdx)                  =&gt; &#34;load&#34; +&amp;+ Int2String(SlotIdx:Int)
</span><span class="noop">  rule unparseTEAL(loads)                         =&gt; &#34;loads&#34;
</span><span class="noop">  rule unparseTEAL(store SlotIdx)                 =&gt; &#34;store&#34; +&amp;+ Int2String(SlotIdx:Int)
</span><span class="noop">  rule unparseTEAL(stores)                        =&gt; &#34;stores&#34;
</span><span class="noop">  rule unparseTEAL(bnz Lbl)                       =&gt; &#34;bnz&#34; +&amp;+ Label2String(Lbl:Label)
</span><span class="noop">  rule unparseTEAL(bz Lbl)                        =&gt; &#34;bz&#34; +&amp;+ Label2String(Lbl:Label)
</span><span class="noop">  rule unparseTEAL(b Lbl)                         =&gt; &#34;b&#34; +&amp;+ Label2String(Lbl:Label)
</span><span class="noop">  rule unparseTEAL(Lbl :)                         =&gt; Label2String(Lbl) +String &#34;:&#34;
</span><span class="noop">  rule unparseTEAL(return)                        =&gt; &#34;return&#34;
</span><span class="noop">  rule unparseTEAL(assert)                        =&gt; &#34;assert&#34;
</span><span class="noop">  rule unparseTEAL(pop)                           =&gt; &#34;pop&#34;
</span><span class="noop">  rule unparseTEAL(dup)                           =&gt; &#34;dup&#34;
</span><span class="noop">  rule unparseTEAL(dup2)                          =&gt; &#34;dup2&#34;
</span><span class="noop">  rule unparseTEAL(dig N)                         =&gt; &#34;dig&#34; +&amp;+ Int2String(N)
</span><span class="noop">  rule unparseTEAL(cover N)                       =&gt; &#34;cover&#34; +&amp;+ Int2String(N)
</span><span class="noop">  rule unparseTEAL(uncover N)                     =&gt; &#34;uncover&#34; +&amp;+ Int2String(N)
</span><span class="noop">  rule unparseTEAL(select)                        =&gt; &#34;select&#34;
</span><span class="noop">  rule unparseTEAL(swap)                          =&gt; &#34;swap&#34;
</span><span class="noop">  rule unparseTEAL(ed25519verify)                 =&gt; &#34;ed25519verify&#34;
</span><span class="noop">  rule unparseTEAL(arg ArgIdx:Int)                =&gt; &#34;arg&#34; +&amp;+ Int2String(ArgIdx)
</span><span class="noop">  rule unparseTEAL(args)                          =&gt; &#34;args&#34;
</span><span class="noop">  rule unparseTEAL(arg_0)                         =&gt; &#34;arg_0&#34;
</span><span class="noop">  rule unparseTEAL(arg_1)                         =&gt; &#34;arg_1&#34;
</span><span class="noop">  rule unparseTEAL(arg_2)                         =&gt; &#34;arg_2&#34;
</span><span class="noop">  rule unparseTEAL(arg_3)                         =&gt; &#34;arg_3&#34;
</span><span class="noop">  rule unparseTEAL(balance)                       =&gt; &#34;balance&#34;
</span><span class="noop">  rule unparseTEAL(app_global_del)                =&gt; &#34;app_global_del&#34;
</span><span class="noop">  rule unparseTEAL(app_global_get)                =&gt; &#34;app_global_get&#34;
</span><span class="noop">  rule unparseTEAL(asset_params_get FieldName)    =&gt; &#34;asset_params_get&#34; +&amp;+ TealField2String(FieldName:AssetParamsField)
</span><span class="noop">  rule unparseTEAL(acct_params_get FieldName)     =&gt; &#34;acct_params_get&#34; +&amp;+ TealField2String(FieldName:AccountParamsField)
</span><span class="noop">  rule unparseTEAL(app_params_get FieldName)      =&gt; &#34;app_params_get&#34; +&amp;+ TealField2String(FieldName:AppParamsField)
</span><span class="noop">  rule unparseTEAL(min_balance)                   =&gt; &#34;min_balance&#34;
</span><span class="noop">  rule unparseTEAL(log)                           =&gt; &#34;log&#34;
</span><span class="noop">  rule unparseTEAL(app_opted_in)                  =&gt; &#34;app_opted_in&#34;
</span><span class="noop">  rule unparseTEAL(app_local_get)                 =&gt; &#34;app_local_get&#34;
</span><span class="noop">  rule unparseTEAL(app_global_get_ex)             =&gt; &#34;app_global_get_ex&#34;
</span><span class="noop">  rule unparseTEAL(app_global_put)                =&gt; &#34;app_global_put&#34;
</span><span class="noop">  rule unparseTEAL(app_local_del)                 =&gt; &#34;app_local_del&#34;
</span><span class="noop">  rule unparseTEAL(asset_holding_get FieldName)   =&gt; &#34;asset_holding_get&#34; +&amp;+ TealField2String(FieldName:AssetHoldingField)
</span><span class="noop">  rule unparseTEAL(app_local_get_ex)              =&gt; &#34;app_local_get_ex&#34;
</span><span class="noop">  rule unparseTEAL(app_local_put)                 =&gt; &#34;app_local_put&#34;
</span><span class="noop">  rule unparseTEAL(gaid N)                        =&gt; &#34;gaid&#34; +&amp;+ Int2String(N)
</span><span class="noop">  rule unparseTEAL(gload N M)                     =&gt; &#34;gload&#34; +&amp;+ Int2String(N) +&amp;+ Int2String(M)
</span><span class="noop">  rule unparseTEAL(gaids)                         =&gt; &#34;gaids&#34;
</span><span class="noop">  rule unparseTEAL(gloads N)                      =&gt; &#34;gloads&#34; +&amp;+ Int2String(N)
</span><span class="noop">  rule unparseTEAL(gloadss)                       =&gt; &#34;gloadss&#34;
</span><span class="noop">  rule unparseTEAL(itxn_begin)                    =&gt; &#34;itxn_begin&#34;
</span><span class="noop">  rule unparseTEAL(itxn_submit)                   =&gt; &#34;itxn_submit&#34;
</span><span class="noop">  rule unparseTEAL(itxn_field FieldName)          =&gt; &#34;itxn_field&#34; +&amp;+ TealField2String(FieldName:TxnField)
</span><span class="noop">  rule unparseTEAL(itxn_next)                     =&gt; &#34;itxn_next&#34;
</span><span class="noop">  rule unparseTEAL(itxn FieldName)                =&gt; &#34;itxn&#34; +&amp;+ TealField2String(FieldName:TxnField)
</span><span class="noop">  rule unparseTEAL(itxna FieldName N)             =&gt; &#34;itxna&#34; +&amp;+ TealField2String(FieldName:TxnField) +&amp;+ Int2String(N)
</span><span class="noop">  rule unparseTEAL(gitxn T FieldName)             =&gt; &#34;itxn&#34; +&amp;+ Int2String(T) +&amp;+ TealField2String(FieldName:TxnField)
</span><span class="noop">  rule unparseTEAL(gitxna T FieldName N)          =&gt; &#34;itxna&#34; +&amp;+ Int2String(T) +&amp;+ TealField2String(FieldName:TxnField) +&amp;+ Int2String(N)
</span><span class="noop">  rule unparseTEAL(itxnas FieldName)              =&gt; &#34;itxnas&#34; +&amp;+ TealField2String(FieldName:TxnaField)
</span><span class="noop">  rule unparseTEAL(gitxnas T FieldName)           =&gt; &#34;gitxnas&#34; +&amp;+ Int2String(T) +&amp;+ TealField2String(FieldName:TxnaField)
</span><span class="noop">
</span><span class="noop">  syntax String ::= left:
</span><span class="noop">                    String &#34;+&amp;+&#34; String       [function]
</span><span class="noop">  // ---------------------------------------------------
</span><span class="noop">  rule S:String +&amp;+ S2:String  =&gt; S +String &#34; &#34; +String S2
</span><span class="noop">
</span><span class="noop">  syntax String ::= Label2String(Label) [function, functional, hook(STRING.token2string)]
</span><span class="noop">
</span><span class="noop">  syntax String ::= TealField2String(GlobalField)        [function]
</span><span class="noop">                  | TealField2String(AssetHoldingField)  [function]
</span><span class="noop">                  | TealField2String(AssetParamsField)   [function]
</span><span class="noop">                  | TealField2String(AppParamsField)     [function]
</span><span class="noop">                  | TealField2String(TxnField)           [function]
</span><span class="noop">                  | TealField2String(TxnaField)          [function]
</span><span class="noop">                  | TealField2String(AccountParamsField) [function]
</span><span class="noop">  // ---------------------------------------------------------------------------------------
</span><span class="noop">  rule TealField2String(MinTxnFee)                =&gt; &#34;MinTxnFee&#34;
</span><span class="noop">  rule TealField2String(MinBalance)               =&gt; &#34;MinBalance&#34;
</span><span class="noop">  rule TealField2String(MaxTxnLife)               =&gt; &#34;MaxTxnLife&#34;
</span><span class="noop">  rule TealField2String(ZeroAddress)              =&gt; &#34;ZeroAddress&#34;
</span><span class="noop">  rule TealField2String(GroupSize)                =&gt; &#34;GroupSize&#34;
</span><span class="noop">  rule TealField2String(LogicSigVersion)          =&gt; &#34;LogicSigVersion&#34;
</span><span class="noop">  rule TealField2String(Round)                    =&gt; &#34;Round&#34;
</span><span class="noop">  rule TealField2String(LatestTimestamp)          =&gt; &#34;LatestTimestamp&#34;
</span><span class="noop">  rule TealField2String(CurrentApplicationID)     =&gt; &#34;CurrentApplicationID&#34;
</span><span class="noop">  rule TealField2String(AssetBalance)             =&gt; &#34;AssetBalance&#34;
</span><span class="noop">  rule TealField2String(AssetFrozen)              =&gt; &#34;AssetFrozen&#34;
</span><span class="noop">  rule TealField2String(AssetTotal)               =&gt; &#34;AssetTotal&#34;
</span><span class="noop">  rule TealField2String(AssetDecimals)            =&gt; &#34;AssetDecimals&#34;
</span><span class="noop">  rule TealField2String(AssetDefaultFrozen)       =&gt; &#34;AssetDefaultFrozen&#34;
</span><span class="noop">  rule TealField2String(AssetUnitName)            =&gt; &#34;AssetUnitName&#34;
</span><span class="noop">  rule TealField2String(AssetName)                =&gt; &#34;AssetName&#34;
</span><span class="noop">  rule TealField2String(AssetURL)                 =&gt; &#34;AssetURL&#34;
</span><span class="noop">  rule TealField2String(AssetMetadataHash)        =&gt; &#34;AssetMetadataHash&#34;
</span><span class="noop">  rule TealField2String(AssetManager)             =&gt; &#34;AssetManager&#34;
</span><span class="noop">  rule TealField2String(AssetReserve)             =&gt; &#34;AssetReserve&#34;
</span><span class="noop">  rule TealField2String(AssetFreeze)              =&gt; &#34;AssetFreeze&#34;
</span><span class="noop">  rule TealField2String(AssetClawback)            =&gt; &#34;AssetClawback&#34;
</span><span class="noop">
</span><span class="noop">  rule TealField2String(AppApprovalProgram)       =&gt; &#34;AppApprovalProgram&#34;
</span><span class="noop">  rule TealField2String(AppClearStateProgram)     =&gt; &#34;AppClearStateProgram&#34;
</span><span class="noop">  rule TealField2String(AppGlobalNumUint)         =&gt; &#34;AppGlobalNumUint&#34;
</span><span class="noop">  rule TealField2String(AppGlobalNumByteSlice)    =&gt; &#34;AppGlobalNumByteSlice&#34;
</span><span class="noop">  rule TealField2String(AppLocalNumUint)          =&gt; &#34;AppLocalNumUint&#34;
</span><span class="noop">  rule TealField2String(AppLocalNumByteSlice)     =&gt; &#34;AppLocalNumByteSlice&#34;
</span><span class="noop">  rule TealField2String(AppExtraProgramPages)     =&gt; &#34;AppExtraProgramPages&#34;
</span><span class="noop">  rule TealField2String(AppCreator)               =&gt; &#34;AppCreator&#34;
</span><span class="noop">  rule TealField2String(AppAddress)               =&gt; &#34;AppAddress&#34;
</span><span class="noop">
</span><span class="noop">  rule TealField2String(TxID)                     =&gt; &#34;TxID&#34;
</span><span class="noop">  rule TealField2String(Sender)                   =&gt; &#34;Sender&#34;
</span><span class="noop">  rule TealField2String(Fee)                      =&gt; &#34;Fee&#34;
</span><span class="noop">  rule TealField2String(FirstValid)               =&gt; &#34;FirstValid&#34;
</span><span class="noop">  rule TealField2String(FirstValidTime)           =&gt; &#34;FirstValidTime&#34;
</span><span class="noop">  rule TealField2String(LastValid)                =&gt; &#34;LastValid&#34;
</span><span class="noop">  rule TealField2String(Note)                     =&gt; &#34;Note&#34;
</span><span class="noop">  rule TealField2String(Lease)                    =&gt; &#34;Lease&#34;
</span><span class="noop">  rule TealField2String(RekeyTo)                  =&gt; &#34;RekeyTo&#34;
</span><span class="noop">  rule TealField2String(TxType)                   =&gt; &#34;TxType&#34;
</span><span class="noop">  rule TealField2String(TypeEnum)                 =&gt; &#34;TypeEnum&#34;
</span><span class="noop">  rule TealField2String(GroupIndex)               =&gt; &#34;GroupIndex&#34;
</span><span class="noop">  rule TealField2String(LastLog)                  =&gt; &#34;LastLog&#34;
</span><span class="noop">  rule TealField2String(NumLogs)                  =&gt; &#34;NumLogs&#34;
</span><span class="noop">  rule TealField2String(Logs)                     =&gt; &#34;Logs&#34;
</span><span class="noop">  rule TealField2String(Receiver)                 =&gt; &#34;Receiver&#34;
</span><span class="noop">  rule TealField2String(Amount)                   =&gt; &#34;Amount&#34;
</span><span class="noop">  rule TealField2String(CloseRemainderTo)         =&gt; &#34;CloseRemainderTo&#34;
</span><span class="noop">  rule TealField2String(VotePK)                   =&gt; &#34;VotePK&#34;
</span><span class="noop">  rule TealField2String(SelectionPK)              =&gt; &#34;SelectionPK&#34;
</span><span class="noop">  rule TealField2String(VoteFirst)                =&gt; &#34;VoteFirst&#34;
</span><span class="noop">  rule TealField2String(VoteLast)                 =&gt; &#34;VoteLast&#34;
</span><span class="noop">  rule TealField2String(VoteKeyDilution)          =&gt; &#34;VoteKeyDilution&#34;
</span><span class="noop">  rule TealField2String(ConfigAsset)              =&gt; &#34;ConfigAsset&#34;
</span><span class="noop">  rule TealField2String(ConfigAssetTotal)         =&gt; &#34;ConfigAssetTotal&#34;
</span><span class="noop">  rule TealField2String(ConfigAssetDecimals)      =&gt; &#34;ConfigAssetDecimals&#34;
</span><span class="noop">  rule TealField2String(ConfigAssetDefaultFrozen) =&gt; &#34;ConfigAssetDefaultFrozen&#34;
</span><span class="noop">  rule TealField2String(ConfigAssetUnitName)      =&gt; &#34;ConfigAssetUnitName&#34;
</span><span class="noop">  rule TealField2String(ConfigAssetName)          =&gt; &#34;ConfigAssetName&#34;
</span><span class="noop">  rule TealField2String(ConfigAssetURL)           =&gt; &#34;ConfigAssetURL&#34;
</span><span class="noop">  rule TealField2String(ConfigAssetMetaDataHash)  =&gt; &#34;ConfigAssetMetaDataHash&#34;
</span><span class="noop">  rule TealField2String(ConfigAssetManager)       =&gt; &#34;ConfigAssetManager&#34;
</span><span class="noop">  rule TealField2String(ConfigAssetReserve)       =&gt; &#34;ConfigAssetReserve&#34;
</span><span class="noop">  rule TealField2String(ConfigAssetFreeze)        =&gt; &#34;ConfigAssetFreeze&#34;
</span><span class="noop">  rule TealField2String(ConfigAssetClawback)      =&gt; &#34;ConfigAssetClawback&#34;
</span><span class="noop">  rule TealField2String(XferAsset)                =&gt; &#34;XferAsset&#34;
</span><span class="noop">  rule TealField2String(AssetAmount)              =&gt; &#34;AssetAmount&#34;
</span><span class="noop">  rule TealField2String(AssetASender)             =&gt; &#34;AssetASender&#34;
</span><span class="noop">  rule TealField2String(AssetReceiver)            =&gt; &#34;AssetReceiver&#34;
</span><span class="noop">  rule TealField2String(AssetCloseTo)             =&gt; &#34;AssetCloseTo&#34;
</span><span class="noop">  rule TealField2String(FreezeAsset)              =&gt; &#34;FreezeAsset&#34;
</span><span class="noop">  rule TealField2String(FreezeAssetAccount)       =&gt; &#34;FreezeAssetAccount&#34;
</span><span class="noop">  rule TealField2String(FreezeAssetFrozen)        =&gt; &#34;FreezeAssetFrozen&#34;
</span><span class="noop">  rule TealField2String(ApplicationID)            =&gt; &#34;ApplicationID&#34;
</span><span class="noop">  rule TealField2String(OnCompletion)             =&gt; &#34;OnCompletion&#34;
</span><span class="noop">  rule TealField2String(NumAppArgs)               =&gt; &#34;NumAppArgs&#34;
</span><span class="noop">  rule TealField2String(NumAccounts)              =&gt; &#34;NumAccounts&#34;
</span><span class="noop">  rule TealField2String(ApprovalProgram)          =&gt; &#34;ApprovalProgram&#34;
</span><span class="noop">  rule TealField2String(ClearStateProgram)        =&gt; &#34;ClearStateProgram&#34;
</span><span class="noop">  rule TealField2String(ApplicationArgs)          =&gt; &#34;ApplicationArgs&#34;
</span><span class="noop">  rule TealField2String(Accounts)                 =&gt; &#34;Accounts&#34;
</span><span class="noop">  rule TealField2String(Applications)             =&gt; &#34;Applications&#34;
</span><span class="noop">  rule TealField2String(Assets)                   =&gt; &#34;Assets&#34;
</span><span class="noop">  rule TealField2String(AcctBalance)              =&gt; &#34;AcctBalance&#34;
</span><span class="noop">  rule TealField2String(AcctMinBalance)           =&gt; &#34;AcctMinBalance&#34;
</span><span class="noop">  rule TealField2String(AcctAuthAddr)             =&gt; &#34;AcctAuthAddr&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">  syntax String ::= TValue2String(TValue)         [function]
</span><span class="noop">                  | TValuePair2String(TValuePair) [function]
</span><span class="noop">  // -------------------------------------------------------
</span><span class="noop">  rule TValue2String(I:Int)              =&gt; Int2String(I)
</span><span class="noop">  rule TValue2String(S:String)           =&gt; &#34;\&#34;&#34; +String S +String &#34;\&#34;&#34;
</span><span class="noop">  rule TValue2String(H:HexToken)         =&gt; Hex2String(H)
</span><span class="noop">  rule TValue2String(B:Bytes)            =&gt; &#34;0x&#34; +String Base2String(Bytes2Int(B,BE,Unsigned), 16)
</span><span class="noop">  rule TValue2String(TA:TAddressLiteral) =&gt; TealAddress2String(TA)
</span><span class="noop">  rule TValuePair2String((TV, TV2))      =&gt; &#34;( &#34; +String TValue2String(TV) +String &#34;, &#34; +String  TValue2String(TV2) +String &#34; )&#34;
</span><span class="noop">
</span><span class="noop">  syntax String ::= TValueList2String(TValueNeList)         [function]
</span><span class="noop">                  | TValuePairList2String(TValuePairList)   [function]
</span><span class="noop">  // ---------------------------------------------------------------
</span><span class="noop">  rule TValueList2String(TV:TValue TVL:TValueNeList)           =&gt; TValue2String(TV) +&amp;+ TValueList2String(TVL)
</span><span class="noop">  rule TValueList2String(TV:TValue)                            =&gt; TValue2String(TV)
</span><span class="noop">  rule TValuePairList2String(TV:TValuePair TVL:TValuePairNeList) =&gt; TValuePair2String(TV) +&amp;+ TValuePairList2String(TVL)
</span><span class="noop">  rule TValuePairList2String(TV:TValuePair)                    =&gt; TValuePair2String(TV)
</span><span class="noop">
</span><span class="noop">  syntax String ::= IntToken2String(TUInt64Token) [function, hook(STRING.token2string)]
</span><span class="noop">  // ----------------------------------------------------------------------------------
</span><span class="noop">  rule IntToken2String(unknown)           =&gt; &#34;unknown&#34;
</span><span class="noop">  rule IntToken2String(pay)               =&gt; &#34;pay&#34;
</span><span class="noop">  rule IntToken2String(keyreg)            =&gt; &#34;keyreg&#34;
</span><span class="noop">  rule IntToken2String(acfg)              =&gt; &#34;acfg&#34;
</span><span class="noop">  rule IntToken2String(axfer)             =&gt; &#34;axfer&#34;
</span><span class="noop">  rule IntToken2String(afrz)              =&gt; &#34;afrz&#34;
</span><span class="noop">  rule IntToken2String(appl)              =&gt; &#34;appl&#34;
</span><span class="noop">  rule IntToken2String(NoOp)              =&gt; &#34;NoOp&#34;
</span><span class="noop">  rule IntToken2String(OptIn)             =&gt; &#34;OptIn&#34;
</span><span class="noop">  rule IntToken2String(CloseOut)          =&gt; &#34;CloseOut&#34;
</span><span class="noop">  rule IntToken2String(ClearState)        =&gt; &#34;ClearState&#34;
</span><span class="noop">  rule IntToken2String(UpdateApplication) =&gt; &#34;UpdateApplication&#34;
</span><span class="noop">  rule IntToken2String(DeleteApplication) =&gt; &#34;DeleteApplication&#34;
</span><span class="noop">
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="avm/teal/teal-types.md">avm/teal/teal-types.md</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">TEAL Type Specification
</span><span class="noop">=======================
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module TEAL-TYPES-SYNTAX
</span><span class="noop">  import INT-SYNTAX
</span><span class="noop">  import STRING-SYNTAX
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">TEAL Literal Representation
</span><span class="noop">---------------------------
</span><span class="noop">
</span><span class="noop">There are only two types in TEAL:
</span><span class="noop">
</span><span class="noop">1.  `uint64`, i.e., 64-bit unsigned integers, represented using K&#39;s `Int` type:
</span><span class="noop">
</span><span class="noop">    ```k
</span><span class="noop">    syntax TUInt64 ::= Int
</span><span class="noop">    ```
</span><span class="noop">
</span><span class="noop">2. `uint8`, i.e., 8-bit unsigned integers, represented using K&#39;s `Int` type:
</span><span class="noop">
</span><span class="noop">    ```k
</span><span class="noop">    syntax TUInt8 ::= Int
</span><span class="noop">    ```
</span><span class="noop">
</span><span class="noop">3.  `bytes`, i.e., byte arrays, represented using K&#39;s `Bytes` type. Note there
</span><span class="noop">    are several representations of byte constants in TEAL:
</span><span class="noop">
</span><span class="noop">    - base64 and base32 encoded sequences,
</span><span class="noop">    - `0x`-prefixed hexadecimal values,
</span><span class="noop">    - and string literals.
</span><span class="noop">
</span><span class="noop">    ```k
</span><span class="noop">    syntax B64Encoded      [token]
</span><span class="noop">    syntax B32Encoded      [token]
</span><span class="noop">    syntax HexToken        [token]
</span><span class="noop">    syntax TAddressLiteral [token]
</span><span class="noop">
</span><span class="noop">    syntax TBytes ::= TBytesLiteral
</span><span class="noop">                    | TAddressLiteral
</span><span class="noop">
</span><span class="noop">    syntax TBytesLiteral ::= &#34;base64&#34; B64Encoded
</span><span class="noop">                           | &#34;b64&#34;    B64Encoded
</span><span class="noop">                           | &#34;base64&#34; &#34;(&#34; B64Encoded &#34;)&#34;
</span><span class="noop">                           | &#34;b64&#34;    &#34;(&#34; B64Encoded &#34;)&#34;
</span><span class="noop">                           | &#34;base32&#34; B32Encoded
</span><span class="noop">                           | &#34;b32&#34;    B32Encoded
</span><span class="noop">                           | &#34;base32&#34; &#34;(&#34; B32Encoded &#34;)&#34;
</span><span class="noop">                           | &#34;b32&#34;    &#34;(&#34; B32Encoded &#34;)&#34;
</span><span class="noop">                           | HexToken
</span><span class="noop">                           | String
</span><span class="noop">    ```
</span><span class="noop">
</span><span class="noop">TEAL TValue Representation
</span><span class="noop">--------------------------
</span><span class="noop">
</span><span class="noop">The `TValue` sort represents all possible TEAL values.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TValue ::= TUInt64 | TBytes
</span><span class="noop">  syntax TValueNeList ::= TValue | TValue TValueNeList
</span><span class="noop">  syntax TValueList ::= &#34;.TValueList&#34; [klabel(.TValueList), symbol] | TValueNeList
</span><span class="noop">  syntax MaybeTValue ::= &#34;NoTValue&#34; [klabel(NoTValue), symbol] | TValue
</span><span class="noop">
</span><span class="noop">  syntax TValuePair ::= &#34;(&#34; TValue &#34;,&#34; TValue &#34;)&#34;
</span><span class="noop">  syntax TValuePairNeList ::= TValuePair | TValuePair TValuePairNeList
</span><span class="noop">  syntax TValuePairList ::= &#34;.TValuePairList&#34; | TValuePairNeList
</span><span class="noop">  syntax MaybeTValuePair ::= &#34;NoTValuePair&#34; | TValuePair
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">endmodule
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">TEAL Type Processing
</span><span class="noop">--------------------
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">module TEAL-TYPES
</span><span class="noop">  import TEAL-TYPES-SYNTAX
</span><span class="noop">  import BOOL
</span><span class="noop">  import K-EQUAL
</span><span class="noop">  import BYTES
</span><span class="noop">  import INT
</span><span class="noop">  import STRING
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Type Representation
</span><span class="noop">
</span><span class="noop">Here we define our internal type representations.
</span><span class="noop">
</span><span class="noop">Our unsigned integers have maximum values.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Int ::= &#34;MAX_UINT8&#34;   [macro]
</span><span class="noop">               | &#34;MAX_UINT64&#34;  [macro]
</span><span class="noop">               | &#34;MAX_UINT128&#34; [macro]
</span><span class="noop">  // ---------------------------------
</span><span class="hit">  rule MAX_UINT8   =&gt; 255                                     // 2 ^Int 8   -Int 1
</span><span class="hit">  rule MAX_UINT64  =&gt; 18446744073709551615                    // 2 ^Int 64  -Int 1
</span><span class="hit">  rule MAX_UINT128 =&gt; 340282366920938463463374607431768211455 // 2 ^Int 128 -Int 1
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">Longer 128-bit Integers may need to be broken down into two 64-bit integers (to be able to store
</span><span class="noop">them on the stack). This is facilitated by two operations:
</span><span class="noop">
</span><span class="noop">1.  Computing the lower 64-bit segment of an unsigned 128-bit integer
</span><span class="noop">
</span><span class="noop">    ```k
</span><span class="noop">      syntax Int ::= lowerU64(Int) [function]
</span><span class="miss">      rule lowerU64(I) =&gt; I &amp;Int MAX_UINT64
</span><span class="noop">    ```
</span><span class="noop">
</span><span class="noop">2.  Computing the upper 64-bit segment of an unsigned 128-bit integer
</span><span class="noop">
</span><span class="noop">    ```k
</span><span class="noop">      syntax Int ::= upperU64(Int) [function]
</span><span class="miss">      rule upperU64(I) =&gt; I &gt;&gt;Int 64
</span><span class="noop">    ```
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">All `TBytes` literals are interpreted into the K `Bytes` type.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TBytes ::= Bytes
</span><span class="noop">
</span><span class="noop">  syntax Bytes ::= normalizeB(TBytes) [function]
</span><span class="noop">  // -------------------------------------------
</span><span class="hit">  rule normalizeB(B:Bytes)  =&gt; B
</span><span class="hit">  rule normalizeB(S:String) =&gt; String2Bytes(S)
</span><span class="hit">  rule normalizeB(H:HexToken) =&gt; prepBytesString(Hex2String(H))
</span><span class="hit">  rule normalizeB(TA:TAddressLiteral) =&gt; DecodeAddressString(TealAddress2String(TA))
</span><span class="noop">
</span><span class="noop">  syntax Bytes ::= prepBytesString(String) [function]
</span><span class="noop">  // ------------------------------------------------
</span><span class="hit">  rule prepBytesString(S:String) =&gt; #ParseBytes(substrString(S, 2, lengthString(S)), .Bytes)
</span><span class="noop">
</span><span class="noop">  syntax Bytes ::= #ParseBytes(String, Bytes) [function]
</span><span class="noop">  // ---------------------------------------------------
</span><span class="hit">  rule #ParseBytes(&#34;&#34;, ByteStr) =&gt; ByteStr
</span><span class="hit">  rule #ParseBytes(Hex, ByteStr)
</span><span class="noop">    =&gt; #ParseBytes(substrString(Hex, 2, lengthString(Hex)),
</span><span class="noop">                   ByteStr
</span><span class="noop">            +Bytes Int2Bytes(1, String2Base(substrString(Hex, 0, 2), 16), BE))
</span><span class="noop">    requires Hex =/=String &#34;&#34;
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">It is sometimes useful to go from the byte representation back to the token.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TAddressLiteral ::= Bytes2TAddressLiteral(Bytes) [function]
</span><span class="noop">  // ---------------------------------------------------------------
</span><span class="miss">  rule Bytes2TAddressLiteral(B) =&gt; String2TealAddress(EncodeAddressBytes(B))
</span><span class="noop">
</span><span class="noop">  syntax HexToken ::= Bytes2HexToken(Bytes) [function]
</span><span class="noop">  // -------------------------------------------------
</span><span class="miss">  rule Bytes2HexToken(B) =&gt; String2Hex(&#34;0x&#34; +String Base2String(Bytes2Int(B, BE, Unsigned), 16))
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">We use several hooks which convert between token and string representations.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax String          ::= TealAddress2String(TAddressLiteral) [function, functional, hook(STRING.token2string)]
</span><span class="noop">  syntax String          ::= Hex2String(HexToken)                [function, functional, hook(STRING.token2string)]
</span><span class="noop">  syntax TAddressLiteral ::= String2TealAddress(String)          [function, hook(STRING.string2token)]
</span><span class="noop">  syntax HexToken        ::= String2Hex(String)                  [function, hook(STRING.string2token)]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">We also need hooks which convert between the string and byte representations of TEAL addresses.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Bytes  ::= DecodeAddressString(String) [function]
</span><span class="noop">  syntax String ::= EncodeAddressBytes(Bytes)   [function]
</span><span class="noop">  // -----------------------------------------------------
</span><span class="hit">  rule DecodeAddressString(S) =&gt; DecodeAddressStringInternal(S) requires IsAddressValid(S)
</span><span class="miss">  rule EncodeAddressBytes(B)  =&gt; EncodeAddressBytesInternal(B)  requires lengthBytes(B)  ==Int 32
</span><span class="noop">
</span><span class="noop">  syntax Bytes  ::= DecodeAddressStringInternal(String) [function, hook(KAVM.address_decode)]
</span><span class="noop">  syntax String ::= EncodeAddressBytesInternal(Bytes)   [function, hook(KAVM.address_encode)]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">We also have a hook just for checking whether an address is valid.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Bool ::= IsAddressValid(String) [function, hook(KAVM.check_address)]
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### TEAL Value Processing
</span><span class="noop">
</span><span class="noop">We expose several functions for working with lists.
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TValue ::= getTValueAt(Int, TValueNeList) [function]
</span><span class="noop">  //---------------------------------------------------------
</span><span class="hit">  rule getTValueAt(I, _ VL) =&gt; getTValueAt(I -Int 1, VL)
</span><span class="noop">    requires I &gt;Int 0
</span><span class="hit">  rule getTValueAt(0, V _) =&gt; V
</span><span class="hit">  rule getTValueAt(0, V  ) =&gt; V
</span><span class="noop">
</span><span class="noop">  syntax Int ::= size(TValueList) [function, smtlib(tvlistsize)]
</span><span class="noop">  // ---------------------------------------
</span><span class="hit">  rule size(_ VL:TValueNeList) =&gt; 1 +Int size(VL)
</span><span class="hit">  rule size(_:TValue       ) =&gt; 1
</span><span class="hit">  rule size(.TValueList    ) =&gt; 0
</span><span class="noop">
</span><span class="noop">  syntax Bool ::= contains(TValueList, TValue) [function, functional]
</span><span class="noop">  // ----------------------------------------------------------------
</span><span class="hit">  rule contains(V1:TValue  _:TValueNeList, V1:TValue) =&gt; true
</span><span class="hit">  rule contains(V1:TValue VL:TValueNeList, V2:TValue) =&gt; contains(VL, V2) requires V1 =/=K V2
</span><span class="hit">  rule contains(V1:TValue                , V2:TValue) =&gt; V1 ==K V2
</span><span class="hit">  rule contains(              .TValueList,  _:TValue) =&gt; false 
</span><span class="noop">
</span><span class="noop">  syntax TValueNeList ::= reverse(TValueNeList) [function]
</span><span class="noop">  // -----------------------------------------------------
</span><span class="miss">  rule reverse(V:TValue VL) =&gt; append(V, reverse(VL))
</span><span class="miss">  rule reverse(V:TValue   ) =&gt; V
</span><span class="noop">
</span><span class="noop">  syntax TValueNeList ::= append(TValue, TValueList) [function]
</span><span class="noop">  // ----------------------------------------------------------
</span><span class="hit">  rule append(V, V&#39;:TValue VL) =&gt; V&#39; append(V, VL)
</span><span class="hit">  rule append(V, V&#39;:TValue   ) =&gt; V&#39; V
</span><span class="hit">  rule append(V, .TValueList ) =&gt; V
</span><span class="noop">
</span><span class="noop">  syntax TValuePairList ::= reverse(TValuePairList) [function]
</span><span class="noop">  // ---------------------------------------------------------
</span><span class="miss">  rule reverse(V:TValuePair VL) =&gt; append(V, reverse(VL))
</span><span class="miss">  rule reverse(V:TValuePair   ) =&gt; V
</span><span class="noop">
</span><span class="noop">  syntax TValuePairNeList ::= append(TValuePair, TValuePairList) [function]
</span><span class="noop">  // ----------------------------------------------------------------------
</span><span class="miss">  rule append(V, V&#39;:TValuePair VL) =&gt; V&#39; append(V, VL)
</span><span class="miss">  rule append(V, V&#39;:TValuePair   ) =&gt; V&#39; V
</span><span class="noop">
</span><span class="noop">  syntax TValueList ::= convertToBytes(TValueList) [function, functional]
</span><span class="noop">  //---------------------------------------------------------------------
</span><span class="hit">  rule convertToBytes(.TValueList) =&gt; .TValueList
</span><span class="hit">  rule convertToBytes(B:TBytes) =&gt; B
</span><span class="hit">  rule convertToBytes(I:TUInt64) =&gt; Int2Bytes({I}:&gt;Int, BE, Unsigned)
</span><span class="hit">  rule convertToBytes(B:TBytes L:TValueNeList) =&gt; (B {convertToBytes(L)}:&gt;TValueNeList)
</span><span class="miss">  rule convertToBytes(I:TUInt64 L:TValueNeList) =&gt; (Int2Bytes({I}:&gt;Int, BE, Unsigned) {convertToBytes(L)}:&gt;TValueNeList)
</span><span class="noop">
</span><span class="noop">  syntax Int ::= sizeInBytes(TValue) [function, functional]
</span><span class="noop">  //--------------------------------
</span><span class="hit">  rule sizeInBytes(_:TUInt64) =&gt; 64
</span><span class="hit">  rule sizeInBytes(B:TBytes) =&gt; lengthBytes({B}:&gt;Bytes)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">TValue normaliziation converts higher-level type representations in TEAL into
</span><span class="noop">our internal K representation:
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax TValue ::= normalize(TValue) [function]
</span><span class="noop">  // -------------------------------------------
</span><span class="hit">  rule normalize(V:TUInt64) =&gt; V
</span><span class="hit">  rule normalize(V:TBytes) =&gt; normalizeB(V)
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">### Boolean conversions
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">  syntax Bool ::= int2Bool(Int) [function, functional]
</span><span class="hit">  rule int2Bool(0) =&gt; false
</span><span class="hit">  rule int2Bool(A) =&gt; true requires A =/=Int 0
</span><span class="noop">
</span><span class="noop">  syntax Int ::= bool2Int(Bool)  [function, functional, smtlib(bool2Int)]
</span><span class="hit">  rule bool2Int(true ) =&gt; 1
</span><span class="hit">  rule bool2Int(false) =&gt; 0
</span><span class="noop">```
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">```k
</span><span class="noop">endmodule
</span><span class="noop">```
</span></pre>
      </td>
    </tr>
  </tbody>
</table>

    </div>
  </body>
</html>
