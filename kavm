#!/usr/bin/env bash

set -euo pipefail

TOOL_NAME=KAVM
TOOL_ENV_PREFIX=KAVM


debug=false
profile=false
stderr=false
verbose=false

notif() { echo "== ${TOOL_NAME}: $*" >&2 ; }

fatal() { notif "[FATAL] $*" ; exit 1 ; }

execute () {
    (   if ${stderr}; then
            exec > >(tee /dev/stderr)
        fi
        if ${profile}; then
            TIMEFORMAT="%lR %lU %lS $*"
            time "$@"
        else
            "$@"
        fi
    )
}

INSTALL_BIN="$(cd $(dirname $0) && pwd)"
INSTALL_LIB="$(dirname ${INSTALL_BIN})/lib/kavm"
INSTALL_INCLUDE=${INSTALL_LIB}/include

install_k_bin=${INSTALL_LIB}/kframework/bin
plugin_include=${INSTALL_LIB}/blockchain-k-plugin/include
libff_dir=${INSTALL_LIB}/libff

export PATH="$install_k_bin:$INSTALL_BIN:$INSTALL_LIB:$PATH"
export LD_LIBRARY_PATH=${LD_LIBRARY_PATH:-}:/usr/local/lib

# Runners
# -------

run_kompile() {
    local kompile_opts openssl_root bitcoin_libexec brew_root

    kompile_opts=( "${run_file}" --directory "${backend_dir}"                            )
    kompile_opts+=( --md-selector "k & ((! type) | exec)"                                )
    kompile_opts+=( -I "${INSTALL_INCLUDE}/kframework" -I "${plugin_include}/kframework" )
    kompile_opts+=( --hook-namespaces "KRYPTO CLARITY"                                   )
    kompile_opts+=( --emit-json                                                          )
    kompile_opts+=( --backend llvm                                                       )
    ! ${verbose} || kompile_opts+=(--verbose)

    kompile_opts+=( -ccopt -I${libff_dir}/include -ccopt -L${libff_dir}/lib              )
    kompile_opts+=( -ccopt ${plugin_include}/c/plugin_util.cpp                           )
    kompile_opts+=( -ccopt ${plugin_include}/c/crypto.cpp                                )
    kompile_opts+=( -ccopt ${plugin_include}/c/blake2.cpp                                )
    kompile_opts+=( -ccopt ${INSTALL_INCLUDE}/c/algorand.cpp                             )
    kompile_opts+=( -ccopt ${INSTALL_INCLUDE}/c/base.cpp                                 )
    kompile_opts+=( -ccopt ${INSTALL_INCLUDE}/c/mnemonic.cpp                             )
    kompile_opts+=( -ccopt ${INSTALL_INCLUDE}/c/hooks.cpp                                )
    kompile_opts+=( -ccopt -g -ccopt -std=c++14                                          )
    kompile_opts+=( -ccopt -lcryptopp -ccopt -lsecp256k1 -ccopt -lff -ccopt -lcurl -ccopt -lssl -ccopt -lcrypto )
    if [[ "$(uname -s)" == 'Linux' ]]; then
        kompile_opts+=( -ccopt -lprocps )
    elif [[ "$(uname -s)" == 'Darwin' ]]; then
        openssl_root="$(brew --prefix openssl)"
        bitcoin_libexec="$(brew --prefix libbitcoin)/libexec"
        brew_root="$(brew --prefix)"
        kompile_opts+=( -ccopt -I${brew_root}/include -ccopt -L/${brew_root}/lib            )
        kompile_opts+=( -ccopt -I${openssl_root}/include -ccopt -L${openssl_root}/lib       )
        kompile_opts+=( -ccopt -I${bitcoin_libexec}/include -ccopt -L${bitcoin_libexec}/lib )
    fi

    execute kompile "${kompile_opts[@]}" "$@"
}

run_kast() {
    local output_mode kast_args
    [[ $# -lt 1 ]] && fatal "kast: no output mode provided"
    output_mode="$1" ; shift
    kast_args=(--directory "${backend_dir}" "${run_file}" --output "${output_mode}")
    filename=$(basename -- "${run_file}")
    extension="${filename##*.}"
    case "$extension" in
        avm-simulation) kast_args+=(--sort AVMSimulation); kast_args+=(--module AVM-EXECUTION) ;;
        teal)           kast_args+=(--sort TealInputPgm); kast_args+=(--module TEAL-PARSER-SYNTAX) ;;
        teals)          kast_args+=(--sort TealPrograms); kast_args+=(--module TEAL-PARSER-SYNTAX) ;;
        *)              fatal "unrecognized file extension .${extension}; kavm kast expects .avm-simulation, .teal or .teals";;
    esac
    execute kast "${kast_args[@]}" "$@"
}

run_parse() {
    local kparse_args
    kparse_args=(--directory "${backend_dir}" "${run_file}")
    ! ${profile} || kparse_args+=(--profile)
    filename=$(basename -- "${run_file}")
    extension="${filename##*.}"
    case "$extension" in
        avm-simulation) kparse_args+=(--sort AVMSimulation); kparse_args+=(--module AVM-EXECUTION) ;;
        teal)           kparse_args+=(--sort TealInputPgm); kparse_args+=(--module TEAL-PARSER-SYNTAX) ;;
        teals)          kparse_args+=(--sort TealPrograms); kparse_args+=(--module TEAL-PARSER-SYNTAX) ;;
        *)              fatal "unrecognized file extension .${extension}; kavm parse expects .avm-simulation, .teal or .teals";;
    esac
    execute kparse "${kparse_args[@]}" "$@"
}

run_krun() {
    local krun_args teal_programs
    krun_args=(--directory "${backend_dir}")
    [[ -n ${depth} ]] && krun_args+=(--depth ${depth})
    ! ${profile} || krun_args+=(--profile)
    ! ${verbose} || krun_args+=(--verbose)
    # TEAL source code is fetched from .teal files in ./tests/teal/
    # by scanning the test scenario "${run_file}" for "declareTealSource <path>" commands
    for TEAL_SRC in $(cat $run_file | grep declareTealSource | cut -d " " -f2 | tr -d '";')
    do
      teal_programs+=$(cat $(realpath $TEAL_SRC))";"
    done
    teal_programs+=".TealPrograms"
    krun_args+=(-cTEAL_PROGRAMS="$teal_programs")
    krun_args+=(-pTEAL_PROGRAMS="./scripts/parse-teal-programs.sh")
    # run_file will contain an AVM simulation scenario,
    # to be parsed with parse-avm-simulation.sh
    krun_args+=(--parser "./scripts/parse-avm-simulation.sh")
    execute krun "${krun_args[@]}" "${run_file}" "$@"
}

run_prove() {
    local kprovex_args
    kprovex_args=(--directory "${backend_dir}" "${run_file}")
    execute kprovex "${kprovex_args[@]}" -I "${INSTALL_LIB}/kframework" "$@"
}

# Helpers
# -------

display_help() {
    echo "
  Usage: $0 kast    <options> <pgm>  <output format> <K arg>*
         $0 parse   <options> <pgm>
         $0 run     <options> <pgm>  <LLVM KRun arg>*
         $0 prove   <options> <spec> <KProve arg>*
         $0 kompile <options> <main> <Kompile arg>*

         $0 [help|--help|version|--version]

  Description:
         $0 kast    : Parse an AVM simulation scenario or a TEAL program and pretty print it.
         $0 parse   : Parse an AVM simulation scenario or a TEAL program and return true if well-formed.
         $0 run     : Run a AVM simulation scenario.
         $0 prove   : [NOT YET IMPLEMENTED] Run a reachability proof using KAVM symbolic execution.
         $0 kompile : Kompile a definition that uses KAVM

         $0 help    : Display this help message.
         $0 version : Display the versions of ${TOOL_NAME}, K, Kore, and Z3 in use.

  Options:
         --backend [avm-llvm|avm-haskell]
         The mode to use for executing the command:
            avm-llvm is for fast concrete execution of AVM transaction groups using the K LLVM backend;
            avm-haskell is for concrete and symbolic execution of AVM transaction groups using the K Haskell backend;
            Default: avm-llvm

         --depth <natural number>
         For all backends, controls the maximum number of steps that the interpreter
         will take.
         Default: Infinite

         --stderr
         This option causes the VM to capture its entire standard output and copy it
         in an unprocessed fashion to standard error. The output will still appear
         on standard output as well in case additional processing is requested.
         Default: Disabled

  Note:
        <pgm> is a path to a file containing the program/test.
        <spec> is a K specification to be proved.
        <main> is a K definition to be kompiled, which may include files from KAVM.
        <K arg> is an argument you want to pass to K.
        <LLVM KRun arg> are arguments to pass to llvm-krun.
        <KProve arg> are arguments to pass to the prover.
        <Kompile arg> are arguments to pass to kompile.
        <output format> is the format for Kast to output the term in.
"
}

# Main
# ----

if [[ $# -eq 0 ]] || [[ "$1" == 'help' ]] || [[ "$1" == '--help' ]] ; then
    display_help
    exit 0
fi

run_command="$1" ; shift

if [[ "${run_command}" == 'version' ]] || [[ "${run_command}" == '--version' ]]; then
    cat "${INSTALL_LIB}/version"
    exit 0
fi

backend="avm-llvm"
backend_dir=""
depth=
teal_sources=
args=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --backend)       backend="$2"      ; shift 2 ;;
        --directory)     backend_dir="$2"  ; shift 2 ;;
        --debug)         debug=true        ; shift   ;;
        --depth)         depth=$2          ; shift 2 ;;
        --stderr)        stderr=true       ; shift   ;;
        --profile)       profile=true      ; shift   ;;
        --verbose)       verbose=true      ; shift   ;;
        *)               args+=("$1")      ; shift   ;;
    esac
done

! ${debug} || set -x
[[ "${#args[@]}" -eq 0 ]] || set -- "${args[@]}"
! ${debug} || set -x

case "$backend" in
    llvm) backend=avm-llvm ;;
esac
backend_dir="${backend_dir:-${INSTALL_LIB}/$backend}"

run_file="$1" ; shift

# Invoke the appropriate runner
case "${run_command}" in
    # Running
    kompile) run_kompile "$@"                                  ;;
    kast)    run_kast    "$@"                                  ;;
    parse)   run_parse   "$@"                                  ;;
    run)     run_krun    "$@"                                  ;;
    prove)   run_prove   "$@"                                  ;;
    *)       $0 help ; fatal "Unknown command: ${run_command}" ;;
esac
