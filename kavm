#!/usr/bin/env bash

set -euo pipefail

TOOL_NAME=KAVM
TOOL_ENV_PREFIX=KAVM


debug=false
profile=false
stderr=false
verbose=false

notif() { echo "== ${TOOL_NAME}: $*" >&2 ; }

fatal() { notif "[FATAL] $*" ; exit 1 ; }

execute () {
    (   if ${stderr}; then
            exec > >(tee /dev/stderr)
        fi
        if ${profile}; then
            TIMEFORMAT="%lR %lU %lS $*"
            time "$@"
        else
            "$@"
        fi
    )
}

INSTALL_BIN="$(cd $(dirname $0) && pwd)"
INSTALL_LIB="$(dirname ${INSTALL_BIN})/lib/kavm"
INSTALL_INCLUDE=${INSTALL_LIB}/include

install_k_bin=${INSTALL_LIB}/kframework/bin

export PATH="$install_k_bin:$INSTALL_BIN:$INSTALL_LIB:$PATH"
export LD_LIBRARY_PATH=${LD_LIBRARY_PATH:-}:/usr/local/lib

# Runners
# -------

run_kast() {
    local output_mode kast_args
    [[ $# -lt 1 ]] && fatal "kast: no output mode provided"
    output_mode="$1" ; shift
    kast_args=(--directory "${mode_dir}" "${run_file}" --output "${output_mode}")
    execute kast "${kast_args[@]}" "$@"
}

run_parse() {
    local kparse_args
    kparse_args=(--directory "${mode_dir}" "${run_file}")
    ! ${profile} || kparse_args+=(--profile)
    execute kparse "${kparse_args[@]}" "$@"
}

run_krun() {
    local krun_args teal_programs
    krun_args=(--directory "${mode_dir}")
    [[ -n ${depth} ]] && krun_args+=(--depth ${depth})
    ! ${profile} || krun_args+=(--profile)
    ! ${verbose} || krun_args+=(--verbose)
    # TEAL source code is fetched from .teal files in ./tests/teal/
    # by scanning the test scenario "${run_file}" for "declareTealSource <path>" commands
    for TEAL_SRC in $(cat $run_file | grep declareTealSource | cut -d " " -f2 | tr -d '";')
    do
      teal_programs+=$(cat $(realpath $TEAL_SRC))";"
    done
    teal_programs+=".TealPrograms"
    krun_args+=(-cTEAL_PROGRAMS="$teal_programs")
    krun_args+=(-pTEAL_PROGRAMS="./scripts/parse-teal-programs.sh")
    # run_file will contain an AVM simulation scenario,
    # to be parsed with parse-avm-simulation.sh
    krun_args+=(--parser "./scripts/parse-avm-simulation.sh")
    execute krun "${krun_args[@]}" "${run_file}" "$@"
}

run_prove() {
    local kprovex_args
    kprovex_args=(--directory "${mode_dir}" "${run_file}")
    execute kprovex "${kprovex_args[@]}" -I "${INSTALL_LIB}/kframework" "$@"
}

# Helpers
# -------

display_help() {
    echo "
  Usage: $0 kast  <options> <pgm>  <output format> <K arg>*
         $0 parse <options> <pgm>
         $0 run   <options> <pgm>  <LLVM KRun arg>*
         $0 prove <options> <spec> <KProve arg>*

         $0 [help|--help|version|--version]

  Description:
         $0 kast  : Parse a single program or test and pretty print it.
         $0 parse : Parse a single program and return true if well-formed.
         $0 run   : Run a single program or test using the fast bison parser.
         $0 prove : Run a reachability proof using KAVM symbolic execution.

         $0 help    : Display this help message.
         $0 version : Display the versions of ${TOOL_NAME}, K, Kore, and Z3 in use.

  Options:
         --mode [avm|legacy-teal]
         The mode to use for executing the command:
            avm is for executing/proving AVM transaction groups;
            teal is for executing/proving a single TEAL program wrapped in a singleton transaction group.
            Default: avm

         --depth <natural number>
         For all modes, controls the maximum number of steps that the interpreter
         will take.
         Default: Infinite

         --stderr
         This option causes the VM to capture its entire standard output and copy it
         in an unprocessed fashion to standard error. The output will still appear
         on standard output as well in case additional processing is requested.
         Default: Disabled

  Note:
        <pgm> is a path to a file containing the program/test.
        <spec> is a K specification to be proved.
        <K arg> is an argument you want to pass to K.
        <LLVM KRun arg> are arguments to pass to llvm-krun.
        <KProve arg> are arguments to pass to the prover.
        <output format> is the format for Kast to output the term in.
"
}

# Main
# ----

if [[ $# -eq 0 ]] || [[ "$1" == 'help' ]] || [[ "$1" == '--help' ]] ; then
    display_help
    exit 0
fi

run_command="$1" ; shift

if [[ "${run_command}" == 'version' ]] || [[ "${run_command}" == '--version' ]]; then
    cat "${INSTALL_LIB}/version"
    exit 0
fi

mode="avm"
mode_dir=""
depth=
teal_sources=
args=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode)          mode="$2"         ; shift 2 ;;
        --mode-dir)      mode_dir="$2"     ; shift 2 ;;
        --debug)         debug=true        ; shift   ;;
        --depth)         depth=$2          ; shift 2 ;;
        --stderr)        stderr=true       ; shift   ;;
        --profile)       profile=true      ; shift   ;;
        --verbose)       verbose=true      ; shift   ;;
      # --teal-sources)  teal_sources="$2" ; shift 2 ;;
        *)               args+=("$1")      ; shift   ;;
    esac
done

! ${debug} || set -x
[[ "${#args[@]}" -eq 0 ]] || set -- "${args[@]}"
! ${debug} || set -x

case "$mode" in
    avm) mode=avm-llvm ;;
esac
mode_dir="${mode_dir:-${INSTALL_LIB}/$mode}"

run_file="$1" ; shift

# Invoke the appropriate runner
case "${run_command}" in
    # Running
    kast)  run_kast  "$@"                                    ;;
    parse) run_parse "$@"                                    ;;
    run)   run_krun  "$@"                                    ;;
    prove) run_prove "$@"                                    ;;
    *)     $0 help ; fatal "Unknown command: ${run_command}" ;;
esac
